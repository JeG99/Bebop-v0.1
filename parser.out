Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> routine0
Rule 1     routine0 -> ROUTINE ID SEMICOLON routine1 main0
Rule 2     routine1 -> class0 routine1
Rule 3     routine1 -> function0 routine1
Rule 4     routine1 -> declaration0 routine1
Rule 5     routine1 -> assignment0 routine1
Rule 6     routine1 -> empty
Rule 7     class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
Rule 8     class1 -> extension0
Rule 9     class1 -> empty
Rule 10    class2 -> attributes
Rule 11    class2 -> empty
Rule 12    class3 -> methods
Rule 13    class3 -> empty
Rule 14    function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
Rule 15    function1 -> type
Rule 16    function1 -> VOID
Rule 17    function2 -> simple_declaration function2
Rule 18    function2 -> simple_assignment function2
Rule 19    function2 -> empty
Rule 20    declaration0 -> ID declaration1 SEMICOLON
Rule 21    declaration1 -> type
Rule 22    declaration1 -> complex_type
Rule 23    declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET declaration2
Rule 24    declaration2 -> LSQRBRACKET exp0 RSQRBRACKET
Rule 25    declaration2 -> empty
Rule 26    assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON
Rule 27    assignment1 -> LSQRBRACKET exp0 RSQRBRACKET assignment2
Rule 28    assignment1 -> empty
Rule 29    assignment2 -> LSQRBRACKET exp0 RSQRBRACKET
Rule 30    assignment2 -> empty
Rule 31    constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0
Rule 32    extension0 -> data_access ID extension1
Rule 33    extension1 -> COMMA extension0
Rule 34    extension1 -> empty
Rule 35    attributes -> data_access simple_declaration attributes
Rule 36    attributes -> simple_assignment attributes
Rule 37    attributes -> empty
Rule 38    methods -> data_access function0 methods
Rule 39    methods -> empty
Rule 40    params0 -> type ID params1
Rule 41    params0 -> empty
Rule 42    params1 -> COMMA params0
Rule 43    params1 -> empty
Rule 44    function_block0 -> LBRACKET function_block1 RBRACKET
Rule 45    function_block1 -> function_statement function_block1
Rule 46    function_block1 -> empty
Rule 47    type -> INT
Rule 48    type -> FLOAT
Rule 49    type -> STRING
Rule 50    type -> BOOL
Rule 51    simple_declaration -> ID COLON type SEMICOLON
Rule 52    simple_assignment -> ID EQUALS expression0 SEMICOLON
Rule 53    complex_type -> ID
Rule 54    logic_or0 -> logic_and0 logic_or1
Rule 55    logic_or1 -> OR logic_or0
Rule 56    logic_or1 -> empty
Rule 57    logic_and0 -> logic_operand logic_and1
Rule 58    logic_and1 -> AND logic_and0
Rule 59    logic_and1 -> empty
Rule 60    logic_operand -> NOT expression0
Rule 61    exp0 -> term0 exp1
Rule 62    exp1 -> PLUS exp0
Rule 63    exp1 -> MINUS exp0
Rule 64    exp1 -> empty
Rule 65    term0 -> factor term1
Rule 66    term1 -> MULTIPLY term0
Rule 67    term1 -> DIVIDE term0
Rule 68    term1 -> empty
Rule 69    factor -> PLUS power0
Rule 70    factor -> MINUS power0
Rule 71    factor -> power0
Rule 72    power0 -> LPAREN exp0 RPAREN power2
Rule 73    power0 -> const_var power2
Rule 74    power0 -> function_call power2
Rule 75    power0 -> method_call0 power2
Rule 76    power0 -> attr_access0 power2
Rule 77    power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
Rule 78    power1 -> LSQRBRACKET exp0 RSQRBRACKET
Rule 79    power1 -> empty
Rule 80    power2 -> POWER power0
Rule 81    power2 -> SQRT power0
Rule 82    power2 -> empty
Rule 83    const_var -> CONST_INT
Rule 84    const_var -> CONST_FLOAT
Rule 85    const_var -> ID
Rule 86    function_call -> ID LPAREN function_call_params0 RPAREN
Rule 87    function_call_params0 -> expression0 function_call_params1
Rule 88    function_call_params0 -> CONST_STRING function_call_params1
Rule 89    function_call_params0 -> empty function_call_params1
Rule 90    function_call_params1 -> COMMA function_call_params0
Rule 91    function_call_params1 -> empty
Rule 92    expression0 -> exp0 expression1
Rule 93    expression0 -> CONST_BOOL expression1
Rule 94    expression0 -> attr_access0 expression1
Rule 95    expression1 -> empty
Rule 96    expression1 -> expression2
Rule 97    expression2 -> LTHAN expression3
Rule 98    expression2 -> GTHAN expression3
Rule 99    expression2 -> DIFFERENT expression3
Rule 100   expression2 -> EQUIVALENT expression3
Rule 101   expression3 -> exp0
Rule 102   expression3 -> CONST_BOOL
Rule 103   expression3 -> attr_access0
Rule 104   attr_access0 -> ID DOT ID attr_access1
Rule 105   attr_access1 -> DOT attr_access0
Rule 106   attr_access1 -> empty
Rule 107   method_call0 -> ID DOT method_call1 function_call
Rule 108   method_call1 -> ID DOT method_call1
Rule 109   method_call1 -> empty
Rule 110   data_access -> PRIVATE
Rule 111   data_access -> PUBLIC
Rule 112   function_statement -> simple_assignment
Rule 113   function_statement -> condition0
Rule 114   function_statement -> writing0
Rule 115   function_statement -> reading
Rule 116   function_statement -> return
Rule 117   function_statement -> function_call SEMICOLON
Rule 118   function_statement -> method_call0 SEMICOLON
Rule 119   function_statement -> while
Rule 120   condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
Rule 121   condition1 -> ELSE block0
Rule 122   condition1 -> empty
Rule 123   writing0 -> WRITE LPAREN writing1 LPAREN SEMICOLON
Rule 124   writing1 -> expression0 writing2
Rule 125   writing1 -> CONST_STRING writing2
Rule 126   writing2 -> COMMA writing1
Rule 127   writing2 -> empty
Rule 128   reading -> READ ID SEMICOLON
Rule 129   return -> RETURN expression0 SEMICOLON
Rule 130   return -> RETURN SEMICOLON
Rule 131   while -> WHILE LPAREN expression0 RPAREN block0
Rule 132   block0 -> LBRACKET block1 RBRACKET
Rule 133   block1 -> statement block1
Rule 134   block1 -> empty
Rule 135   statement -> assignment0
Rule 136   statement -> object_assignment
Rule 137   statement -> condition0
Rule 138   statement -> writing0
Rule 139   statement -> reading
Rule 140   statement -> return
Rule 141   statement -> function_call SEMICOLON
Rule 142   statement -> method_call0 SEMICOLON
Rule 143   statement -> while
Rule 144   object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
Rule 145   main0 -> MAIN LBRACKET main1 RBRACKET
Rule 146   main1 -> declaration0 main1
Rule 147   main1 -> statement main1
Rule 148   main1 -> empty
Rule 149   empty -> <empty>

Terminals, with rules where they appear

AND                  : 58
ARROW                : 14
BOOL                 : 50
CLASS                : 7
COLON                : 51
COMMA                : 33 42 90 126
CONSTRUCT            : 31
CONST_BOOL           : 93 102
CONST_FLOAT          : 84
CONST_INT            : 83
CONST_STRING         : 88 125
DEF                  : 14
DIFFERENT            : 99
DIVIDE               : 67
DOT                  : 104 105 107 108
ELSE                 : 121
EQUALS               : 26 52 144
EQUIVALENT           : 100
FLOAT                : 48
GTHAN                : 98
ID                   : 1 7 14 20 26 31 32 40 51 52 53 77 85 86 104 104 107 108 128 144 144
IF                   : 120
INT                  : 47
LBRACKET             : 7 44 132 145
LPAREN               : 14 31 72 86 120 123 123 131 144
LSQRBRACKET          : 14 14 23 24 27 29 77 78
LTHAN                : 97
MAIN                 : 145
MINUS                : 63 70
MULTIPLY             : 66
NEW                  : 144
NOT                  : 60
OR                   : 55
PLUS                 : 62 69
POWER                : 80
PRIVATE              : 110
PUBLIC               : 111
RBRACKET             : 7 44 132 145
READ                 : 128
RETURN               : 129 130
ROUTINE              : 1
RPAREN               : 14 31 72 86 120 131 144
RSQRBRACKET          : 14 14 23 24 27 29 77 78
SEMICOLON            : 1 7 20 26 51 52 117 118 120 123 128 129 130 141 142 144
SQRT                 : 81
STRING               : 49
VOID                 : 16
WHILE                : 131
WRITE                : 123
error                : 

Nonterminals, with rules where they appear

assignment0          : 5 135
assignment1          : 26
assignment2          : 27
attr_access0         : 76 94 103 105
attr_access1         : 104
attributes           : 10 35 36
block0               : 120 121 131
block1               : 132 133
class0               : 2
class1               : 7
class2               : 7
class3               : 7
complex_type         : 22
condition0           : 113 137
condition1           : 120
const_var            : 73
constructor          : 7
data_access          : 32 35 38
declaration0         : 4 146
declaration1         : 20
declaration2         : 23
empty                : 6 9 11 13 19 25 28 30 34 37 39 41 43 46 56 59 64 68 79 82 89 91 95 106 109 122 127 134 148
exp0                 : 23 24 27 29 62 63 72 77 78 92 101
exp1                 : 61
expression0          : 26 52 60 87 120 124 129 131
expression1          : 92 93 94
expression2          : 96
expression3          : 97 98 99 100
extension0           : 8 33
extension1           : 32
factor               : 65
function0            : 3 38
function1            : 14
function2            : 14 17 18
function_block0      : 14 31
function_block1      : 44 45
function_call        : 74 107 117 141
function_call_params0 : 86 90 144
function_call_params1 : 87 88 89
function_statement   : 45
logic_and0           : 54 58
logic_and1           : 57
logic_operand        : 57
logic_or0            : 55
logic_or1            : 54
main0                : 1
main1                : 145 146 147
method_call0         : 75 118 142
method_call1         : 107 108
methods              : 12 38
object_assignment    : 136
params0              : 14 31 42
params1              : 40
power0               : 69 70 71 80 81
power1               : 77
power2               : 72 73 74 75 76 77
reading              : 115 139
return               : 116 140
routine0             : 0
routine1             : 1 2 3 4 5
simple_assignment    : 18 36 112
simple_declaration   : 17 35
statement            : 133 147
term0                : 61 66 67
term1                : 65
type                 : 15 21 23 40 51
while                : 119 143
writing0             : 114 138
writing1             : 123 126
writing2             : 124 125

Parsing method: LALR

state 0

    (0) S' -> . routine0
    (1) routine0 -> . ROUTINE ID SEMICOLON routine1 main0

    ROUTINE         shift and go to state 2

    routine0                       shift and go to state 1

state 1

    (0) S' -> routine0 .



state 2

    (1) routine0 -> ROUTINE . ID SEMICOLON routine1 main0

    ID              shift and go to state 3


state 3

    (1) routine0 -> ROUTINE ID . SEMICOLON routine1 main0

    SEMICOLON       shift and go to state 4


state 4

    (1) routine0 -> ROUTINE ID SEMICOLON . routine1 main0
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID declaration1 SEMICOLON
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (149) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 149 (empty -> .)

    routine1                       shift and go to state 6
    class0                         shift and go to state 7
    function0                      shift and go to state 8
    declaration0                   shift and go to state 9
    assignment0                    shift and go to state 10
    empty                          shift and go to state 11

state 5

    (20) declaration0 -> ID . declaration1 SEMICOLON
    (26) assignment0 -> ID . assignment1 EQUALS expression0 SEMICOLON
    (21) declaration1 -> . type
    (22) declaration1 -> . complex_type
    (23) declaration1 -> . type LSQRBRACKET exp0 RSQRBRACKET declaration2
    (27) assignment1 -> . LSQRBRACKET exp0 RSQRBRACKET assignment2
    (28) assignment1 -> . empty
    (47) type -> . INT
    (48) type -> . FLOAT
    (49) type -> . STRING
    (50) type -> . BOOL
    (53) complex_type -> . ID
    (149) empty -> .

    LSQRBRACKET     shift and go to state 19
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    ID              shift and go to state 14
    EQUALS          reduce using rule 149 (empty -> .)

    declaration1                   shift and go to state 15
    assignment1                    shift and go to state 16
    type                           shift and go to state 17
    complex_type                   shift and go to state 18
    empty                          shift and go to state 20

state 6

    (1) routine0 -> ROUTINE ID SEMICOLON routine1 . main0
    (145) main0 -> . MAIN LBRACKET main1 RBRACKET

    MAIN            shift and go to state 26

    main0                          shift and go to state 25

state 7

    (2) routine1 -> class0 . routine1
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID declaration1 SEMICOLON
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (149) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 149 (empty -> .)

    class0                         shift and go to state 7
    routine1                       shift and go to state 27
    function0                      shift and go to state 8
    declaration0                   shift and go to state 9
    assignment0                    shift and go to state 10
    empty                          shift and go to state 11

state 8

    (3) routine1 -> function0 . routine1
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID declaration1 SEMICOLON
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (149) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 149 (empty -> .)

    function0                      shift and go to state 8
    routine1                       shift and go to state 28
    class0                         shift and go to state 7
    declaration0                   shift and go to state 9
    assignment0                    shift and go to state 10
    empty                          shift and go to state 11

state 9

    (4) routine1 -> declaration0 . routine1
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID declaration1 SEMICOLON
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (149) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 149 (empty -> .)

    declaration0                   shift and go to state 9
    routine1                       shift and go to state 29
    class0                         shift and go to state 7
    function0                      shift and go to state 8
    assignment0                    shift and go to state 10
    empty                          shift and go to state 11

state 10

    (5) routine1 -> assignment0 . routine1
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID declaration1 SEMICOLON
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (149) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 149 (empty -> .)

    assignment0                    shift and go to state 10
    routine1                       shift and go to state 30
    class0                         shift and go to state 7
    function0                      shift and go to state 8
    declaration0                   shift and go to state 9
    empty                          shift and go to state 11

state 11

    (6) routine1 -> empty .

    MAIN            reduce using rule 6 (routine1 -> empty .)


state 12

    (7) class0 -> CLASS . ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON

    ID              shift and go to state 31


state 13

    (14) function0 -> DEF . ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    ID              shift and go to state 32


state 14

    (53) complex_type -> ID .

    SEMICOLON       reduce using rule 53 (complex_type -> ID .)


state 15

    (20) declaration0 -> ID declaration1 . SEMICOLON

    SEMICOLON       shift and go to state 33


state 16

    (26) assignment0 -> ID assignment1 . EQUALS expression0 SEMICOLON

    EQUALS          shift and go to state 34


state 17

    (21) declaration1 -> type .
    (23) declaration1 -> type . LSQRBRACKET exp0 RSQRBRACKET declaration2

    SEMICOLON       reduce using rule 21 (declaration1 -> type .)
    LSQRBRACKET     shift and go to state 35


state 18

    (22) declaration1 -> complex_type .

    SEMICOLON       reduce using rule 22 (declaration1 -> complex_type .)


state 19

    (27) assignment1 -> LSQRBRACKET . exp0 RSQRBRACKET assignment2
    (61) exp0 -> . term0 exp1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    exp0                           shift and go to state 36
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 20

    (28) assignment1 -> empty .

    EQUALS          reduce using rule 28 (assignment1 -> empty .)


state 21

    (47) type -> INT .

    LSQRBRACKET     reduce using rule 47 (type -> INT .)
    SEMICOLON       reduce using rule 47 (type -> INT .)
    ID              reduce using rule 47 (type -> INT .)


state 22

    (48) type -> FLOAT .

    LSQRBRACKET     reduce using rule 48 (type -> FLOAT .)
    SEMICOLON       reduce using rule 48 (type -> FLOAT .)
    ID              reduce using rule 48 (type -> FLOAT .)


state 23

    (49) type -> STRING .

    LSQRBRACKET     reduce using rule 49 (type -> STRING .)
    SEMICOLON       reduce using rule 49 (type -> STRING .)
    ID              reduce using rule 49 (type -> STRING .)


state 24

    (50) type -> BOOL .

    LSQRBRACKET     reduce using rule 50 (type -> BOOL .)
    SEMICOLON       reduce using rule 50 (type -> BOOL .)
    ID              reduce using rule 50 (type -> BOOL .)


state 25

    (1) routine0 -> ROUTINE ID SEMICOLON routine1 main0 .

    $end            reduce using rule 1 (routine0 -> ROUTINE ID SEMICOLON routine1 main0 .)


state 26

    (145) main0 -> MAIN . LBRACKET main1 RBRACKET

    LBRACKET        shift and go to state 50


state 27

    (2) routine1 -> class0 routine1 .

    MAIN            reduce using rule 2 (routine1 -> class0 routine1 .)


state 28

    (3) routine1 -> function0 routine1 .

    MAIN            reduce using rule 3 (routine1 -> function0 routine1 .)


state 29

    (4) routine1 -> declaration0 routine1 .

    MAIN            reduce using rule 4 (routine1 -> declaration0 routine1 .)


state 30

    (5) routine1 -> assignment0 routine1 .

    MAIN            reduce using rule 5 (routine1 -> assignment0 routine1 .)


state 31

    (7) class0 -> CLASS ID . class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (8) class1 -> . extension0
    (9) class1 -> . empty
    (32) extension0 -> . data_access ID extension1
    (149) empty -> .
    (110) data_access -> . PRIVATE
    (111) data_access -> . PUBLIC

    LBRACKET        reduce using rule 149 (empty -> .)
    PRIVATE         shift and go to state 55
    PUBLIC          shift and go to state 56

    class1                         shift and go to state 51
    extension0                     shift and go to state 52
    empty                          shift and go to state 53
    data_access                    shift and go to state 54

state 32

    (14) function0 -> DEF ID . LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    LPAREN          shift and go to state 57


state 33

    (20) declaration0 -> ID declaration1 SEMICOLON .

    CLASS           reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)
    DEF             reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)
    ID              reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)
    MAIN            reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)
    IF              reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)
    WRITE           reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)
    READ            reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)
    RETURN          reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)
    WHILE           reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)
    RBRACKET        reduce using rule 20 (declaration0 -> ID declaration1 SEMICOLON .)


state 34

    (26) assignment0 -> ID assignment1 EQUALS . expression0 SEMICOLON
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_BOOL      shift and go to state 61
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    expression0                    shift and go to state 59
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 35

    (23) declaration1 -> type LSQRBRACKET . exp0 RSQRBRACKET declaration2
    (61) exp0 -> . term0 exp1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    exp0                           shift and go to state 63
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 36

    (27) assignment1 -> LSQRBRACKET exp0 . RSQRBRACKET assignment2

    RSQRBRACKET     shift and go to state 64


state 37

    (61) exp0 -> term0 . exp1
    (62) exp1 -> . PLUS exp0
    (63) exp1 -> . MINUS exp0
    (64) exp1 -> . empty
    (149) empty -> .

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    exp1                           shift and go to state 65
    empty                          shift and go to state 68

state 38

    (65) term0 -> factor . term1
    (66) term1 -> . MULTIPLY term0
    (67) term1 -> . DIVIDE term0
    (68) term1 -> . empty
    (149) empty -> .

    MULTIPLY        shift and go to state 70
    DIVIDE          shift and go to state 71
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    term1                          shift and go to state 69
    empty                          shift and go to state 72

state 39

    (69) factor -> PLUS . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    power0                         shift and go to state 73
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 40

    (71) factor -> power0 .

    MULTIPLY        reduce using rule 71 (factor -> power0 .)
    DIVIDE          reduce using rule 71 (factor -> power0 .)
    PLUS            reduce using rule 71 (factor -> power0 .)
    MINUS           reduce using rule 71 (factor -> power0 .)
    RSQRBRACKET     reduce using rule 71 (factor -> power0 .)
    LTHAN           reduce using rule 71 (factor -> power0 .)
    GTHAN           reduce using rule 71 (factor -> power0 .)
    DIFFERENT       reduce using rule 71 (factor -> power0 .)
    EQUIVALENT      reduce using rule 71 (factor -> power0 .)
    SEMICOLON       reduce using rule 71 (factor -> power0 .)
    RPAREN          reduce using rule 71 (factor -> power0 .)
    COMMA           reduce using rule 71 (factor -> power0 .)
    LPAREN          reduce using rule 71 (factor -> power0 .)


state 41

    (70) factor -> MINUS . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    power0                         shift and go to state 74
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 42

    (72) power0 -> LPAREN . exp0 RPAREN power2
    (61) exp0 -> . term0 exp1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    exp0                           shift and go to state 75
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 43

    (73) power0 -> const_var . power2
    (80) power2 -> . POWER power0
    (81) power2 -> . SQRT power0
    (82) power2 -> . empty
    (149) empty -> .

    POWER           shift and go to state 77
    SQRT            shift and go to state 78
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    power2                         shift and go to state 76
    empty                          shift and go to state 79

state 44

    (74) power0 -> function_call . power2
    (80) power2 -> . POWER power0
    (81) power2 -> . SQRT power0
    (82) power2 -> . empty
    (149) empty -> .

    POWER           shift and go to state 77
    SQRT            shift and go to state 78
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    power2                         shift and go to state 80
    empty                          shift and go to state 79

state 45

    (75) power0 -> method_call0 . power2
    (80) power2 -> . POWER power0
    (81) power2 -> . SQRT power0
    (82) power2 -> . empty
    (149) empty -> .

    POWER           shift and go to state 77
    SQRT            shift and go to state 78
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    power2                         shift and go to state 81
    empty                          shift and go to state 79

state 46

    (76) power0 -> attr_access0 . power2
    (80) power2 -> . POWER power0
    (81) power2 -> . SQRT power0
    (82) power2 -> . empty
    (149) empty -> .

    POWER           shift and go to state 77
    SQRT            shift and go to state 78
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    power2                         shift and go to state 82
    empty                          shift and go to state 79

state 47

    (77) power0 -> ID . LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (85) const_var -> ID .
    (86) function_call -> ID . LPAREN function_call_params0 RPAREN
    (107) method_call0 -> ID . DOT method_call1 function_call
    (104) attr_access0 -> ID . DOT ID attr_access1

  ! shift/reduce conflict for LPAREN resolved as shift
    LSQRBRACKET     shift and go to state 83
    POWER           reduce using rule 85 (const_var -> ID .)
    SQRT            reduce using rule 85 (const_var -> ID .)
    MULTIPLY        reduce using rule 85 (const_var -> ID .)
    DIVIDE          reduce using rule 85 (const_var -> ID .)
    PLUS            reduce using rule 85 (const_var -> ID .)
    MINUS           reduce using rule 85 (const_var -> ID .)
    RSQRBRACKET     reduce using rule 85 (const_var -> ID .)
    LTHAN           reduce using rule 85 (const_var -> ID .)
    GTHAN           reduce using rule 85 (const_var -> ID .)
    DIFFERENT       reduce using rule 85 (const_var -> ID .)
    EQUIVALENT      reduce using rule 85 (const_var -> ID .)
    SEMICOLON       reduce using rule 85 (const_var -> ID .)
    RPAREN          reduce using rule 85 (const_var -> ID .)
    COMMA           reduce using rule 85 (const_var -> ID .)
    LPAREN          shift and go to state 84
    DOT             shift and go to state 85

  ! LPAREN          [ reduce using rule 85 (const_var -> ID .) ]


state 48

    (83) const_var -> CONST_INT .

    POWER           reduce using rule 83 (const_var -> CONST_INT .)
    SQRT            reduce using rule 83 (const_var -> CONST_INT .)
    MULTIPLY        reduce using rule 83 (const_var -> CONST_INT .)
    DIVIDE          reduce using rule 83 (const_var -> CONST_INT .)
    PLUS            reduce using rule 83 (const_var -> CONST_INT .)
    MINUS           reduce using rule 83 (const_var -> CONST_INT .)
    RSQRBRACKET     reduce using rule 83 (const_var -> CONST_INT .)
    LTHAN           reduce using rule 83 (const_var -> CONST_INT .)
    GTHAN           reduce using rule 83 (const_var -> CONST_INT .)
    DIFFERENT       reduce using rule 83 (const_var -> CONST_INT .)
    EQUIVALENT      reduce using rule 83 (const_var -> CONST_INT .)
    SEMICOLON       reduce using rule 83 (const_var -> CONST_INT .)
    RPAREN          reduce using rule 83 (const_var -> CONST_INT .)
    COMMA           reduce using rule 83 (const_var -> CONST_INT .)
    LPAREN          reduce using rule 83 (const_var -> CONST_INT .)


state 49

    (84) const_var -> CONST_FLOAT .

    POWER           reduce using rule 84 (const_var -> CONST_FLOAT .)
    SQRT            reduce using rule 84 (const_var -> CONST_FLOAT .)
    MULTIPLY        reduce using rule 84 (const_var -> CONST_FLOAT .)
    DIVIDE          reduce using rule 84 (const_var -> CONST_FLOAT .)
    PLUS            reduce using rule 84 (const_var -> CONST_FLOAT .)
    MINUS           reduce using rule 84 (const_var -> CONST_FLOAT .)
    RSQRBRACKET     reduce using rule 84 (const_var -> CONST_FLOAT .)
    LTHAN           reduce using rule 84 (const_var -> CONST_FLOAT .)
    GTHAN           reduce using rule 84 (const_var -> CONST_FLOAT .)
    DIFFERENT       reduce using rule 84 (const_var -> CONST_FLOAT .)
    EQUIVALENT      reduce using rule 84 (const_var -> CONST_FLOAT .)
    SEMICOLON       reduce using rule 84 (const_var -> CONST_FLOAT .)
    RPAREN          reduce using rule 84 (const_var -> CONST_FLOAT .)
    COMMA           reduce using rule 84 (const_var -> CONST_FLOAT .)
    LPAREN          reduce using rule 84 (const_var -> CONST_FLOAT .)


state 50

    (145) main0 -> MAIN LBRACKET . main1 RBRACKET
    (146) main1 -> . declaration0 main1
    (147) main1 -> . statement main1
    (148) main1 -> . empty
    (20) declaration0 -> . ID declaration1 SEMICOLON
    (135) statement -> . assignment0
    (136) statement -> . object_assignment
    (137) statement -> . condition0
    (138) statement -> . writing0
    (139) statement -> . reading
    (140) statement -> . return
    (141) statement -> . function_call SEMICOLON
    (142) statement -> . method_call0 SEMICOLON
    (143) statement -> . while
    (149) empty -> .
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (144) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (120) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (123) writing0 -> . WRITE LPAREN writing1 LPAREN SEMICOLON
    (128) reading -> . READ ID SEMICOLON
    (129) return -> . RETURN expression0 SEMICOLON
    (130) return -> . RETURN SEMICOLON
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (131) while -> . WHILE LPAREN expression0 RPAREN block0

    ID              shift and go to state 90
    RBRACKET        reduce using rule 149 (empty -> .)
    IF              shift and go to state 100
    WRITE           shift and go to state 101
    READ            shift and go to state 102
    RETURN          shift and go to state 103
    WHILE           shift and go to state 104

    main1                          shift and go to state 86
    declaration0                   shift and go to state 87
    statement                      shift and go to state 88
    empty                          shift and go to state 89
    assignment0                    shift and go to state 91
    object_assignment              shift and go to state 92
    condition0                     shift and go to state 93
    writing0                       shift and go to state 94
    reading                        shift and go to state 95
    return                         shift and go to state 96
    function_call                  shift and go to state 97
    method_call0                   shift and go to state 98
    while                          shift and go to state 99

state 51

    (7) class0 -> CLASS ID class1 . LBRACKET class2 constructor class3 RBRACKET SEMICOLON

    LBRACKET        shift and go to state 105


state 52

    (8) class1 -> extension0 .

    LBRACKET        reduce using rule 8 (class1 -> extension0 .)


state 53

    (9) class1 -> empty .

    LBRACKET        reduce using rule 9 (class1 -> empty .)


state 54

    (32) extension0 -> data_access . ID extension1

    ID              shift and go to state 106


state 55

    (110) data_access -> PRIVATE .

    ID              reduce using rule 110 (data_access -> PRIVATE .)
    DEF             reduce using rule 110 (data_access -> PRIVATE .)


state 56

    (111) data_access -> PUBLIC .

    ID              reduce using rule 111 (data_access -> PUBLIC .)
    DEF             reduce using rule 111 (data_access -> PUBLIC .)


state 57

    (14) function0 -> DEF ID LPAREN . params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (40) params0 -> . type ID params1
    (41) params0 -> . empty
    (47) type -> . INT
    (48) type -> . FLOAT
    (49) type -> . STRING
    (50) type -> . BOOL
    (149) empty -> .

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    RPAREN          reduce using rule 149 (empty -> .)

    params0                        shift and go to state 107
    type                           shift and go to state 108
    empty                          shift and go to state 109

state 58

    (104) attr_access0 -> ID . DOT ID attr_access1
    (77) power0 -> ID . LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (85) const_var -> ID .
    (86) function_call -> ID . LPAREN function_call_params0 RPAREN
    (107) method_call0 -> ID . DOT method_call1 function_call

  ! shift/reduce conflict for LPAREN resolved as shift
    DOT             shift and go to state 110
    LSQRBRACKET     shift and go to state 83
    POWER           reduce using rule 85 (const_var -> ID .)
    SQRT            reduce using rule 85 (const_var -> ID .)
    MULTIPLY        reduce using rule 85 (const_var -> ID .)
    DIVIDE          reduce using rule 85 (const_var -> ID .)
    PLUS            reduce using rule 85 (const_var -> ID .)
    MINUS           reduce using rule 85 (const_var -> ID .)
    LTHAN           reduce using rule 85 (const_var -> ID .)
    GTHAN           reduce using rule 85 (const_var -> ID .)
    DIFFERENT       reduce using rule 85 (const_var -> ID .)
    EQUIVALENT      reduce using rule 85 (const_var -> ID .)
    SEMICOLON       reduce using rule 85 (const_var -> ID .)
    COMMA           reduce using rule 85 (const_var -> ID .)
    RPAREN          reduce using rule 85 (const_var -> ID .)
    LPAREN          shift and go to state 84

  ! LPAREN          [ reduce using rule 85 (const_var -> ID .) ]


state 59

    (26) assignment0 -> ID assignment1 EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 111


state 60

    (92) expression0 -> exp0 . expression1
    (95) expression1 -> . empty
    (96) expression1 -> . expression2
    (149) empty -> .
    (97) expression2 -> . LTHAN expression3
    (98) expression2 -> . GTHAN expression3
    (99) expression2 -> . DIFFERENT expression3
    (100) expression2 -> . EQUIVALENT expression3

    SEMICOLON       reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)
    LTHAN           shift and go to state 115
    GTHAN           shift and go to state 116
    DIFFERENT       shift and go to state 117
    EQUIVALENT      shift and go to state 118

    expression1                    shift and go to state 112
    empty                          shift and go to state 113
    expression2                    shift and go to state 114

state 61

    (93) expression0 -> CONST_BOOL . expression1
    (95) expression1 -> . empty
    (96) expression1 -> . expression2
    (149) empty -> .
    (97) expression2 -> . LTHAN expression3
    (98) expression2 -> . GTHAN expression3
    (99) expression2 -> . DIFFERENT expression3
    (100) expression2 -> . EQUIVALENT expression3

    SEMICOLON       reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)
    LTHAN           shift and go to state 115
    GTHAN           shift and go to state 116
    DIFFERENT       shift and go to state 117
    EQUIVALENT      shift and go to state 118

    expression1                    shift and go to state 119
    empty                          shift and go to state 113
    expression2                    shift and go to state 114

state 62

    (94) expression0 -> attr_access0 . expression1
    (76) power0 -> attr_access0 . power2
    (95) expression1 -> . empty
    (96) expression1 -> . expression2
    (80) power2 -> . POWER power0
    (81) power2 -> . SQRT power0
    (82) power2 -> . empty
    (149) empty -> .
    (97) expression2 -> . LTHAN expression3
    (98) expression2 -> . GTHAN expression3
    (99) expression2 -> . DIFFERENT expression3
    (100) expression2 -> . EQUIVALENT expression3

  ! shift/reduce conflict for LTHAN resolved as shift
  ! shift/reduce conflict for GTHAN resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for EQUIVALENT resolved as shift
    POWER           shift and go to state 77
    SQRT            shift and go to state 78
    SEMICOLON       reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    LTHAN           shift and go to state 115
    GTHAN           shift and go to state 116
    DIFFERENT       shift and go to state 117
    EQUIVALENT      shift and go to state 118

  ! LTHAN           [ reduce using rule 149 (empty -> .) ]
  ! GTHAN           [ reduce using rule 149 (empty -> .) ]
  ! DIFFERENT       [ reduce using rule 149 (empty -> .) ]
  ! EQUIVALENT      [ reduce using rule 149 (empty -> .) ]

    expression1                    shift and go to state 120
    power2                         shift and go to state 82
    empty                          shift and go to state 121
    expression2                    shift and go to state 114

state 63

    (23) declaration1 -> type LSQRBRACKET exp0 . RSQRBRACKET declaration2

    RSQRBRACKET     shift and go to state 122


state 64

    (27) assignment1 -> LSQRBRACKET exp0 RSQRBRACKET . assignment2
    (29) assignment2 -> . LSQRBRACKET exp0 RSQRBRACKET
    (30) assignment2 -> . empty
    (149) empty -> .

    LSQRBRACKET     shift and go to state 123
    EQUALS          reduce using rule 149 (empty -> .)

    assignment2                    shift and go to state 124
    empty                          shift and go to state 125

state 65

    (61) exp0 -> term0 exp1 .

    RSQRBRACKET     reduce using rule 61 (exp0 -> term0 exp1 .)
    LTHAN           reduce using rule 61 (exp0 -> term0 exp1 .)
    GTHAN           reduce using rule 61 (exp0 -> term0 exp1 .)
    DIFFERENT       reduce using rule 61 (exp0 -> term0 exp1 .)
    EQUIVALENT      reduce using rule 61 (exp0 -> term0 exp1 .)
    SEMICOLON       reduce using rule 61 (exp0 -> term0 exp1 .)
    RPAREN          reduce using rule 61 (exp0 -> term0 exp1 .)
    COMMA           reduce using rule 61 (exp0 -> term0 exp1 .)
    LPAREN          reduce using rule 61 (exp0 -> term0 exp1 .)


state 66

    (62) exp1 -> PLUS . exp0
    (61) exp0 -> . term0 exp1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    exp0                           shift and go to state 126
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 67

    (63) exp1 -> MINUS . exp0
    (61) exp0 -> . term0 exp1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    exp0                           shift and go to state 127
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 68

    (64) exp1 -> empty .

    RSQRBRACKET     reduce using rule 64 (exp1 -> empty .)
    LTHAN           reduce using rule 64 (exp1 -> empty .)
    GTHAN           reduce using rule 64 (exp1 -> empty .)
    DIFFERENT       reduce using rule 64 (exp1 -> empty .)
    EQUIVALENT      reduce using rule 64 (exp1 -> empty .)
    SEMICOLON       reduce using rule 64 (exp1 -> empty .)
    RPAREN          reduce using rule 64 (exp1 -> empty .)
    COMMA           reduce using rule 64 (exp1 -> empty .)
    LPAREN          reduce using rule 64 (exp1 -> empty .)


state 69

    (65) term0 -> factor term1 .

    PLUS            reduce using rule 65 (term0 -> factor term1 .)
    MINUS           reduce using rule 65 (term0 -> factor term1 .)
    RSQRBRACKET     reduce using rule 65 (term0 -> factor term1 .)
    LTHAN           reduce using rule 65 (term0 -> factor term1 .)
    GTHAN           reduce using rule 65 (term0 -> factor term1 .)
    DIFFERENT       reduce using rule 65 (term0 -> factor term1 .)
    EQUIVALENT      reduce using rule 65 (term0 -> factor term1 .)
    SEMICOLON       reduce using rule 65 (term0 -> factor term1 .)
    RPAREN          reduce using rule 65 (term0 -> factor term1 .)
    COMMA           reduce using rule 65 (term0 -> factor term1 .)
    LPAREN          reduce using rule 65 (term0 -> factor term1 .)


state 70

    (66) term1 -> MULTIPLY . term0
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    term0                          shift and go to state 128
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 71

    (67) term1 -> DIVIDE . term0
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    term0                          shift and go to state 129
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 72

    (68) term1 -> empty .

    PLUS            reduce using rule 68 (term1 -> empty .)
    MINUS           reduce using rule 68 (term1 -> empty .)
    RSQRBRACKET     reduce using rule 68 (term1 -> empty .)
    LTHAN           reduce using rule 68 (term1 -> empty .)
    GTHAN           reduce using rule 68 (term1 -> empty .)
    DIFFERENT       reduce using rule 68 (term1 -> empty .)
    EQUIVALENT      reduce using rule 68 (term1 -> empty .)
    SEMICOLON       reduce using rule 68 (term1 -> empty .)
    RPAREN          reduce using rule 68 (term1 -> empty .)
    COMMA           reduce using rule 68 (term1 -> empty .)
    LPAREN          reduce using rule 68 (term1 -> empty .)


state 73

    (69) factor -> PLUS power0 .

    MULTIPLY        reduce using rule 69 (factor -> PLUS power0 .)
    DIVIDE          reduce using rule 69 (factor -> PLUS power0 .)
    PLUS            reduce using rule 69 (factor -> PLUS power0 .)
    MINUS           reduce using rule 69 (factor -> PLUS power0 .)
    RSQRBRACKET     reduce using rule 69 (factor -> PLUS power0 .)
    LTHAN           reduce using rule 69 (factor -> PLUS power0 .)
    GTHAN           reduce using rule 69 (factor -> PLUS power0 .)
    DIFFERENT       reduce using rule 69 (factor -> PLUS power0 .)
    EQUIVALENT      reduce using rule 69 (factor -> PLUS power0 .)
    SEMICOLON       reduce using rule 69 (factor -> PLUS power0 .)
    RPAREN          reduce using rule 69 (factor -> PLUS power0 .)
    COMMA           reduce using rule 69 (factor -> PLUS power0 .)
    LPAREN          reduce using rule 69 (factor -> PLUS power0 .)


state 74

    (70) factor -> MINUS power0 .

    MULTIPLY        reduce using rule 70 (factor -> MINUS power0 .)
    DIVIDE          reduce using rule 70 (factor -> MINUS power0 .)
    PLUS            reduce using rule 70 (factor -> MINUS power0 .)
    MINUS           reduce using rule 70 (factor -> MINUS power0 .)
    RSQRBRACKET     reduce using rule 70 (factor -> MINUS power0 .)
    LTHAN           reduce using rule 70 (factor -> MINUS power0 .)
    GTHAN           reduce using rule 70 (factor -> MINUS power0 .)
    DIFFERENT       reduce using rule 70 (factor -> MINUS power0 .)
    EQUIVALENT      reduce using rule 70 (factor -> MINUS power0 .)
    SEMICOLON       reduce using rule 70 (factor -> MINUS power0 .)
    RPAREN          reduce using rule 70 (factor -> MINUS power0 .)
    COMMA           reduce using rule 70 (factor -> MINUS power0 .)
    LPAREN          reduce using rule 70 (factor -> MINUS power0 .)


state 75

    (72) power0 -> LPAREN exp0 . RPAREN power2

    RPAREN          shift and go to state 130


state 76

    (73) power0 -> const_var power2 .

    MULTIPLY        reduce using rule 73 (power0 -> const_var power2 .)
    DIVIDE          reduce using rule 73 (power0 -> const_var power2 .)
    PLUS            reduce using rule 73 (power0 -> const_var power2 .)
    MINUS           reduce using rule 73 (power0 -> const_var power2 .)
    RSQRBRACKET     reduce using rule 73 (power0 -> const_var power2 .)
    LTHAN           reduce using rule 73 (power0 -> const_var power2 .)
    GTHAN           reduce using rule 73 (power0 -> const_var power2 .)
    DIFFERENT       reduce using rule 73 (power0 -> const_var power2 .)
    EQUIVALENT      reduce using rule 73 (power0 -> const_var power2 .)
    SEMICOLON       reduce using rule 73 (power0 -> const_var power2 .)
    RPAREN          reduce using rule 73 (power0 -> const_var power2 .)
    COMMA           reduce using rule 73 (power0 -> const_var power2 .)
    LPAREN          reduce using rule 73 (power0 -> const_var power2 .)


state 77

    (80) power2 -> POWER . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    power0                         shift and go to state 131
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 78

    (81) power2 -> SQRT . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    power0                         shift and go to state 132
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 79

    (82) power2 -> empty .

    MULTIPLY        reduce using rule 82 (power2 -> empty .)
    DIVIDE          reduce using rule 82 (power2 -> empty .)
    PLUS            reduce using rule 82 (power2 -> empty .)
    MINUS           reduce using rule 82 (power2 -> empty .)
    RSQRBRACKET     reduce using rule 82 (power2 -> empty .)
    LTHAN           reduce using rule 82 (power2 -> empty .)
    GTHAN           reduce using rule 82 (power2 -> empty .)
    DIFFERENT       reduce using rule 82 (power2 -> empty .)
    EQUIVALENT      reduce using rule 82 (power2 -> empty .)
    SEMICOLON       reduce using rule 82 (power2 -> empty .)
    RPAREN          reduce using rule 82 (power2 -> empty .)
    COMMA           reduce using rule 82 (power2 -> empty .)
    LPAREN          reduce using rule 82 (power2 -> empty .)


state 80

    (74) power0 -> function_call power2 .

    MULTIPLY        reduce using rule 74 (power0 -> function_call power2 .)
    DIVIDE          reduce using rule 74 (power0 -> function_call power2 .)
    PLUS            reduce using rule 74 (power0 -> function_call power2 .)
    MINUS           reduce using rule 74 (power0 -> function_call power2 .)
    RSQRBRACKET     reduce using rule 74 (power0 -> function_call power2 .)
    LTHAN           reduce using rule 74 (power0 -> function_call power2 .)
    GTHAN           reduce using rule 74 (power0 -> function_call power2 .)
    DIFFERENT       reduce using rule 74 (power0 -> function_call power2 .)
    EQUIVALENT      reduce using rule 74 (power0 -> function_call power2 .)
    SEMICOLON       reduce using rule 74 (power0 -> function_call power2 .)
    RPAREN          reduce using rule 74 (power0 -> function_call power2 .)
    COMMA           reduce using rule 74 (power0 -> function_call power2 .)
    LPAREN          reduce using rule 74 (power0 -> function_call power2 .)


state 81

    (75) power0 -> method_call0 power2 .

    MULTIPLY        reduce using rule 75 (power0 -> method_call0 power2 .)
    DIVIDE          reduce using rule 75 (power0 -> method_call0 power2 .)
    PLUS            reduce using rule 75 (power0 -> method_call0 power2 .)
    MINUS           reduce using rule 75 (power0 -> method_call0 power2 .)
    RSQRBRACKET     reduce using rule 75 (power0 -> method_call0 power2 .)
    LTHAN           reduce using rule 75 (power0 -> method_call0 power2 .)
    GTHAN           reduce using rule 75 (power0 -> method_call0 power2 .)
    DIFFERENT       reduce using rule 75 (power0 -> method_call0 power2 .)
    EQUIVALENT      reduce using rule 75 (power0 -> method_call0 power2 .)
    SEMICOLON       reduce using rule 75 (power0 -> method_call0 power2 .)
    RPAREN          reduce using rule 75 (power0 -> method_call0 power2 .)
    COMMA           reduce using rule 75 (power0 -> method_call0 power2 .)
    LPAREN          reduce using rule 75 (power0 -> method_call0 power2 .)


state 82

    (76) power0 -> attr_access0 power2 .

    MULTIPLY        reduce using rule 76 (power0 -> attr_access0 power2 .)
    DIVIDE          reduce using rule 76 (power0 -> attr_access0 power2 .)
    PLUS            reduce using rule 76 (power0 -> attr_access0 power2 .)
    MINUS           reduce using rule 76 (power0 -> attr_access0 power2 .)
    RSQRBRACKET     reduce using rule 76 (power0 -> attr_access0 power2 .)
    LTHAN           reduce using rule 76 (power0 -> attr_access0 power2 .)
    GTHAN           reduce using rule 76 (power0 -> attr_access0 power2 .)
    DIFFERENT       reduce using rule 76 (power0 -> attr_access0 power2 .)
    EQUIVALENT      reduce using rule 76 (power0 -> attr_access0 power2 .)
    SEMICOLON       reduce using rule 76 (power0 -> attr_access0 power2 .)
    RPAREN          reduce using rule 76 (power0 -> attr_access0 power2 .)
    COMMA           reduce using rule 76 (power0 -> attr_access0 power2 .)
    LPAREN          reduce using rule 76 (power0 -> attr_access0 power2 .)


state 83

    (77) power0 -> ID LSQRBRACKET . exp0 RSQRBRACKET power1 power2
    (61) exp0 -> . term0 exp1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    exp0                           shift and go to state 133
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 84

    (86) function_call -> ID LPAREN . function_call_params0 RPAREN
    (87) function_call_params0 -> . expression0 function_call_params1
    (88) function_call_params0 -> . CONST_STRING function_call_params1
    (89) function_call_params0 -> . empty function_call_params1
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (149) empty -> .
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_STRING    shift and go to state 136
    CONST_BOOL      shift and go to state 61
    COMMA           reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    function_call_params0          shift and go to state 134
    expression0                    shift and go to state 135
    empty                          shift and go to state 137
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 85

    (107) method_call0 -> ID DOT . method_call1 function_call
    (104) attr_access0 -> ID DOT . ID attr_access1
    (108) method_call1 -> . ID DOT method_call1
    (109) method_call1 -> . empty
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 138

  ! ID              [ reduce using rule 149 (empty -> .) ]

    method_call1                   shift and go to state 139
    empty                          shift and go to state 140

state 86

    (145) main0 -> MAIN LBRACKET main1 . RBRACKET

    RBRACKET        shift and go to state 141


state 87

    (146) main1 -> declaration0 . main1
    (146) main1 -> . declaration0 main1
    (147) main1 -> . statement main1
    (148) main1 -> . empty
    (20) declaration0 -> . ID declaration1 SEMICOLON
    (135) statement -> . assignment0
    (136) statement -> . object_assignment
    (137) statement -> . condition0
    (138) statement -> . writing0
    (139) statement -> . reading
    (140) statement -> . return
    (141) statement -> . function_call SEMICOLON
    (142) statement -> . method_call0 SEMICOLON
    (143) statement -> . while
    (149) empty -> .
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (144) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (120) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (123) writing0 -> . WRITE LPAREN writing1 LPAREN SEMICOLON
    (128) reading -> . READ ID SEMICOLON
    (129) return -> . RETURN expression0 SEMICOLON
    (130) return -> . RETURN SEMICOLON
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (131) while -> . WHILE LPAREN expression0 RPAREN block0

    ID              shift and go to state 90
    RBRACKET        reduce using rule 149 (empty -> .)
    IF              shift and go to state 100
    WRITE           shift and go to state 101
    READ            shift and go to state 102
    RETURN          shift and go to state 103
    WHILE           shift and go to state 104

    declaration0                   shift and go to state 87
    main1                          shift and go to state 142
    statement                      shift and go to state 88
    empty                          shift and go to state 89
    assignment0                    shift and go to state 91
    object_assignment              shift and go to state 92
    condition0                     shift and go to state 93
    writing0                       shift and go to state 94
    reading                        shift and go to state 95
    return                         shift and go to state 96
    function_call                  shift and go to state 97
    method_call0                   shift and go to state 98
    while                          shift and go to state 99

state 88

    (147) main1 -> statement . main1
    (146) main1 -> . declaration0 main1
    (147) main1 -> . statement main1
    (148) main1 -> . empty
    (20) declaration0 -> . ID declaration1 SEMICOLON
    (135) statement -> . assignment0
    (136) statement -> . object_assignment
    (137) statement -> . condition0
    (138) statement -> . writing0
    (139) statement -> . reading
    (140) statement -> . return
    (141) statement -> . function_call SEMICOLON
    (142) statement -> . method_call0 SEMICOLON
    (143) statement -> . while
    (149) empty -> .
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (144) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (120) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (123) writing0 -> . WRITE LPAREN writing1 LPAREN SEMICOLON
    (128) reading -> . READ ID SEMICOLON
    (129) return -> . RETURN expression0 SEMICOLON
    (130) return -> . RETURN SEMICOLON
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (131) while -> . WHILE LPAREN expression0 RPAREN block0

    ID              shift and go to state 90
    RBRACKET        reduce using rule 149 (empty -> .)
    IF              shift and go to state 100
    WRITE           shift and go to state 101
    READ            shift and go to state 102
    RETURN          shift and go to state 103
    WHILE           shift and go to state 104

    statement                      shift and go to state 88
    main1                          shift and go to state 143
    declaration0                   shift and go to state 87
    empty                          shift and go to state 89
    assignment0                    shift and go to state 91
    object_assignment              shift and go to state 92
    condition0                     shift and go to state 93
    writing0                       shift and go to state 94
    reading                        shift and go to state 95
    return                         shift and go to state 96
    function_call                  shift and go to state 97
    method_call0                   shift and go to state 98
    while                          shift and go to state 99

state 89

    (148) main1 -> empty .

    RBRACKET        reduce using rule 148 (main1 -> empty .)


state 90

    (20) declaration0 -> ID . declaration1 SEMICOLON
    (26) assignment0 -> ID . assignment1 EQUALS expression0 SEMICOLON
    (144) object_assignment -> ID . EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (86) function_call -> ID . LPAREN function_call_params0 RPAREN
    (107) method_call0 -> ID . DOT method_call1 function_call
    (21) declaration1 -> . type
    (22) declaration1 -> . complex_type
    (23) declaration1 -> . type LSQRBRACKET exp0 RSQRBRACKET declaration2
    (27) assignment1 -> . LSQRBRACKET exp0 RSQRBRACKET assignment2
    (28) assignment1 -> . empty
    (47) type -> . INT
    (48) type -> . FLOAT
    (49) type -> . STRING
    (50) type -> . BOOL
    (53) complex_type -> . ID
    (149) empty -> .

  ! shift/reduce conflict for EQUALS resolved as shift
    EQUALS          shift and go to state 144
    LPAREN          shift and go to state 84
    DOT             shift and go to state 145
    LSQRBRACKET     shift and go to state 19
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    ID              shift and go to state 14

  ! EQUALS          [ reduce using rule 149 (empty -> .) ]

    declaration1                   shift and go to state 15
    assignment1                    shift and go to state 16
    type                           shift and go to state 17
    complex_type                   shift and go to state 18
    empty                          shift and go to state 20

state 91

    (135) statement -> assignment0 .

    ID              reduce using rule 135 (statement -> assignment0 .)
    IF              reduce using rule 135 (statement -> assignment0 .)
    WRITE           reduce using rule 135 (statement -> assignment0 .)
    READ            reduce using rule 135 (statement -> assignment0 .)
    RETURN          reduce using rule 135 (statement -> assignment0 .)
    WHILE           reduce using rule 135 (statement -> assignment0 .)
    RBRACKET        reduce using rule 135 (statement -> assignment0 .)


state 92

    (136) statement -> object_assignment .

    ID              reduce using rule 136 (statement -> object_assignment .)
    IF              reduce using rule 136 (statement -> object_assignment .)
    WRITE           reduce using rule 136 (statement -> object_assignment .)
    READ            reduce using rule 136 (statement -> object_assignment .)
    RETURN          reduce using rule 136 (statement -> object_assignment .)
    WHILE           reduce using rule 136 (statement -> object_assignment .)
    RBRACKET        reduce using rule 136 (statement -> object_assignment .)


state 93

    (137) statement -> condition0 .

    ID              reduce using rule 137 (statement -> condition0 .)
    IF              reduce using rule 137 (statement -> condition0 .)
    WRITE           reduce using rule 137 (statement -> condition0 .)
    READ            reduce using rule 137 (statement -> condition0 .)
    RETURN          reduce using rule 137 (statement -> condition0 .)
    WHILE           reduce using rule 137 (statement -> condition0 .)
    RBRACKET        reduce using rule 137 (statement -> condition0 .)


state 94

    (138) statement -> writing0 .

    ID              reduce using rule 138 (statement -> writing0 .)
    IF              reduce using rule 138 (statement -> writing0 .)
    WRITE           reduce using rule 138 (statement -> writing0 .)
    READ            reduce using rule 138 (statement -> writing0 .)
    RETURN          reduce using rule 138 (statement -> writing0 .)
    WHILE           reduce using rule 138 (statement -> writing0 .)
    RBRACKET        reduce using rule 138 (statement -> writing0 .)


state 95

    (139) statement -> reading .

    ID              reduce using rule 139 (statement -> reading .)
    IF              reduce using rule 139 (statement -> reading .)
    WRITE           reduce using rule 139 (statement -> reading .)
    READ            reduce using rule 139 (statement -> reading .)
    RETURN          reduce using rule 139 (statement -> reading .)
    WHILE           reduce using rule 139 (statement -> reading .)
    RBRACKET        reduce using rule 139 (statement -> reading .)


state 96

    (140) statement -> return .

    ID              reduce using rule 140 (statement -> return .)
    IF              reduce using rule 140 (statement -> return .)
    WRITE           reduce using rule 140 (statement -> return .)
    READ            reduce using rule 140 (statement -> return .)
    RETURN          reduce using rule 140 (statement -> return .)
    WHILE           reduce using rule 140 (statement -> return .)
    RBRACKET        reduce using rule 140 (statement -> return .)


state 97

    (141) statement -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 146


state 98

    (142) statement -> method_call0 . SEMICOLON

    SEMICOLON       shift and go to state 147


state 99

    (143) statement -> while .

    ID              reduce using rule 143 (statement -> while .)
    IF              reduce using rule 143 (statement -> while .)
    WRITE           reduce using rule 143 (statement -> while .)
    READ            reduce using rule 143 (statement -> while .)
    RETURN          reduce using rule 143 (statement -> while .)
    WHILE           reduce using rule 143 (statement -> while .)
    RBRACKET        reduce using rule 143 (statement -> while .)


state 100

    (120) condition0 -> IF . LPAREN expression0 RPAREN block0 condition1 SEMICOLON

    LPAREN          shift and go to state 148


state 101

    (123) writing0 -> WRITE . LPAREN writing1 LPAREN SEMICOLON

    LPAREN          shift and go to state 149


state 102

    (128) reading -> READ . ID SEMICOLON

    ID              shift and go to state 150


state 103

    (129) return -> RETURN . expression0 SEMICOLON
    (130) return -> RETURN . SEMICOLON
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    SEMICOLON       shift and go to state 152
    CONST_BOOL      shift and go to state 61
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    expression0                    shift and go to state 151
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 104

    (131) while -> WHILE . LPAREN expression0 RPAREN block0

    LPAREN          shift and go to state 153


state 105

    (7) class0 -> CLASS ID class1 LBRACKET . class2 constructor class3 RBRACKET SEMICOLON
    (10) class2 -> . attributes
    (11) class2 -> . empty
    (35) attributes -> . data_access simple_declaration attributes
    (36) attributes -> . simple_assignment attributes
    (37) attributes -> . empty
    (149) empty -> .
    (110) data_access -> . PRIVATE
    (111) data_access -> . PUBLIC
    (52) simple_assignment -> . ID EQUALS expression0 SEMICOLON

    CONSTRUCT       reduce using rule 149 (empty -> .)
    PRIVATE         shift and go to state 55
    PUBLIC          shift and go to state 56
    ID              shift and go to state 154

    class2                         shift and go to state 155
    attributes                     shift and go to state 156
    empty                          shift and go to state 157
    data_access                    shift and go to state 158
    simple_assignment              shift and go to state 159

state 106

    (32) extension0 -> data_access ID . extension1
    (33) extension1 -> . COMMA extension0
    (34) extension1 -> . empty
    (149) empty -> .

    COMMA           shift and go to state 161
    LBRACKET        reduce using rule 149 (empty -> .)

    extension1                     shift and go to state 160
    empty                          shift and go to state 162

state 107

    (14) function0 -> DEF ID LPAREN params0 . RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    RPAREN          shift and go to state 163


state 108

    (40) params0 -> type . ID params1

    ID              shift and go to state 164


state 109

    (41) params0 -> empty .

    RPAREN          reduce using rule 41 (params0 -> empty .)


state 110

    (104) attr_access0 -> ID DOT . ID attr_access1
    (107) method_call0 -> ID DOT . method_call1 function_call
    (108) method_call1 -> . ID DOT method_call1
    (109) method_call1 -> . empty
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 138

  ! ID              [ reduce using rule 149 (empty -> .) ]

    method_call1                   shift and go to state 139
    empty                          shift and go to state 140

state 111

    (26) assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .

    CLASS           reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)
    DEF             reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)
    MAIN            reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 26 (assignment0 -> ID assignment1 EQUALS expression0 SEMICOLON .)


state 112

    (92) expression0 -> exp0 expression1 .

    SEMICOLON       reduce using rule 92 (expression0 -> exp0 expression1 .)
    COMMA           reduce using rule 92 (expression0 -> exp0 expression1 .)
    RPAREN          reduce using rule 92 (expression0 -> exp0 expression1 .)
    LPAREN          reduce using rule 92 (expression0 -> exp0 expression1 .)


state 113

    (95) expression1 -> empty .

    SEMICOLON       reduce using rule 95 (expression1 -> empty .)
    COMMA           reduce using rule 95 (expression1 -> empty .)
    RPAREN          reduce using rule 95 (expression1 -> empty .)
    LPAREN          reduce using rule 95 (expression1 -> empty .)


state 114

    (96) expression1 -> expression2 .

    SEMICOLON       reduce using rule 96 (expression1 -> expression2 .)
    COMMA           reduce using rule 96 (expression1 -> expression2 .)
    RPAREN          reduce using rule 96 (expression1 -> expression2 .)
    LPAREN          reduce using rule 96 (expression1 -> expression2 .)


state 115

    (97) expression2 -> LTHAN . expression3
    (101) expression3 -> . exp0
    (102) expression3 -> . CONST_BOOL
    (103) expression3 -> . attr_access0
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_BOOL      shift and go to state 167
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    expression3                    shift and go to state 165
    exp0                           shift and go to state 166
    attr_access0                   shift and go to state 168
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 116

    (98) expression2 -> GTHAN . expression3
    (101) expression3 -> . exp0
    (102) expression3 -> . CONST_BOOL
    (103) expression3 -> . attr_access0
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_BOOL      shift and go to state 167
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    expression3                    shift and go to state 169
    exp0                           shift and go to state 166
    attr_access0                   shift and go to state 168
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 117

    (99) expression2 -> DIFFERENT . expression3
    (101) expression3 -> . exp0
    (102) expression3 -> . CONST_BOOL
    (103) expression3 -> . attr_access0
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_BOOL      shift and go to state 167
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    expression3                    shift and go to state 170
    exp0                           shift and go to state 166
    attr_access0                   shift and go to state 168
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 118

    (100) expression2 -> EQUIVALENT . expression3
    (101) expression3 -> . exp0
    (102) expression3 -> . CONST_BOOL
    (103) expression3 -> . attr_access0
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_BOOL      shift and go to state 167
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    expression3                    shift and go to state 171
    exp0                           shift and go to state 166
    attr_access0                   shift and go to state 168
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 119

    (93) expression0 -> CONST_BOOL expression1 .

    SEMICOLON       reduce using rule 93 (expression0 -> CONST_BOOL expression1 .)
    COMMA           reduce using rule 93 (expression0 -> CONST_BOOL expression1 .)
    RPAREN          reduce using rule 93 (expression0 -> CONST_BOOL expression1 .)
    LPAREN          reduce using rule 93 (expression0 -> CONST_BOOL expression1 .)


state 120

    (94) expression0 -> attr_access0 expression1 .

    SEMICOLON       reduce using rule 94 (expression0 -> attr_access0 expression1 .)
    COMMA           reduce using rule 94 (expression0 -> attr_access0 expression1 .)
    RPAREN          reduce using rule 94 (expression0 -> attr_access0 expression1 .)
    LPAREN          reduce using rule 94 (expression0 -> attr_access0 expression1 .)


state 121

    (95) expression1 -> empty .
    (82) power2 -> empty .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 82 (power2 -> empty .)
  ! reduce/reduce conflict for COMMA resolved using rule 82 (power2 -> empty .)
  ! reduce/reduce conflict for RPAREN resolved using rule 82 (power2 -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 82 (power2 -> empty .)
    MULTIPLY        reduce using rule 82 (power2 -> empty .)
    DIVIDE          reduce using rule 82 (power2 -> empty .)
    PLUS            reduce using rule 82 (power2 -> empty .)
    MINUS           reduce using rule 82 (power2 -> empty .)
    LTHAN           reduce using rule 82 (power2 -> empty .)
    GTHAN           reduce using rule 82 (power2 -> empty .)
    DIFFERENT       reduce using rule 82 (power2 -> empty .)
    EQUIVALENT      reduce using rule 82 (power2 -> empty .)
    SEMICOLON       reduce using rule 82 (power2 -> empty .)
    COMMA           reduce using rule 82 (power2 -> empty .)
    RPAREN          reduce using rule 82 (power2 -> empty .)
    LPAREN          reduce using rule 82 (power2 -> empty .)

  ! SEMICOLON       [ reduce using rule 95 (expression1 -> empty .) ]
  ! COMMA           [ reduce using rule 95 (expression1 -> empty .) ]
  ! RPAREN          [ reduce using rule 95 (expression1 -> empty .) ]
  ! LPAREN          [ reduce using rule 95 (expression1 -> empty .) ]


state 122

    (23) declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET . declaration2
    (24) declaration2 -> . LSQRBRACKET exp0 RSQRBRACKET
    (25) declaration2 -> . empty
    (149) empty -> .

    LSQRBRACKET     shift and go to state 172
    SEMICOLON       reduce using rule 149 (empty -> .)

    declaration2                   shift and go to state 173
    empty                          shift and go to state 174

state 123

    (29) assignment2 -> LSQRBRACKET . exp0 RSQRBRACKET
    (61) exp0 -> . term0 exp1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    exp0                           shift and go to state 175
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 124

    (27) assignment1 -> LSQRBRACKET exp0 RSQRBRACKET assignment2 .

    EQUALS          reduce using rule 27 (assignment1 -> LSQRBRACKET exp0 RSQRBRACKET assignment2 .)


state 125

    (30) assignment2 -> empty .

    EQUALS          reduce using rule 30 (assignment2 -> empty .)


state 126

    (62) exp1 -> PLUS exp0 .

    RSQRBRACKET     reduce using rule 62 (exp1 -> PLUS exp0 .)
    LTHAN           reduce using rule 62 (exp1 -> PLUS exp0 .)
    GTHAN           reduce using rule 62 (exp1 -> PLUS exp0 .)
    DIFFERENT       reduce using rule 62 (exp1 -> PLUS exp0 .)
    EQUIVALENT      reduce using rule 62 (exp1 -> PLUS exp0 .)
    SEMICOLON       reduce using rule 62 (exp1 -> PLUS exp0 .)
    RPAREN          reduce using rule 62 (exp1 -> PLUS exp0 .)
    COMMA           reduce using rule 62 (exp1 -> PLUS exp0 .)
    LPAREN          reduce using rule 62 (exp1 -> PLUS exp0 .)


state 127

    (63) exp1 -> MINUS exp0 .

    RSQRBRACKET     reduce using rule 63 (exp1 -> MINUS exp0 .)
    LTHAN           reduce using rule 63 (exp1 -> MINUS exp0 .)
    GTHAN           reduce using rule 63 (exp1 -> MINUS exp0 .)
    DIFFERENT       reduce using rule 63 (exp1 -> MINUS exp0 .)
    EQUIVALENT      reduce using rule 63 (exp1 -> MINUS exp0 .)
    SEMICOLON       reduce using rule 63 (exp1 -> MINUS exp0 .)
    RPAREN          reduce using rule 63 (exp1 -> MINUS exp0 .)
    COMMA           reduce using rule 63 (exp1 -> MINUS exp0 .)
    LPAREN          reduce using rule 63 (exp1 -> MINUS exp0 .)


state 128

    (66) term1 -> MULTIPLY term0 .

    PLUS            reduce using rule 66 (term1 -> MULTIPLY term0 .)
    MINUS           reduce using rule 66 (term1 -> MULTIPLY term0 .)
    RSQRBRACKET     reduce using rule 66 (term1 -> MULTIPLY term0 .)
    LTHAN           reduce using rule 66 (term1 -> MULTIPLY term0 .)
    GTHAN           reduce using rule 66 (term1 -> MULTIPLY term0 .)
    DIFFERENT       reduce using rule 66 (term1 -> MULTIPLY term0 .)
    EQUIVALENT      reduce using rule 66 (term1 -> MULTIPLY term0 .)
    SEMICOLON       reduce using rule 66 (term1 -> MULTIPLY term0 .)
    RPAREN          reduce using rule 66 (term1 -> MULTIPLY term0 .)
    COMMA           reduce using rule 66 (term1 -> MULTIPLY term0 .)
    LPAREN          reduce using rule 66 (term1 -> MULTIPLY term0 .)


state 129

    (67) term1 -> DIVIDE term0 .

    PLUS            reduce using rule 67 (term1 -> DIVIDE term0 .)
    MINUS           reduce using rule 67 (term1 -> DIVIDE term0 .)
    RSQRBRACKET     reduce using rule 67 (term1 -> DIVIDE term0 .)
    LTHAN           reduce using rule 67 (term1 -> DIVIDE term0 .)
    GTHAN           reduce using rule 67 (term1 -> DIVIDE term0 .)
    DIFFERENT       reduce using rule 67 (term1 -> DIVIDE term0 .)
    EQUIVALENT      reduce using rule 67 (term1 -> DIVIDE term0 .)
    SEMICOLON       reduce using rule 67 (term1 -> DIVIDE term0 .)
    RPAREN          reduce using rule 67 (term1 -> DIVIDE term0 .)
    COMMA           reduce using rule 67 (term1 -> DIVIDE term0 .)
    LPAREN          reduce using rule 67 (term1 -> DIVIDE term0 .)


state 130

    (72) power0 -> LPAREN exp0 RPAREN . power2
    (80) power2 -> . POWER power0
    (81) power2 -> . SQRT power0
    (82) power2 -> . empty
    (149) empty -> .

    POWER           shift and go to state 77
    SQRT            shift and go to state 78
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    power2                         shift and go to state 176
    empty                          shift and go to state 79

state 131

    (80) power2 -> POWER power0 .

    MULTIPLY        reduce using rule 80 (power2 -> POWER power0 .)
    DIVIDE          reduce using rule 80 (power2 -> POWER power0 .)
    PLUS            reduce using rule 80 (power2 -> POWER power0 .)
    MINUS           reduce using rule 80 (power2 -> POWER power0 .)
    RSQRBRACKET     reduce using rule 80 (power2 -> POWER power0 .)
    LTHAN           reduce using rule 80 (power2 -> POWER power0 .)
    GTHAN           reduce using rule 80 (power2 -> POWER power0 .)
    DIFFERENT       reduce using rule 80 (power2 -> POWER power0 .)
    EQUIVALENT      reduce using rule 80 (power2 -> POWER power0 .)
    SEMICOLON       reduce using rule 80 (power2 -> POWER power0 .)
    RPAREN          reduce using rule 80 (power2 -> POWER power0 .)
    COMMA           reduce using rule 80 (power2 -> POWER power0 .)
    LPAREN          reduce using rule 80 (power2 -> POWER power0 .)


state 132

    (81) power2 -> SQRT power0 .

    MULTIPLY        reduce using rule 81 (power2 -> SQRT power0 .)
    DIVIDE          reduce using rule 81 (power2 -> SQRT power0 .)
    PLUS            reduce using rule 81 (power2 -> SQRT power0 .)
    MINUS           reduce using rule 81 (power2 -> SQRT power0 .)
    RSQRBRACKET     reduce using rule 81 (power2 -> SQRT power0 .)
    LTHAN           reduce using rule 81 (power2 -> SQRT power0 .)
    GTHAN           reduce using rule 81 (power2 -> SQRT power0 .)
    DIFFERENT       reduce using rule 81 (power2 -> SQRT power0 .)
    EQUIVALENT      reduce using rule 81 (power2 -> SQRT power0 .)
    SEMICOLON       reduce using rule 81 (power2 -> SQRT power0 .)
    RPAREN          reduce using rule 81 (power2 -> SQRT power0 .)
    COMMA           reduce using rule 81 (power2 -> SQRT power0 .)
    LPAREN          reduce using rule 81 (power2 -> SQRT power0 .)


state 133

    (77) power0 -> ID LSQRBRACKET exp0 . RSQRBRACKET power1 power2

    RSQRBRACKET     shift and go to state 177


state 134

    (86) function_call -> ID LPAREN function_call_params0 . RPAREN

    RPAREN          shift and go to state 178


state 135

    (87) function_call_params0 -> expression0 . function_call_params1
    (90) function_call_params1 -> . COMMA function_call_params0
    (91) function_call_params1 -> . empty
    (149) empty -> .

    COMMA           shift and go to state 180
    RPAREN          reduce using rule 149 (empty -> .)

    function_call_params1          shift and go to state 179
    empty                          shift and go to state 181

state 136

    (88) function_call_params0 -> CONST_STRING . function_call_params1
    (90) function_call_params1 -> . COMMA function_call_params0
    (91) function_call_params1 -> . empty
    (149) empty -> .

    COMMA           shift and go to state 180
    RPAREN          reduce using rule 149 (empty -> .)

    function_call_params1          shift and go to state 182
    empty                          shift and go to state 181

state 137

    (89) function_call_params0 -> empty . function_call_params1
    (90) function_call_params1 -> . COMMA function_call_params0
    (91) function_call_params1 -> . empty
    (149) empty -> .

    COMMA           shift and go to state 180
    RPAREN          reduce using rule 149 (empty -> .)

    empty                          shift and go to state 181
    function_call_params1          shift and go to state 183

state 138

    (104) attr_access0 -> ID DOT ID . attr_access1
    (108) method_call1 -> ID . DOT method_call1
    (105) attr_access1 -> . DOT attr_access0
    (106) attr_access1 -> . empty
    (149) empty -> .

    DOT             shift and go to state 184
    POWER           reduce using rule 149 (empty -> .)
    SQRT            reduce using rule 149 (empty -> .)
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    attr_access1                   shift and go to state 185
    empty                          shift and go to state 186

state 139

    (107) method_call0 -> ID DOT method_call1 . function_call
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN

    ID              shift and go to state 187

    function_call                  shift and go to state 188

state 140

    (109) method_call1 -> empty .

    ID              reduce using rule 109 (method_call1 -> empty .)


state 141

    (145) main0 -> MAIN LBRACKET main1 RBRACKET .

    $end            reduce using rule 145 (main0 -> MAIN LBRACKET main1 RBRACKET .)


state 142

    (146) main1 -> declaration0 main1 .

    RBRACKET        reduce using rule 146 (main1 -> declaration0 main1 .)


state 143

    (147) main1 -> statement main1 .

    RBRACKET        reduce using rule 147 (main1 -> statement main1 .)


state 144

    (144) object_assignment -> ID EQUALS . NEW ID LPAREN function_call_params0 RPAREN SEMICOLON

    NEW             shift and go to state 189


state 145

    (107) method_call0 -> ID DOT . method_call1 function_call
    (108) method_call1 -> . ID DOT method_call1
    (109) method_call1 -> . empty
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 190

  ! ID              [ reduce using rule 149 (empty -> .) ]

    method_call1                   shift and go to state 139
    empty                          shift and go to state 140

state 146

    (141) statement -> function_call SEMICOLON .

    ID              reduce using rule 141 (statement -> function_call SEMICOLON .)
    IF              reduce using rule 141 (statement -> function_call SEMICOLON .)
    WRITE           reduce using rule 141 (statement -> function_call SEMICOLON .)
    READ            reduce using rule 141 (statement -> function_call SEMICOLON .)
    RETURN          reduce using rule 141 (statement -> function_call SEMICOLON .)
    WHILE           reduce using rule 141 (statement -> function_call SEMICOLON .)
    RBRACKET        reduce using rule 141 (statement -> function_call SEMICOLON .)


state 147

    (142) statement -> method_call0 SEMICOLON .

    ID              reduce using rule 142 (statement -> method_call0 SEMICOLON .)
    IF              reduce using rule 142 (statement -> method_call0 SEMICOLON .)
    WRITE           reduce using rule 142 (statement -> method_call0 SEMICOLON .)
    READ            reduce using rule 142 (statement -> method_call0 SEMICOLON .)
    RETURN          reduce using rule 142 (statement -> method_call0 SEMICOLON .)
    WHILE           reduce using rule 142 (statement -> method_call0 SEMICOLON .)
    RBRACKET        reduce using rule 142 (statement -> method_call0 SEMICOLON .)


state 148

    (120) condition0 -> IF LPAREN . expression0 RPAREN block0 condition1 SEMICOLON
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_BOOL      shift and go to state 61
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    expression0                    shift and go to state 191
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 149

    (123) writing0 -> WRITE LPAREN . writing1 LPAREN SEMICOLON
    (124) writing1 -> . expression0 writing2
    (125) writing1 -> . CONST_STRING writing2
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_STRING    shift and go to state 194
    CONST_BOOL      shift and go to state 61
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    writing1                       shift and go to state 192
    expression0                    shift and go to state 193
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 150

    (128) reading -> READ ID . SEMICOLON

    SEMICOLON       shift and go to state 195


state 151

    (129) return -> RETURN expression0 . SEMICOLON

    SEMICOLON       shift and go to state 196


state 152

    (130) return -> RETURN SEMICOLON .

    ID              reduce using rule 130 (return -> RETURN SEMICOLON .)
    IF              reduce using rule 130 (return -> RETURN SEMICOLON .)
    WRITE           reduce using rule 130 (return -> RETURN SEMICOLON .)
    READ            reduce using rule 130 (return -> RETURN SEMICOLON .)
    RETURN          reduce using rule 130 (return -> RETURN SEMICOLON .)
    WHILE           reduce using rule 130 (return -> RETURN SEMICOLON .)
    RBRACKET        reduce using rule 130 (return -> RETURN SEMICOLON .)


state 153

    (131) while -> WHILE LPAREN . expression0 RPAREN block0
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_BOOL      shift and go to state 61
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    expression0                    shift and go to state 197
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 154

    (52) simple_assignment -> ID . EQUALS expression0 SEMICOLON

    EQUALS          shift and go to state 198


state 155

    (7) class0 -> CLASS ID class1 LBRACKET class2 . constructor class3 RBRACKET SEMICOLON
    (31) constructor -> . CONSTRUCT ID LPAREN params0 RPAREN function_block0

    CONSTRUCT       shift and go to state 200

    constructor                    shift and go to state 199

state 156

    (10) class2 -> attributes .

    CONSTRUCT       reduce using rule 10 (class2 -> attributes .)


state 157

    (11) class2 -> empty .
    (37) attributes -> empty .

  ! reduce/reduce conflict for CONSTRUCT resolved using rule 11 (class2 -> empty .)
    CONSTRUCT       reduce using rule 11 (class2 -> empty .)

  ! CONSTRUCT       [ reduce using rule 37 (attributes -> empty .) ]


state 158

    (35) attributes -> data_access . simple_declaration attributes
    (51) simple_declaration -> . ID COLON type SEMICOLON

    ID              shift and go to state 202

    simple_declaration             shift and go to state 201

state 159

    (36) attributes -> simple_assignment . attributes
    (35) attributes -> . data_access simple_declaration attributes
    (36) attributes -> . simple_assignment attributes
    (37) attributes -> . empty
    (110) data_access -> . PRIVATE
    (111) data_access -> . PUBLIC
    (52) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (149) empty -> .

    PRIVATE         shift and go to state 55
    PUBLIC          shift and go to state 56
    ID              shift and go to state 154
    CONSTRUCT       reduce using rule 149 (empty -> .)

    simple_assignment              shift and go to state 159
    attributes                     shift and go to state 203
    data_access                    shift and go to state 158
    empty                          shift and go to state 204

state 160

    (32) extension0 -> data_access ID extension1 .

    LBRACKET        reduce using rule 32 (extension0 -> data_access ID extension1 .)


state 161

    (33) extension1 -> COMMA . extension0
    (32) extension0 -> . data_access ID extension1
    (110) data_access -> . PRIVATE
    (111) data_access -> . PUBLIC

    PRIVATE         shift and go to state 55
    PUBLIC          shift and go to state 56

    extension0                     shift and go to state 205
    data_access                    shift and go to state 54

state 162

    (34) extension1 -> empty .

    LBRACKET        reduce using rule 34 (extension1 -> empty .)


state 163

    (14) function0 -> DEF ID LPAREN params0 RPAREN . ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    ARROW           shift and go to state 206


state 164

    (40) params0 -> type ID . params1
    (42) params1 -> . COMMA params0
    (43) params1 -> . empty
    (149) empty -> .

    COMMA           shift and go to state 208
    RPAREN          reduce using rule 149 (empty -> .)

    params1                        shift and go to state 207
    empty                          shift and go to state 209

state 165

    (97) expression2 -> LTHAN expression3 .

    SEMICOLON       reduce using rule 97 (expression2 -> LTHAN expression3 .)
    COMMA           reduce using rule 97 (expression2 -> LTHAN expression3 .)
    RPAREN          reduce using rule 97 (expression2 -> LTHAN expression3 .)
    LPAREN          reduce using rule 97 (expression2 -> LTHAN expression3 .)


state 166

    (101) expression3 -> exp0 .

    SEMICOLON       reduce using rule 101 (expression3 -> exp0 .)
    COMMA           reduce using rule 101 (expression3 -> exp0 .)
    RPAREN          reduce using rule 101 (expression3 -> exp0 .)
    LPAREN          reduce using rule 101 (expression3 -> exp0 .)


state 167

    (102) expression3 -> CONST_BOOL .

    SEMICOLON       reduce using rule 102 (expression3 -> CONST_BOOL .)
    COMMA           reduce using rule 102 (expression3 -> CONST_BOOL .)
    RPAREN          reduce using rule 102 (expression3 -> CONST_BOOL .)
    LPAREN          reduce using rule 102 (expression3 -> CONST_BOOL .)


state 168

    (103) expression3 -> attr_access0 .
    (76) power0 -> attr_access0 . power2
    (80) power2 -> . POWER power0
    (81) power2 -> . SQRT power0
    (82) power2 -> . empty
    (149) empty -> .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 103 (expression3 -> attr_access0 .)
  ! reduce/reduce conflict for COMMA resolved using rule 103 (expression3 -> attr_access0 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 103 (expression3 -> attr_access0 .)
  ! reduce/reduce conflict for LPAREN resolved using rule 103 (expression3 -> attr_access0 .)
    SEMICOLON       reduce using rule 103 (expression3 -> attr_access0 .)
    COMMA           reduce using rule 103 (expression3 -> attr_access0 .)
    RPAREN          reduce using rule 103 (expression3 -> attr_access0 .)
    LPAREN          reduce using rule 103 (expression3 -> attr_access0 .)
    POWER           shift and go to state 77
    SQRT            shift and go to state 78
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)

  ! SEMICOLON       [ reduce using rule 149 (empty -> .) ]
  ! COMMA           [ reduce using rule 149 (empty -> .) ]
  ! RPAREN          [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    power2                         shift and go to state 82
    empty                          shift and go to state 79

state 169

    (98) expression2 -> GTHAN expression3 .

    SEMICOLON       reduce using rule 98 (expression2 -> GTHAN expression3 .)
    COMMA           reduce using rule 98 (expression2 -> GTHAN expression3 .)
    RPAREN          reduce using rule 98 (expression2 -> GTHAN expression3 .)
    LPAREN          reduce using rule 98 (expression2 -> GTHAN expression3 .)


state 170

    (99) expression2 -> DIFFERENT expression3 .

    SEMICOLON       reduce using rule 99 (expression2 -> DIFFERENT expression3 .)
    COMMA           reduce using rule 99 (expression2 -> DIFFERENT expression3 .)
    RPAREN          reduce using rule 99 (expression2 -> DIFFERENT expression3 .)
    LPAREN          reduce using rule 99 (expression2 -> DIFFERENT expression3 .)


state 171

    (100) expression2 -> EQUIVALENT expression3 .

    SEMICOLON       reduce using rule 100 (expression2 -> EQUIVALENT expression3 .)
    COMMA           reduce using rule 100 (expression2 -> EQUIVALENT expression3 .)
    RPAREN          reduce using rule 100 (expression2 -> EQUIVALENT expression3 .)
    LPAREN          reduce using rule 100 (expression2 -> EQUIVALENT expression3 .)


state 172

    (24) declaration2 -> LSQRBRACKET . exp0 RSQRBRACKET
    (61) exp0 -> . term0 exp1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    exp0                           shift and go to state 210
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 173

    (23) declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET declaration2 .

    SEMICOLON       reduce using rule 23 (declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET declaration2 .)


state 174

    (25) declaration2 -> empty .

    SEMICOLON       reduce using rule 25 (declaration2 -> empty .)


state 175

    (29) assignment2 -> LSQRBRACKET exp0 . RSQRBRACKET

    RSQRBRACKET     shift and go to state 211


state 176

    (72) power0 -> LPAREN exp0 RPAREN power2 .

    MULTIPLY        reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    DIVIDE          reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    PLUS            reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    MINUS           reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    RSQRBRACKET     reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    LTHAN           reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    GTHAN           reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    DIFFERENT       reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    EQUIVALENT      reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    SEMICOLON       reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    RPAREN          reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    COMMA           reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)
    LPAREN          reduce using rule 72 (power0 -> LPAREN exp0 RPAREN power2 .)


state 177

    (77) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET . power1 power2
    (78) power1 -> . LSQRBRACKET exp0 RSQRBRACKET
    (79) power1 -> . empty
    (149) empty -> .

    LSQRBRACKET     shift and go to state 212
    POWER           reduce using rule 149 (empty -> .)
    SQRT            reduce using rule 149 (empty -> .)
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    power1                         shift and go to state 213
    empty                          shift and go to state 214

state 178

    (86) function_call -> ID LPAREN function_call_params0 RPAREN .

    POWER           reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    SQRT            reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    MULTIPLY        reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    DIVIDE          reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    PLUS            reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    MINUS           reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    RSQRBRACKET     reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    LTHAN           reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    GTHAN           reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    DIFFERENT       reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    EQUIVALENT      reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    SEMICOLON       reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    RPAREN          reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    COMMA           reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    LPAREN          reduce using rule 86 (function_call -> ID LPAREN function_call_params0 RPAREN .)


state 179

    (87) function_call_params0 -> expression0 function_call_params1 .

    RPAREN          reduce using rule 87 (function_call_params0 -> expression0 function_call_params1 .)


state 180

    (90) function_call_params1 -> COMMA . function_call_params0
    (87) function_call_params0 -> . expression0 function_call_params1
    (88) function_call_params0 -> . CONST_STRING function_call_params1
    (89) function_call_params0 -> . empty function_call_params1
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (149) empty -> .
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_STRING    shift and go to state 136
    CONST_BOOL      shift and go to state 61
    COMMA           reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    function_call_params0          shift and go to state 215
    expression0                    shift and go to state 135
    empty                          shift and go to state 137
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 181

    (91) function_call_params1 -> empty .

    RPAREN          reduce using rule 91 (function_call_params1 -> empty .)


state 182

    (88) function_call_params0 -> CONST_STRING function_call_params1 .

    RPAREN          reduce using rule 88 (function_call_params0 -> CONST_STRING function_call_params1 .)


state 183

    (89) function_call_params0 -> empty function_call_params1 .

    RPAREN          reduce using rule 89 (function_call_params0 -> empty function_call_params1 .)


state 184

    (108) method_call1 -> ID DOT . method_call1
    (105) attr_access1 -> DOT . attr_access0
    (108) method_call1 -> . ID DOT method_call1
    (109) method_call1 -> . empty
    (104) attr_access0 -> . ID DOT ID attr_access1
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 216

  ! ID              [ reduce using rule 149 (empty -> .) ]

    method_call1                   shift and go to state 217
    attr_access0                   shift and go to state 218
    empty                          shift and go to state 140

state 185

    (104) attr_access0 -> ID DOT ID attr_access1 .

    POWER           reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    SQRT            reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    MULTIPLY        reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    DIVIDE          reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    PLUS            reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    MINUS           reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    RSQRBRACKET     reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    LTHAN           reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    GTHAN           reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    DIFFERENT       reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    EQUIVALENT      reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    SEMICOLON       reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    RPAREN          reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    COMMA           reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)
    LPAREN          reduce using rule 104 (attr_access0 -> ID DOT ID attr_access1 .)


state 186

    (106) attr_access1 -> empty .

    POWER           reduce using rule 106 (attr_access1 -> empty .)
    SQRT            reduce using rule 106 (attr_access1 -> empty .)
    MULTIPLY        reduce using rule 106 (attr_access1 -> empty .)
    DIVIDE          reduce using rule 106 (attr_access1 -> empty .)
    PLUS            reduce using rule 106 (attr_access1 -> empty .)
    MINUS           reduce using rule 106 (attr_access1 -> empty .)
    RSQRBRACKET     reduce using rule 106 (attr_access1 -> empty .)
    LTHAN           reduce using rule 106 (attr_access1 -> empty .)
    GTHAN           reduce using rule 106 (attr_access1 -> empty .)
    DIFFERENT       reduce using rule 106 (attr_access1 -> empty .)
    EQUIVALENT      reduce using rule 106 (attr_access1 -> empty .)
    SEMICOLON       reduce using rule 106 (attr_access1 -> empty .)
    RPAREN          reduce using rule 106 (attr_access1 -> empty .)
    COMMA           reduce using rule 106 (attr_access1 -> empty .)
    LPAREN          reduce using rule 106 (attr_access1 -> empty .)


state 187

    (86) function_call -> ID . LPAREN function_call_params0 RPAREN

    LPAREN          shift and go to state 84


state 188

    (107) method_call0 -> ID DOT method_call1 function_call .

    POWER           reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    SQRT            reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    MULTIPLY        reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    DIVIDE          reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    PLUS            reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    MINUS           reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    RSQRBRACKET     reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    LTHAN           reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    GTHAN           reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    DIFFERENT       reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    EQUIVALENT      reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    SEMICOLON       reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    RPAREN          reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    COMMA           reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)
    LPAREN          reduce using rule 107 (method_call0 -> ID DOT method_call1 function_call .)


state 189

    (144) object_assignment -> ID EQUALS NEW . ID LPAREN function_call_params0 RPAREN SEMICOLON

    ID              shift and go to state 219


state 190

    (108) method_call1 -> ID . DOT method_call1

    DOT             shift and go to state 220


state 191

    (120) condition0 -> IF LPAREN expression0 . RPAREN block0 condition1 SEMICOLON

    RPAREN          shift and go to state 221


state 192

    (123) writing0 -> WRITE LPAREN writing1 . LPAREN SEMICOLON

    LPAREN          shift and go to state 222


state 193

    (124) writing1 -> expression0 . writing2
    (126) writing2 -> . COMMA writing1
    (127) writing2 -> . empty
    (149) empty -> .

    COMMA           shift and go to state 224
    LPAREN          reduce using rule 149 (empty -> .)

    writing2                       shift and go to state 223
    empty                          shift and go to state 225

state 194

    (125) writing1 -> CONST_STRING . writing2
    (126) writing2 -> . COMMA writing1
    (127) writing2 -> . empty
    (149) empty -> .

    COMMA           shift and go to state 224
    LPAREN          reduce using rule 149 (empty -> .)

    writing2                       shift and go to state 226
    empty                          shift and go to state 225

state 195

    (128) reading -> READ ID SEMICOLON .

    ID              reduce using rule 128 (reading -> READ ID SEMICOLON .)
    IF              reduce using rule 128 (reading -> READ ID SEMICOLON .)
    WRITE           reduce using rule 128 (reading -> READ ID SEMICOLON .)
    READ            reduce using rule 128 (reading -> READ ID SEMICOLON .)
    RETURN          reduce using rule 128 (reading -> READ ID SEMICOLON .)
    WHILE           reduce using rule 128 (reading -> READ ID SEMICOLON .)
    RBRACKET        reduce using rule 128 (reading -> READ ID SEMICOLON .)


state 196

    (129) return -> RETURN expression0 SEMICOLON .

    ID              reduce using rule 129 (return -> RETURN expression0 SEMICOLON .)
    IF              reduce using rule 129 (return -> RETURN expression0 SEMICOLON .)
    WRITE           reduce using rule 129 (return -> RETURN expression0 SEMICOLON .)
    READ            reduce using rule 129 (return -> RETURN expression0 SEMICOLON .)
    RETURN          reduce using rule 129 (return -> RETURN expression0 SEMICOLON .)
    WHILE           reduce using rule 129 (return -> RETURN expression0 SEMICOLON .)
    RBRACKET        reduce using rule 129 (return -> RETURN expression0 SEMICOLON .)


state 197

    (131) while -> WHILE LPAREN expression0 . RPAREN block0

    RPAREN          shift and go to state 227


state 198

    (52) simple_assignment -> ID EQUALS . expression0 SEMICOLON
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_BOOL      shift and go to state 61
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    expression0                    shift and go to state 228
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 199

    (7) class0 -> CLASS ID class1 LBRACKET class2 constructor . class3 RBRACKET SEMICOLON
    (12) class3 -> . methods
    (13) class3 -> . empty
    (38) methods -> . data_access function0 methods
    (39) methods -> . empty
    (149) empty -> .
    (110) data_access -> . PRIVATE
    (111) data_access -> . PUBLIC

    RBRACKET        reduce using rule 149 (empty -> .)
    PRIVATE         shift and go to state 55
    PUBLIC          shift and go to state 56

    class3                         shift and go to state 229
    methods                        shift and go to state 230
    empty                          shift and go to state 231
    data_access                    shift and go to state 232

state 200

    (31) constructor -> CONSTRUCT . ID LPAREN params0 RPAREN function_block0

    ID              shift and go to state 233


state 201

    (35) attributes -> data_access simple_declaration . attributes
    (35) attributes -> . data_access simple_declaration attributes
    (36) attributes -> . simple_assignment attributes
    (37) attributes -> . empty
    (110) data_access -> . PRIVATE
    (111) data_access -> . PUBLIC
    (52) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (149) empty -> .

    PRIVATE         shift and go to state 55
    PUBLIC          shift and go to state 56
    ID              shift and go to state 154
    CONSTRUCT       reduce using rule 149 (empty -> .)

    data_access                    shift and go to state 158
    attributes                     shift and go to state 234
    simple_assignment              shift and go to state 159
    empty                          shift and go to state 204

state 202

    (51) simple_declaration -> ID . COLON type SEMICOLON

    COLON           shift and go to state 235


state 203

    (36) attributes -> simple_assignment attributes .

    CONSTRUCT       reduce using rule 36 (attributes -> simple_assignment attributes .)


state 204

    (37) attributes -> empty .

    CONSTRUCT       reduce using rule 37 (attributes -> empty .)


state 205

    (33) extension1 -> COMMA extension0 .

    LBRACKET        reduce using rule 33 (extension1 -> COMMA extension0 .)


state 206

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW . function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (15) function1 -> . type
    (16) function1 -> . VOID
    (47) type -> . INT
    (48) type -> . FLOAT
    (49) type -> . STRING
    (50) type -> . BOOL

    VOID            shift and go to state 238
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24

    function1                      shift and go to state 236
    type                           shift and go to state 237

state 207

    (40) params0 -> type ID params1 .

    RPAREN          reduce using rule 40 (params0 -> type ID params1 .)


state 208

    (42) params1 -> COMMA . params0
    (40) params0 -> . type ID params1
    (41) params0 -> . empty
    (47) type -> . INT
    (48) type -> . FLOAT
    (49) type -> . STRING
    (50) type -> . BOOL
    (149) empty -> .

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    RPAREN          reduce using rule 149 (empty -> .)

    params0                        shift and go to state 239
    type                           shift and go to state 108
    empty                          shift and go to state 109

state 209

    (43) params1 -> empty .

    RPAREN          reduce using rule 43 (params1 -> empty .)


state 210

    (24) declaration2 -> LSQRBRACKET exp0 . RSQRBRACKET

    RSQRBRACKET     shift and go to state 240


state 211

    (29) assignment2 -> LSQRBRACKET exp0 RSQRBRACKET .

    EQUALS          reduce using rule 29 (assignment2 -> LSQRBRACKET exp0 RSQRBRACKET .)


state 212

    (78) power1 -> LSQRBRACKET . exp0 RSQRBRACKET
    (61) exp0 -> . term0 exp1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (104) attr_access0 -> . ID DOT ID attr_access1

    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    ID              shift and go to state 47
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    exp0                           shift and go to state 241
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45
    attr_access0                   shift and go to state 46

state 213

    (77) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 . power2
    (80) power2 -> . POWER power0
    (81) power2 -> . SQRT power0
    (82) power2 -> . empty
    (149) empty -> .

    POWER           shift and go to state 77
    SQRT            shift and go to state 78
    MULTIPLY        reduce using rule 149 (empty -> .)
    DIVIDE          reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    RSQRBRACKET     reduce using rule 149 (empty -> .)
    LTHAN           reduce using rule 149 (empty -> .)
    GTHAN           reduce using rule 149 (empty -> .)
    DIFFERENT       reduce using rule 149 (empty -> .)
    EQUIVALENT      reduce using rule 149 (empty -> .)
    SEMICOLON       reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    LPAREN          reduce using rule 149 (empty -> .)

    power2                         shift and go to state 242
    empty                          shift and go to state 79

state 214

    (79) power1 -> empty .

    POWER           reduce using rule 79 (power1 -> empty .)
    SQRT            reduce using rule 79 (power1 -> empty .)
    MULTIPLY        reduce using rule 79 (power1 -> empty .)
    DIVIDE          reduce using rule 79 (power1 -> empty .)
    PLUS            reduce using rule 79 (power1 -> empty .)
    MINUS           reduce using rule 79 (power1 -> empty .)
    RSQRBRACKET     reduce using rule 79 (power1 -> empty .)
    LTHAN           reduce using rule 79 (power1 -> empty .)
    GTHAN           reduce using rule 79 (power1 -> empty .)
    DIFFERENT       reduce using rule 79 (power1 -> empty .)
    EQUIVALENT      reduce using rule 79 (power1 -> empty .)
    SEMICOLON       reduce using rule 79 (power1 -> empty .)
    RPAREN          reduce using rule 79 (power1 -> empty .)
    COMMA           reduce using rule 79 (power1 -> empty .)
    LPAREN          reduce using rule 79 (power1 -> empty .)


state 215

    (90) function_call_params1 -> COMMA function_call_params0 .

    RPAREN          reduce using rule 90 (function_call_params1 -> COMMA function_call_params0 .)


state 216

    (108) method_call1 -> ID . DOT method_call1
    (104) attr_access0 -> ID . DOT ID attr_access1

    DOT             shift and go to state 243


state 217

    (108) method_call1 -> ID DOT method_call1 .

    ID              reduce using rule 108 (method_call1 -> ID DOT method_call1 .)


state 218

    (105) attr_access1 -> DOT attr_access0 .

    POWER           reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    SQRT            reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    MULTIPLY        reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    DIVIDE          reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    PLUS            reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    MINUS           reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    RSQRBRACKET     reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    LTHAN           reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    GTHAN           reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    DIFFERENT       reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    EQUIVALENT      reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    SEMICOLON       reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    RPAREN          reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    COMMA           reduce using rule 105 (attr_access1 -> DOT attr_access0 .)
    LPAREN          reduce using rule 105 (attr_access1 -> DOT attr_access0 .)


state 219

    (144) object_assignment -> ID EQUALS NEW ID . LPAREN function_call_params0 RPAREN SEMICOLON

    LPAREN          shift and go to state 244


state 220

    (108) method_call1 -> ID DOT . method_call1
    (108) method_call1 -> . ID DOT method_call1
    (109) method_call1 -> . empty
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 190

  ! ID              [ reduce using rule 149 (empty -> .) ]

    method_call1                   shift and go to state 217
    empty                          shift and go to state 140

state 221

    (120) condition0 -> IF LPAREN expression0 RPAREN . block0 condition1 SEMICOLON
    (132) block0 -> . LBRACKET block1 RBRACKET

    LBRACKET        shift and go to state 246

    block0                         shift and go to state 245

state 222

    (123) writing0 -> WRITE LPAREN writing1 LPAREN . SEMICOLON

    SEMICOLON       shift and go to state 247


state 223

    (124) writing1 -> expression0 writing2 .

    LPAREN          reduce using rule 124 (writing1 -> expression0 writing2 .)


state 224

    (126) writing2 -> COMMA . writing1
    (124) writing1 -> . expression0 writing2
    (125) writing1 -> . CONST_STRING writing2
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_STRING    shift and go to state 194
    CONST_BOOL      shift and go to state 61
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    writing1                       shift and go to state 248
    expression0                    shift and go to state 193
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 225

    (127) writing2 -> empty .

    LPAREN          reduce using rule 127 (writing2 -> empty .)


state 226

    (125) writing1 -> CONST_STRING writing2 .

    LPAREN          reduce using rule 125 (writing1 -> CONST_STRING writing2 .)


state 227

    (131) while -> WHILE LPAREN expression0 RPAREN . block0
    (132) block0 -> . LBRACKET block1 RBRACKET

    LBRACKET        shift and go to state 246

    block0                         shift and go to state 249

state 228

    (52) simple_assignment -> ID EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 250


state 229

    (7) class0 -> CLASS ID class1 LBRACKET class2 constructor class3 . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 251


state 230

    (12) class3 -> methods .

    RBRACKET        reduce using rule 12 (class3 -> methods .)


state 231

    (13) class3 -> empty .
    (39) methods -> empty .

  ! reduce/reduce conflict for RBRACKET resolved using rule 13 (class3 -> empty .)
    RBRACKET        reduce using rule 13 (class3 -> empty .)

  ! RBRACKET        [ reduce using rule 39 (methods -> empty .) ]


state 232

    (38) methods -> data_access . function0 methods
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    DEF             shift and go to state 13

    function0                      shift and go to state 252

state 233

    (31) constructor -> CONSTRUCT ID . LPAREN params0 RPAREN function_block0

    LPAREN          shift and go to state 253


state 234

    (35) attributes -> data_access simple_declaration attributes .

    CONSTRUCT       reduce using rule 35 (attributes -> data_access simple_declaration attributes .)


state 235

    (51) simple_declaration -> ID COLON . type SEMICOLON
    (47) type -> . INT
    (48) type -> . FLOAT
    (49) type -> . STRING
    (50) type -> . BOOL

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24

    type                           shift and go to state 254

state 236

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 . LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    LSQRBRACKET     shift and go to state 255


state 237

    (15) function1 -> type .

    LSQRBRACKET     reduce using rule 15 (function1 -> type .)


state 238

    (16) function1 -> VOID .

    LSQRBRACKET     reduce using rule 16 (function1 -> VOID .)


state 239

    (42) params1 -> COMMA params0 .

    RPAREN          reduce using rule 42 (params1 -> COMMA params0 .)


state 240

    (24) declaration2 -> LSQRBRACKET exp0 RSQRBRACKET .

    SEMICOLON       reduce using rule 24 (declaration2 -> LSQRBRACKET exp0 RSQRBRACKET .)


state 241

    (78) power1 -> LSQRBRACKET exp0 . RSQRBRACKET

    RSQRBRACKET     shift and go to state 256


state 242

    (77) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .

    MULTIPLY        reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    DIVIDE          reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    PLUS            reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    MINUS           reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    RSQRBRACKET     reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    LTHAN           reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    GTHAN           reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    DIFFERENT       reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    EQUIVALENT      reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    SEMICOLON       reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    RPAREN          reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    COMMA           reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    LPAREN          reduce using rule 77 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)


state 243

    (108) method_call1 -> ID DOT . method_call1
    (104) attr_access0 -> ID DOT . ID attr_access1
    (108) method_call1 -> . ID DOT method_call1
    (109) method_call1 -> . empty
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 138

  ! ID              [ reduce using rule 149 (empty -> .) ]

    method_call1                   shift and go to state 217
    empty                          shift and go to state 140

state 244

    (144) object_assignment -> ID EQUALS NEW ID LPAREN . function_call_params0 RPAREN SEMICOLON
    (87) function_call_params0 -> . expression0 function_call_params1
    (88) function_call_params0 -> . CONST_STRING function_call_params1
    (89) function_call_params0 -> . empty function_call_params1
    (92) expression0 -> . exp0 expression1
    (93) expression0 -> . CONST_BOOL expression1
    (94) expression0 -> . attr_access0 expression1
    (149) empty -> .
    (61) exp0 -> . term0 exp1
    (104) attr_access0 -> . ID DOT ID attr_access1
    (65) term0 -> . factor term1
    (69) factor -> . PLUS power0
    (70) factor -> . MINUS power0
    (71) factor -> . power0
    (72) power0 -> . LPAREN exp0 RPAREN power2
    (73) power0 -> . const_var power2
    (74) power0 -> . function_call power2
    (75) power0 -> . method_call0 power2
    (76) power0 -> . attr_access0 power2
    (77) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (83) const_var -> . CONST_INT
    (84) const_var -> . CONST_FLOAT
    (85) const_var -> . ID
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call

    CONST_STRING    shift and go to state 136
    CONST_BOOL      shift and go to state 61
    COMMA           reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    ID              shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 41
    LPAREN          shift and go to state 42
    CONST_INT       shift and go to state 48
    CONST_FLOAT     shift and go to state 49

    function_call_params0          shift and go to state 257
    expression0                    shift and go to state 135
    empty                          shift and go to state 137
    exp0                           shift and go to state 60
    attr_access0                   shift and go to state 62
    term0                          shift and go to state 37
    factor                         shift and go to state 38
    power0                         shift and go to state 40
    const_var                      shift and go to state 43
    function_call                  shift and go to state 44
    method_call0                   shift and go to state 45

state 245

    (120) condition0 -> IF LPAREN expression0 RPAREN block0 . condition1 SEMICOLON
    (121) condition1 -> . ELSE block0
    (122) condition1 -> . empty
    (149) empty -> .

    ELSE            shift and go to state 259
    SEMICOLON       reduce using rule 149 (empty -> .)

    condition1                     shift and go to state 258
    empty                          shift and go to state 260

state 246

    (132) block0 -> LBRACKET . block1 RBRACKET
    (133) block1 -> . statement block1
    (134) block1 -> . empty
    (135) statement -> . assignment0
    (136) statement -> . object_assignment
    (137) statement -> . condition0
    (138) statement -> . writing0
    (139) statement -> . reading
    (140) statement -> . return
    (141) statement -> . function_call SEMICOLON
    (142) statement -> . method_call0 SEMICOLON
    (143) statement -> . while
    (149) empty -> .
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (144) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (120) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (123) writing0 -> . WRITE LPAREN writing1 LPAREN SEMICOLON
    (128) reading -> . READ ID SEMICOLON
    (129) return -> . RETURN expression0 SEMICOLON
    (130) return -> . RETURN SEMICOLON
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (131) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 149 (empty -> .)
    ID              shift and go to state 264
    IF              shift and go to state 100
    WRITE           shift and go to state 101
    READ            shift and go to state 102
    RETURN          shift and go to state 103
    WHILE           shift and go to state 104

    block1                         shift and go to state 261
    statement                      shift and go to state 262
    empty                          shift and go to state 263
    assignment0                    shift and go to state 91
    object_assignment              shift and go to state 92
    condition0                     shift and go to state 93
    writing0                       shift and go to state 94
    reading                        shift and go to state 95
    return                         shift and go to state 96
    function_call                  shift and go to state 97
    method_call0                   shift and go to state 98
    while                          shift and go to state 99

state 247

    (123) writing0 -> WRITE LPAREN writing1 LPAREN SEMICOLON .

    ID              reduce using rule 123 (writing0 -> WRITE LPAREN writing1 LPAREN SEMICOLON .)
    IF              reduce using rule 123 (writing0 -> WRITE LPAREN writing1 LPAREN SEMICOLON .)
    WRITE           reduce using rule 123 (writing0 -> WRITE LPAREN writing1 LPAREN SEMICOLON .)
    READ            reduce using rule 123 (writing0 -> WRITE LPAREN writing1 LPAREN SEMICOLON .)
    RETURN          reduce using rule 123 (writing0 -> WRITE LPAREN writing1 LPAREN SEMICOLON .)
    WHILE           reduce using rule 123 (writing0 -> WRITE LPAREN writing1 LPAREN SEMICOLON .)
    RBRACKET        reduce using rule 123 (writing0 -> WRITE LPAREN writing1 LPAREN SEMICOLON .)


state 248

    (126) writing2 -> COMMA writing1 .

    LPAREN          reduce using rule 126 (writing2 -> COMMA writing1 .)


state 249

    (131) while -> WHILE LPAREN expression0 RPAREN block0 .

    ID              reduce using rule 131 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    IF              reduce using rule 131 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    WRITE           reduce using rule 131 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    READ            reduce using rule 131 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    RETURN          reduce using rule 131 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    WHILE           reduce using rule 131 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    RBRACKET        reduce using rule 131 (while -> WHILE LPAREN expression0 RPAREN block0 .)


state 250

    (52) simple_assignment -> ID EQUALS expression0 SEMICOLON .

    PRIVATE         reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    PUBLIC          reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    CONSTRUCT       reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    RSQRBRACKET     reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 52 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)


state 251

    (7) class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 265


state 252

    (38) methods -> data_access function0 . methods
    (38) methods -> . data_access function0 methods
    (39) methods -> . empty
    (110) data_access -> . PRIVATE
    (111) data_access -> . PUBLIC
    (149) empty -> .

    PRIVATE         shift and go to state 55
    PUBLIC          shift and go to state 56
    RBRACKET        reduce using rule 149 (empty -> .)

    data_access                    shift and go to state 232
    methods                        shift and go to state 266
    empty                          shift and go to state 267

state 253

    (31) constructor -> CONSTRUCT ID LPAREN . params0 RPAREN function_block0
    (40) params0 -> . type ID params1
    (41) params0 -> . empty
    (47) type -> . INT
    (48) type -> . FLOAT
    (49) type -> . STRING
    (50) type -> . BOOL
    (149) empty -> .

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    RPAREN          reduce using rule 149 (empty -> .)

    params0                        shift and go to state 268
    type                           shift and go to state 108
    empty                          shift and go to state 109

state 254

    (51) simple_declaration -> ID COLON type . SEMICOLON

    SEMICOLON       shift and go to state 269


state 255

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET . LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    LSQRBRACKET     shift and go to state 270


state 256

    (78) power1 -> LSQRBRACKET exp0 RSQRBRACKET .

    POWER           reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    SQRT            reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    MULTIPLY        reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    DIVIDE          reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    PLUS            reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    MINUS           reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    RSQRBRACKET     reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    LTHAN           reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    GTHAN           reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    DIFFERENT       reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    EQUIVALENT      reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    SEMICOLON       reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    RPAREN          reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    COMMA           reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    LPAREN          reduce using rule 78 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)


state 257

    (144) object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 . RPAREN SEMICOLON

    RPAREN          shift and go to state 271


state 258

    (120) condition0 -> IF LPAREN expression0 RPAREN block0 condition1 . SEMICOLON

    SEMICOLON       shift and go to state 272


state 259

    (121) condition1 -> ELSE . block0
    (132) block0 -> . LBRACKET block1 RBRACKET

    LBRACKET        shift and go to state 246

    block0                         shift and go to state 273

state 260

    (122) condition1 -> empty .

    SEMICOLON       reduce using rule 122 (condition1 -> empty .)


state 261

    (132) block0 -> LBRACKET block1 . RBRACKET

    RBRACKET        shift and go to state 274


state 262

    (133) block1 -> statement . block1
    (133) block1 -> . statement block1
    (134) block1 -> . empty
    (135) statement -> . assignment0
    (136) statement -> . object_assignment
    (137) statement -> . condition0
    (138) statement -> . writing0
    (139) statement -> . reading
    (140) statement -> . return
    (141) statement -> . function_call SEMICOLON
    (142) statement -> . method_call0 SEMICOLON
    (143) statement -> . while
    (149) empty -> .
    (26) assignment0 -> . ID assignment1 EQUALS expression0 SEMICOLON
    (144) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (120) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (123) writing0 -> . WRITE LPAREN writing1 LPAREN SEMICOLON
    (128) reading -> . READ ID SEMICOLON
    (129) return -> . RETURN expression0 SEMICOLON
    (130) return -> . RETURN SEMICOLON
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (131) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 149 (empty -> .)
    ID              shift and go to state 264
    IF              shift and go to state 100
    WRITE           shift and go to state 101
    READ            shift and go to state 102
    RETURN          shift and go to state 103
    WHILE           shift and go to state 104

    statement                      shift and go to state 262
    block1                         shift and go to state 275
    empty                          shift and go to state 263
    assignment0                    shift and go to state 91
    object_assignment              shift and go to state 92
    condition0                     shift and go to state 93
    writing0                       shift and go to state 94
    reading                        shift and go to state 95
    return                         shift and go to state 96
    function_call                  shift and go to state 97
    method_call0                   shift and go to state 98
    while                          shift and go to state 99

state 263

    (134) block1 -> empty .

    RBRACKET        reduce using rule 134 (block1 -> empty .)


state 264

    (26) assignment0 -> ID . assignment1 EQUALS expression0 SEMICOLON
    (144) object_assignment -> ID . EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (86) function_call -> ID . LPAREN function_call_params0 RPAREN
    (107) method_call0 -> ID . DOT method_call1 function_call
    (27) assignment1 -> . LSQRBRACKET exp0 RSQRBRACKET assignment2
    (28) assignment1 -> . empty
    (149) empty -> .

  ! shift/reduce conflict for EQUALS resolved as shift
    EQUALS          shift and go to state 144
    LPAREN          shift and go to state 84
    DOT             shift and go to state 145
    LSQRBRACKET     shift and go to state 19

  ! EQUALS          [ reduce using rule 149 (empty -> .) ]

    assignment1                    shift and go to state 16
    empty                          shift and go to state 20

state 265

    (7) class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .

    CLASS           reduce using rule 7 (class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .)
    DEF             reduce using rule 7 (class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .)
    ID              reduce using rule 7 (class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .)
    MAIN            reduce using rule 7 (class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .)


state 266

    (38) methods -> data_access function0 methods .

    RBRACKET        reduce using rule 38 (methods -> data_access function0 methods .)


state 267

    (39) methods -> empty .

    RBRACKET        reduce using rule 39 (methods -> empty .)


state 268

    (31) constructor -> CONSTRUCT ID LPAREN params0 . RPAREN function_block0

    RPAREN          shift and go to state 276


state 269

    (51) simple_declaration -> ID COLON type SEMICOLON .

    PRIVATE         reduce using rule 51 (simple_declaration -> ID COLON type SEMICOLON .)
    PUBLIC          reduce using rule 51 (simple_declaration -> ID COLON type SEMICOLON .)
    ID              reduce using rule 51 (simple_declaration -> ID COLON type SEMICOLON .)
    CONSTRUCT       reduce using rule 51 (simple_declaration -> ID COLON type SEMICOLON .)
    RSQRBRACKET     reduce using rule 51 (simple_declaration -> ID COLON type SEMICOLON .)


state 270

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET . function2 RSQRBRACKET RSQRBRACKET function_block0
    (17) function2 -> . simple_declaration function2
    (18) function2 -> . simple_assignment function2
    (19) function2 -> . empty
    (51) simple_declaration -> . ID COLON type SEMICOLON
    (52) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (149) empty -> .

    ID              shift and go to state 277
    RSQRBRACKET     reduce using rule 149 (empty -> .)

    function2                      shift and go to state 278
    simple_declaration             shift and go to state 279
    simple_assignment              shift and go to state 280
    empty                          shift and go to state 281

state 271

    (144) object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 282


state 272

    (120) condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .

    ID              reduce using rule 120 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    IF              reduce using rule 120 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    WRITE           reduce using rule 120 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    READ            reduce using rule 120 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    RETURN          reduce using rule 120 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    WHILE           reduce using rule 120 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    RBRACKET        reduce using rule 120 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)


state 273

    (121) condition1 -> ELSE block0 .

    SEMICOLON       reduce using rule 121 (condition1 -> ELSE block0 .)


state 274

    (132) block0 -> LBRACKET block1 RBRACKET .

    ELSE            reduce using rule 132 (block0 -> LBRACKET block1 RBRACKET .)
    SEMICOLON       reduce using rule 132 (block0 -> LBRACKET block1 RBRACKET .)
    ID              reduce using rule 132 (block0 -> LBRACKET block1 RBRACKET .)
    IF              reduce using rule 132 (block0 -> LBRACKET block1 RBRACKET .)
    WRITE           reduce using rule 132 (block0 -> LBRACKET block1 RBRACKET .)
    READ            reduce using rule 132 (block0 -> LBRACKET block1 RBRACKET .)
    RETURN          reduce using rule 132 (block0 -> LBRACKET block1 RBRACKET .)
    WHILE           reduce using rule 132 (block0 -> LBRACKET block1 RBRACKET .)
    RBRACKET        reduce using rule 132 (block0 -> LBRACKET block1 RBRACKET .)


state 275

    (133) block1 -> statement block1 .

    RBRACKET        reduce using rule 133 (block1 -> statement block1 .)


state 276

    (31) constructor -> CONSTRUCT ID LPAREN params0 RPAREN . function_block0
    (44) function_block0 -> . LBRACKET function_block1 RBRACKET

    LBRACKET        shift and go to state 284

    function_block0                shift and go to state 283

state 277

    (51) simple_declaration -> ID . COLON type SEMICOLON
    (52) simple_assignment -> ID . EQUALS expression0 SEMICOLON

    COLON           shift and go to state 235
    EQUALS          shift and go to state 198


state 278

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 . RSQRBRACKET RSQRBRACKET function_block0

    RSQRBRACKET     shift and go to state 285


state 279

    (17) function2 -> simple_declaration . function2
    (17) function2 -> . simple_declaration function2
    (18) function2 -> . simple_assignment function2
    (19) function2 -> . empty
    (51) simple_declaration -> . ID COLON type SEMICOLON
    (52) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (149) empty -> .

    ID              shift and go to state 277
    RSQRBRACKET     reduce using rule 149 (empty -> .)

    simple_declaration             shift and go to state 279
    function2                      shift and go to state 286
    simple_assignment              shift and go to state 280
    empty                          shift and go to state 281

state 280

    (18) function2 -> simple_assignment . function2
    (17) function2 -> . simple_declaration function2
    (18) function2 -> . simple_assignment function2
    (19) function2 -> . empty
    (51) simple_declaration -> . ID COLON type SEMICOLON
    (52) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (149) empty -> .

    ID              shift and go to state 277
    RSQRBRACKET     reduce using rule 149 (empty -> .)

    simple_assignment              shift and go to state 280
    function2                      shift and go to state 287
    simple_declaration             shift and go to state 279
    empty                          shift and go to state 281

state 281

    (19) function2 -> empty .

    RSQRBRACKET     reduce using rule 19 (function2 -> empty .)


state 282

    (144) object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .

    ID              reduce using rule 144 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    IF              reduce using rule 144 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    WRITE           reduce using rule 144 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    READ            reduce using rule 144 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    RETURN          reduce using rule 144 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    WHILE           reduce using rule 144 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 144 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)


state 283

    (31) constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .

    PRIVATE         reduce using rule 31 (constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .)
    PUBLIC          reduce using rule 31 (constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .)
    RBRACKET        reduce using rule 31 (constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .)


state 284

    (44) function_block0 -> LBRACKET . function_block1 RBRACKET
    (45) function_block1 -> . function_statement function_block1
    (46) function_block1 -> . empty
    (112) function_statement -> . simple_assignment
    (113) function_statement -> . condition0
    (114) function_statement -> . writing0
    (115) function_statement -> . reading
    (116) function_statement -> . return
    (117) function_statement -> . function_call SEMICOLON
    (118) function_statement -> . method_call0 SEMICOLON
    (119) function_statement -> . while
    (149) empty -> .
    (52) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (120) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (123) writing0 -> . WRITE LPAREN writing1 LPAREN SEMICOLON
    (128) reading -> . READ ID SEMICOLON
    (129) return -> . RETURN expression0 SEMICOLON
    (130) return -> . RETURN SEMICOLON
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (131) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 149 (empty -> .)
    ID              shift and go to state 299
    IF              shift and go to state 100
    WRITE           shift and go to state 101
    READ            shift and go to state 102
    RETURN          shift and go to state 103
    WHILE           shift and go to state 104

    function_block1                shift and go to state 288
    function_statement             shift and go to state 289
    empty                          shift and go to state 290
    simple_assignment              shift and go to state 291
    condition0                     shift and go to state 292
    writing0                       shift and go to state 293
    reading                        shift and go to state 294
    return                         shift and go to state 295
    function_call                  shift and go to state 296
    method_call0                   shift and go to state 297
    while                          shift and go to state 298

state 285

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET . RSQRBRACKET function_block0

    RSQRBRACKET     shift and go to state 300


state 286

    (17) function2 -> simple_declaration function2 .

    RSQRBRACKET     reduce using rule 17 (function2 -> simple_declaration function2 .)


state 287

    (18) function2 -> simple_assignment function2 .

    RSQRBRACKET     reduce using rule 18 (function2 -> simple_assignment function2 .)


state 288

    (44) function_block0 -> LBRACKET function_block1 . RBRACKET

    RBRACKET        shift and go to state 301


state 289

    (45) function_block1 -> function_statement . function_block1
    (45) function_block1 -> . function_statement function_block1
    (46) function_block1 -> . empty
    (112) function_statement -> . simple_assignment
    (113) function_statement -> . condition0
    (114) function_statement -> . writing0
    (115) function_statement -> . reading
    (116) function_statement -> . return
    (117) function_statement -> . function_call SEMICOLON
    (118) function_statement -> . method_call0 SEMICOLON
    (119) function_statement -> . while
    (149) empty -> .
    (52) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (120) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (123) writing0 -> . WRITE LPAREN writing1 LPAREN SEMICOLON
    (128) reading -> . READ ID SEMICOLON
    (129) return -> . RETURN expression0 SEMICOLON
    (130) return -> . RETURN SEMICOLON
    (86) function_call -> . ID LPAREN function_call_params0 RPAREN
    (107) method_call0 -> . ID DOT method_call1 function_call
    (131) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 149 (empty -> .)
    ID              shift and go to state 299
    IF              shift and go to state 100
    WRITE           shift and go to state 101
    READ            shift and go to state 102
    RETURN          shift and go to state 103
    WHILE           shift and go to state 104

    function_statement             shift and go to state 289
    function_block1                shift and go to state 302
    empty                          shift and go to state 290
    simple_assignment              shift and go to state 291
    condition0                     shift and go to state 292
    writing0                       shift and go to state 293
    reading                        shift and go to state 294
    return                         shift and go to state 295
    function_call                  shift and go to state 296
    method_call0                   shift and go to state 297
    while                          shift and go to state 298

state 290

    (46) function_block1 -> empty .

    RBRACKET        reduce using rule 46 (function_block1 -> empty .)


state 291

    (112) function_statement -> simple_assignment .

    ID              reduce using rule 112 (function_statement -> simple_assignment .)
    IF              reduce using rule 112 (function_statement -> simple_assignment .)
    WRITE           reduce using rule 112 (function_statement -> simple_assignment .)
    READ            reduce using rule 112 (function_statement -> simple_assignment .)
    RETURN          reduce using rule 112 (function_statement -> simple_assignment .)
    WHILE           reduce using rule 112 (function_statement -> simple_assignment .)
    RBRACKET        reduce using rule 112 (function_statement -> simple_assignment .)


state 292

    (113) function_statement -> condition0 .

    ID              reduce using rule 113 (function_statement -> condition0 .)
    IF              reduce using rule 113 (function_statement -> condition0 .)
    WRITE           reduce using rule 113 (function_statement -> condition0 .)
    READ            reduce using rule 113 (function_statement -> condition0 .)
    RETURN          reduce using rule 113 (function_statement -> condition0 .)
    WHILE           reduce using rule 113 (function_statement -> condition0 .)
    RBRACKET        reduce using rule 113 (function_statement -> condition0 .)


state 293

    (114) function_statement -> writing0 .

    ID              reduce using rule 114 (function_statement -> writing0 .)
    IF              reduce using rule 114 (function_statement -> writing0 .)
    WRITE           reduce using rule 114 (function_statement -> writing0 .)
    READ            reduce using rule 114 (function_statement -> writing0 .)
    RETURN          reduce using rule 114 (function_statement -> writing0 .)
    WHILE           reduce using rule 114 (function_statement -> writing0 .)
    RBRACKET        reduce using rule 114 (function_statement -> writing0 .)


state 294

    (115) function_statement -> reading .

    ID              reduce using rule 115 (function_statement -> reading .)
    IF              reduce using rule 115 (function_statement -> reading .)
    WRITE           reduce using rule 115 (function_statement -> reading .)
    READ            reduce using rule 115 (function_statement -> reading .)
    RETURN          reduce using rule 115 (function_statement -> reading .)
    WHILE           reduce using rule 115 (function_statement -> reading .)
    RBRACKET        reduce using rule 115 (function_statement -> reading .)


state 295

    (116) function_statement -> return .

    ID              reduce using rule 116 (function_statement -> return .)
    IF              reduce using rule 116 (function_statement -> return .)
    WRITE           reduce using rule 116 (function_statement -> return .)
    READ            reduce using rule 116 (function_statement -> return .)
    RETURN          reduce using rule 116 (function_statement -> return .)
    WHILE           reduce using rule 116 (function_statement -> return .)
    RBRACKET        reduce using rule 116 (function_statement -> return .)


state 296

    (117) function_statement -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 303


state 297

    (118) function_statement -> method_call0 . SEMICOLON

    SEMICOLON       shift and go to state 304


state 298

    (119) function_statement -> while .

    ID              reduce using rule 119 (function_statement -> while .)
    IF              reduce using rule 119 (function_statement -> while .)
    WRITE           reduce using rule 119 (function_statement -> while .)
    READ            reduce using rule 119 (function_statement -> while .)
    RETURN          reduce using rule 119 (function_statement -> while .)
    WHILE           reduce using rule 119 (function_statement -> while .)
    RBRACKET        reduce using rule 119 (function_statement -> while .)


state 299

    (52) simple_assignment -> ID . EQUALS expression0 SEMICOLON
    (86) function_call -> ID . LPAREN function_call_params0 RPAREN
    (107) method_call0 -> ID . DOT method_call1 function_call

    EQUALS          shift and go to state 198
    LPAREN          shift and go to state 84
    DOT             shift and go to state 145


state 300

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET . function_block0
    (44) function_block0 -> . LBRACKET function_block1 RBRACKET

    LBRACKET        shift and go to state 284

    function_block0                shift and go to state 305

state 301

    (44) function_block0 -> LBRACKET function_block1 RBRACKET .

    PRIVATE         reduce using rule 44 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    PUBLIC          reduce using rule 44 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    RBRACKET        reduce using rule 44 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    CLASS           reduce using rule 44 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    DEF             reduce using rule 44 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    ID              reduce using rule 44 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    MAIN            reduce using rule 44 (function_block0 -> LBRACKET function_block1 RBRACKET .)


state 302

    (45) function_block1 -> function_statement function_block1 .

    RBRACKET        reduce using rule 45 (function_block1 -> function_statement function_block1 .)


state 303

    (117) function_statement -> function_call SEMICOLON .

    ID              reduce using rule 117 (function_statement -> function_call SEMICOLON .)
    IF              reduce using rule 117 (function_statement -> function_call SEMICOLON .)
    WRITE           reduce using rule 117 (function_statement -> function_call SEMICOLON .)
    READ            reduce using rule 117 (function_statement -> function_call SEMICOLON .)
    RETURN          reduce using rule 117 (function_statement -> function_call SEMICOLON .)
    WHILE           reduce using rule 117 (function_statement -> function_call SEMICOLON .)
    RBRACKET        reduce using rule 117 (function_statement -> function_call SEMICOLON .)


state 304

    (118) function_statement -> method_call0 SEMICOLON .

    ID              reduce using rule 118 (function_statement -> method_call0 SEMICOLON .)
    IF              reduce using rule 118 (function_statement -> method_call0 SEMICOLON .)
    WRITE           reduce using rule 118 (function_statement -> method_call0 SEMICOLON .)
    READ            reduce using rule 118 (function_statement -> method_call0 SEMICOLON .)
    RETURN          reduce using rule 118 (function_statement -> method_call0 SEMICOLON .)
    WHILE           reduce using rule 118 (function_statement -> method_call0 SEMICOLON .)
    RBRACKET        reduce using rule 118 (function_statement -> method_call0 SEMICOLON .)


state 305

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .

    CLASS           reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    DEF             reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    ID              reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    MAIN            reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    PRIVATE         reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    PUBLIC          reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    RBRACKET        reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 47 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 58 resolved as shift
WARNING: shift/reduce conflict for LTHAN in state 62 resolved as shift
WARNING: shift/reduce conflict for GTHAN in state 62 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 62 resolved as shift
WARNING: shift/reduce conflict for EQUIVALENT in state 62 resolved as shift
WARNING: shift/reduce conflict for ID in state 85 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 110 resolved as shift
WARNING: shift/reduce conflict for ID in state 145 resolved as shift
WARNING: shift/reduce conflict for ID in state 184 resolved as shift
WARNING: shift/reduce conflict for ID in state 220 resolved as shift
WARNING: shift/reduce conflict for ID in state 243 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 264 resolved as shift
WARNING: reduce/reduce conflict in state 121 resolved using rule (power2 -> empty)
WARNING: rejected rule (expression1 -> empty) in state 121
WARNING: reduce/reduce conflict in state 157 resolved using rule (class2 -> empty)
WARNING: rejected rule (attributes -> empty) in state 157
WARNING: reduce/reduce conflict in state 168 resolved using rule (expression3 -> attr_access0)
WARNING: rejected rule (empty -> <empty>) in state 168
WARNING: reduce/reduce conflict in state 231 resolved using rule (class3 -> empty)
WARNING: rejected rule (methods -> empty) in state 231
