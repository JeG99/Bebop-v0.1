Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    CONST_BOOL
    NOT
    OR

Grammar

Rule 0     S' -> routine0
Rule 1     routine0 -> ROUTINE ID SEMICOLON routine1 main0
Rule 2     routine1 -> class0 routine1
Rule 3     routine1 -> function0 routine1
Rule 4     routine1 -> declaration0 routine1
Rule 5     routine1 -> assignment0 routine1
Rule 6     routine1 -> empty
Rule 7     class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
Rule 8     class1 -> COLON extension0
Rule 9     class1 -> empty
Rule 10    class2 -> attributes
Rule 11    class2 -> empty
Rule 12    class3 -> methods
Rule 13    class3 -> empty
Rule 14    function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
Rule 15    function1 -> type
Rule 16    function1 -> VOID
Rule 17    function2 -> simple_declaration function2
Rule 18    function2 -> simple_assignment function2
Rule 19    function2 -> empty
Rule 20    declaration0 -> ID COLON declaration1 SEMICOLON
Rule 21    declaration1 -> type
Rule 22    declaration1 -> complex_type
Rule 23    declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET declaration2
Rule 24    declaration2 -> LSQRBRACKET exp0 RSQRBRACKET
Rule 25    declaration2 -> empty
Rule 26    assignment0 -> ID EQUALS expression0 SEMICOLON
Rule 27    assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
Rule 28    assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
Rule 29    constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0
Rule 30    extension0 -> ID
Rule 31    attributes -> data_access simple_declaration attributes
Rule 32    attributes -> simple_assignment attributes
Rule 33    attributes -> empty
Rule 34    methods -> data_access function0 methods
Rule 35    methods -> empty
Rule 36    params0 -> type ID params1
Rule 37    params0 -> empty
Rule 38    params1 -> COMMA params0
Rule 39    params1 -> empty
Rule 40    function_block0 -> LBRACKET function_block1 RBRACKET
Rule 41    function_block1 -> function_statement function_block1
Rule 42    function_block1 -> empty
Rule 43    type -> INT
Rule 44    type -> FLOAT
Rule 45    type -> STRING
Rule 46    type -> BOOL
Rule 47    simple_declaration -> ID COLON type SEMICOLON
Rule 48    simple_assignment -> ID EQUALS expression0 SEMICOLON
Rule 49    complex_type -> ID
Rule 50    logic_or0 -> logic_and0 logic_or1
Rule 51    logic_or1 -> OR logic_or0
Rule 52    logic_or1 -> empty
Rule 53    logic_and0 -> logic_operand logic_and1
Rule 54    logic_and1 -> AND logic_and0
Rule 55    logic_and1 -> empty
Rule 56    logic_operand -> NOT expression0
Rule 57    exp0 -> term0 exp1
Rule 58    exp1 -> PLUS exp0
Rule 59    exp1 -> MINUS exp0
Rule 60    exp1 -> empty
Rule 61    term0 -> factor term1
Rule 62    term1 -> MULTIPLY term0
Rule 63    term1 -> DIVIDE term0
Rule 64    term1 -> empty
Rule 65    factor -> PLUS power0
Rule 66    factor -> MINUS power0
Rule 67    factor -> power0
Rule 68    power0 -> LPAREN exp0 RPAREN power2
Rule 69    power0 -> const_var power2
Rule 70    power0 -> function_call power2
Rule 71    power0 -> method_call0 power2
Rule 72    power0 -> attr_access0 power2
Rule 73    power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
Rule 74    power1 -> LSQRBRACKET exp0 RSQRBRACKET
Rule 75    power1 -> empty
Rule 76    power2 -> POWER power0
Rule 77    power2 -> SQRT power0
Rule 78    power2 -> empty
Rule 79    const_var -> CONST_INT
Rule 80    const_var -> CONST_FLOAT
Rule 81    const_var -> ID
Rule 82    function_call -> ID LPAREN function_call_params0 RPAREN
Rule 83    function_call_params0 -> expression0 function_call_params1
Rule 84    function_call_params0 -> CONST_STRING function_call_params1
Rule 85    function_call_params0 -> empty function_call_params1
Rule 86    function_call_params1 -> COMMA function_call_params0
Rule 87    function_call_params1 -> empty
Rule 88    expression0 -> exp0 expression1
Rule 89    expression0 -> CONST_BOOL expression1
Rule 90    expression0 -> attr_access0 expression1
Rule 91    expression1 -> empty
Rule 92    expression1 -> expression2
Rule 93    expression2 -> LTHAN expression3
Rule 94    expression2 -> GTHAN expression3
Rule 95    expression2 -> DIFFERENT expression3
Rule 96    expression2 -> EQUIVALENT expression3
Rule 97    expression3 -> exp0
Rule 98    expression3 -> CONST_BOOL
Rule 99    expression3 -> attr_access0
Rule 100   attr_access0 -> ID DOT ID
Rule 101   method_call0 -> ID DOT function_call
Rule 102   data_access -> PRIVATE
Rule 103   data_access -> PUBLIC
Rule 104   function_statement -> simple_assignment
Rule 105   function_statement -> condition0
Rule 106   function_statement -> writing0
Rule 107   function_statement -> reading
Rule 108   function_statement -> return
Rule 109   function_statement -> function_call SEMICOLON
Rule 110   function_statement -> method_call0 SEMICOLON
Rule 111   function_statement -> while
Rule 112   condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
Rule 113   condition1 -> ELSE block0
Rule 114   condition1 -> empty
Rule 115   writing0 -> WRITE LPAREN writing1 RPAREN SEMICOLON
Rule 116   writing1 -> expression0 writing2
Rule 117   writing1 -> CONST_STRING writing2
Rule 118   writing2 -> COMMA writing1
Rule 119   writing2 -> empty
Rule 120   reading -> READ ID SEMICOLON
Rule 121   return -> RETURN expression0 SEMICOLON
Rule 122   return -> RETURN SEMICOLON
Rule 123   while -> WHILE LPAREN expression0 RPAREN block0
Rule 124   block0 -> LBRACKET block1 RBRACKET
Rule 125   block1 -> statement block1
Rule 126   block1 -> empty
Rule 127   statement -> assignment0
Rule 128   statement -> object_assignment
Rule 129   statement -> condition0
Rule 130   statement -> writing0
Rule 131   statement -> reading
Rule 132   statement -> return
Rule 133   statement -> function_call SEMICOLON
Rule 134   statement -> method_call0 SEMICOLON
Rule 135   statement -> while
Rule 136   object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
Rule 137   main0 -> MAIN LBRACKET main1 RBRACKET
Rule 138   main1 -> declaration0 main1
Rule 139   main1 -> statement main1
Rule 140   main1 -> empty
Rule 141   empty -> <empty>

Terminals, with rules where they appear

AND                  : 54
ARROW                : 14
BOOL                 : 46
CLASS                : 7
COLON                : 8 20 47
COMMA                : 38 86 118
CONSTRUCT            : 29
CONST_BOOL           : 89 98
CONST_FLOAT          : 80
CONST_INT            : 79
CONST_STRING         : 84 117
DEF                  : 14
DIFFERENT            : 95
DIVIDE               : 63
DOT                  : 100 101
ELSE                 : 113
EQUALS               : 26 27 28 48 136
EQUIVALENT           : 96
FLOAT                : 44
GTHAN                : 94
ID                   : 1 7 14 20 26 27 28 29 30 36 47 48 49 73 81 82 100 100 101 120 136 136
IF                   : 112
INT                  : 43
LBRACKET             : 7 40 124 137
LPAREN               : 14 29 68 82 112 115 123 136
LSQRBRACKET          : 14 14 23 24 27 28 28 73 74
LTHAN                : 93
MAIN                 : 137
MINUS                : 59 66
MULTIPLY             : 62
NEW                  : 136
NOT                  : 56
OR                   : 51
PLUS                 : 58 65
POWER                : 76
PRIVATE              : 102
PUBLIC               : 103
RBRACKET             : 7 40 124 137
READ                 : 120
RETURN               : 121 122
ROUTINE              : 1
RPAREN               : 14 29 68 82 112 115 123 136
RSQRBRACKET          : 14 14 23 24 27 28 28 73 74
SEMICOLON            : 1 7 20 26 27 28 47 48 109 110 112 115 120 121 122 133 134 136
SQRT                 : 77
STRING               : 45
VOID                 : 16
WHILE                : 123
WRITE                : 115
error                : 

Nonterminals, with rules where they appear

assignment0          : 5 127
attr_access0         : 72 90 99
attributes           : 10 31 32
block0               : 112 113 123
block1               : 124 125
class0               : 2
class1               : 7
class2               : 7
class3               : 7
complex_type         : 22
condition0           : 105 129
condition1           : 112
const_var            : 69
constructor          : 7
data_access          : 31 34
declaration0         : 4 138
declaration1         : 20
declaration2         : 23
empty                : 6 9 11 13 19 25 33 35 37 39 42 52 55 60 64 75 78 85 87 91 114 119 126 140
exp0                 : 23 24 27 28 28 58 59 68 73 74 88 97
exp1                 : 57
expression0          : 26 27 28 48 56 83 112 116 121 123
expression1          : 88 89 90
expression2          : 92
expression3          : 93 94 95 96
extension0           : 8
factor               : 61
function0            : 3 34
function1            : 14
function2            : 14 17 18
function_block0      : 14 29
function_block1      : 40 41
function_call        : 70 101 109 133
function_call_params0 : 82 86 136
function_call_params1 : 83 84 85
function_statement   : 41
logic_and0           : 50 54
logic_and1           : 53
logic_operand        : 53
logic_or0            : 51
logic_or1            : 50
main0                : 1
main1                : 137 138 139
method_call0         : 71 110 134
methods              : 12 34
object_assignment    : 128
params0              : 14 29 38
params1              : 36
power0               : 65 66 67 76 77
power1               : 73
power2               : 68 69 70 71 72 73
reading              : 107 131
return               : 108 132
routine0             : 0
routine1             : 1 2 3 4 5
simple_assignment    : 18 32 104
simple_declaration   : 17 31
statement            : 125 139
term0                : 57 62 63
term1                : 61
type                 : 15 21 23 36 47
while                : 111 135
writing0             : 106 130
writing1             : 115 118
writing2             : 116 117

Parsing method: LALR

state 0

    (0) S' -> . routine0
    (1) routine0 -> . ROUTINE ID SEMICOLON routine1 main0

    ROUTINE         shift and go to state 2

    routine0                       shift and go to state 1

state 1

    (0) S' -> routine0 .



state 2

    (1) routine0 -> ROUTINE . ID SEMICOLON routine1 main0

    ID              shift and go to state 3


state 3

    (1) routine0 -> ROUTINE ID . SEMICOLON routine1 main0

    SEMICOLON       shift and go to state 4


state 4

<<<<<<< Updated upstream
    (1) routine0 -> ROUTINE ID SEMICOLON . routine1 main0
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID COLON declaration1 SEMICOLON
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (141) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 141 (empty -> .)

    routine1                       shift and go to state 6
    class0                         shift and go to state 7
    function0                      shift and go to state 8
    declaration0                   shift and go to state 9
    assignment0                    shift and go to state 10
    empty                          shift and go to state 11
=======
    (1) routine0 -> ROUTINE ID SEMICOLON . global_scope routine1 main0
    (8) global_scope -> .

    CLASS           reduce using rule 8 (global_scope -> .)
    DEF             reduce using rule 8 (global_scope -> .)
    ID              reduce using rule 8 (global_scope -> .)
    IF              reduce using rule 8 (global_scope -> .)
    WRITE           reduce using rule 8 (global_scope -> .)
    READ            reduce using rule 8 (global_scope -> .)
    RETURN          reduce using rule 8 (global_scope -> .)
    WHILE           reduce using rule 8 (global_scope -> .)
    MAIN            reduce using rule 8 (global_scope -> .)

    global_scope                   shift and go to state 5

state 5

    (1) routine0 -> ROUTINE ID SEMICOLON global_scope . routine1 main0
    (2) routine1 -> . statement routine1
    (3) routine1 -> . class0 routine1
    (4) routine1 -> . function0 routine1
    (5) routine1 -> . declaration0 routine1
    (6) routine1 -> . assignment0 routine1
    (7) routine1 -> . empty
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (9) class0 -> . CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global
    (20) function0 -> . DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (26) declaration0 -> . decl_id_def COLON declaration1 SEMICOLON
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (145) empty -> .
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0
    (27) decl_id_def -> . ID

    CLASS           shift and go to state 22
    DEF             shift and go to state 23
    ID              shift and go to state 6
    MAIN            reduce using rule 145 (empty -> .)
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    routine1                       shift and go to state 7
    statement                      shift and go to state 8
    class0                         shift and go to state 9
    function0                      shift and go to state 10
    declaration0                   shift and go to state 11
    assignment0                    shift and go to state 12
    empty                          shift and go to state 13
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21
    decl_id_def                    shift and go to state 24
>>>>>>> Stashed changes

state 5

<<<<<<< Updated upstream
    (20) declaration0 -> ID . COLON declaration1 SEMICOLON
    (26) assignment0 -> ID . EQUALS expression0 SEMICOLON
    (27) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON

    COLON           shift and go to state 14
    EQUALS          shift and go to state 15
    LSQRBRACKET     shift and go to state 16
=======
    (33) assignment0 -> ID . EQUALS expression0 SEMICOLON
    (34) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (139) object_assignment -> ID . EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (84) function_call -> ID . LPAREN function_call_params0 RPAREN
    (102) method_call0 -> ID . DOT function_call
    (27) decl_id_def -> ID .

    EQUALS          shift and go to state 30
    LSQRBRACKET     shift and go to state 31
    LPAREN          shift and go to state 32
    DOT             shift and go to state 33
    COLON           reduce using rule 27 (decl_id_def -> ID .)
>>>>>>> Stashed changes


state 6

<<<<<<< Updated upstream
    (1) routine0 -> ROUTINE ID SEMICOLON routine1 . main0
    (137) main0 -> . MAIN LBRACKET main1 RBRACKET

    MAIN            shift and go to state 18

    main0                          shift and go to state 17
=======
    (1) routine0 -> ROUTINE ID SEMICOLON global_scope routine1 . main0
    (140) main0 -> . MAIN main_scope LBRACKET main1 RBRACKET

    MAIN            shift and go to state 35

    main0                          shift and go to state 34
>>>>>>> Stashed changes

state 7

<<<<<<< Updated upstream
    (2) routine1 -> class0 . routine1
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID COLON declaration1 SEMICOLON
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (141) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 141 (empty -> .)

    class0                         shift and go to state 7
    routine1                       shift and go to state 19
    function0                      shift and go to state 8
    declaration0                   shift and go to state 9
    assignment0                    shift and go to state 10
    empty                          shift and go to state 11
=======
    (2) routine1 -> statement . routine1
    (2) routine1 -> . statement routine1
    (3) routine1 -> . class0 routine1
    (4) routine1 -> . function0 routine1
    (5) routine1 -> . declaration0 routine1
    (6) routine1 -> . assignment0 routine1
    (7) routine1 -> . empty
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (9) class0 -> . CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global
    (20) function0 -> . DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (26) declaration0 -> . decl_id_def COLON declaration1 SEMICOLON
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (145) empty -> .
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0
    (27) decl_id_def -> . ID

    CLASS           shift and go to state 22
    DEF             shift and go to state 23
    ID              shift and go to state 6
    MAIN            reduce using rule 145 (empty -> .)
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    statement                      shift and go to state 8
    routine1                       shift and go to state 36
    class0                         shift and go to state 9
    function0                      shift and go to state 10
    declaration0                   shift and go to state 11
    assignment0                    shift and go to state 12
    empty                          shift and go to state 13
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21
    decl_id_def                    shift and go to state 24
>>>>>>> Stashed changes

state 8

<<<<<<< Updated upstream
    (3) routine1 -> function0 . routine1
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID COLON declaration1 SEMICOLON
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (141) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 141 (empty -> .)

    function0                      shift and go to state 8
    routine1                       shift and go to state 20
    class0                         shift and go to state 7
    declaration0                   shift and go to state 9
    assignment0                    shift and go to state 10
    empty                          shift and go to state 11
=======
    (3) routine1 -> class0 . routine1
    (2) routine1 -> . statement routine1
    (3) routine1 -> . class0 routine1
    (4) routine1 -> . function0 routine1
    (5) routine1 -> . declaration0 routine1
    (6) routine1 -> . assignment0 routine1
    (7) routine1 -> . empty
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (9) class0 -> . CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global
    (20) function0 -> . DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (26) declaration0 -> . decl_id_def COLON declaration1 SEMICOLON
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (145) empty -> .
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0
    (27) decl_id_def -> . ID

    CLASS           shift and go to state 22
    DEF             shift and go to state 23
    ID              shift and go to state 6
    MAIN            reduce using rule 145 (empty -> .)
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    class0                         shift and go to state 9
    routine1                       shift and go to state 37
    statement                      shift and go to state 8
    function0                      shift and go to state 10
    declaration0                   shift and go to state 11
    assignment0                    shift and go to state 12
    empty                          shift and go to state 13
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21
    decl_id_def                    shift and go to state 24
>>>>>>> Stashed changes

state 9

<<<<<<< Updated upstream
    (4) routine1 -> declaration0 . routine1
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID COLON declaration1 SEMICOLON
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (141) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 141 (empty -> .)

    declaration0                   shift and go to state 9
    routine1                       shift and go to state 21
    class0                         shift and go to state 7
    function0                      shift and go to state 8
    assignment0                    shift and go to state 10
    empty                          shift and go to state 11
=======
    (4) routine1 -> function0 . routine1
    (2) routine1 -> . statement routine1
    (3) routine1 -> . class0 routine1
    (4) routine1 -> . function0 routine1
    (5) routine1 -> . declaration0 routine1
    (6) routine1 -> . assignment0 routine1
    (7) routine1 -> . empty
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (9) class0 -> . CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global
    (20) function0 -> . DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (26) declaration0 -> . decl_id_def COLON declaration1 SEMICOLON
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (145) empty -> .
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0
    (27) decl_id_def -> . ID

    CLASS           shift and go to state 22
    DEF             shift and go to state 23
    ID              shift and go to state 6
    MAIN            reduce using rule 145 (empty -> .)
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    function0                      shift and go to state 10
    routine1                       shift and go to state 38
    statement                      shift and go to state 8
    class0                         shift and go to state 9
    declaration0                   shift and go to state 11
    assignment0                    shift and go to state 12
    empty                          shift and go to state 13
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21
    decl_id_def                    shift and go to state 24
>>>>>>> Stashed changes

state 10

<<<<<<< Updated upstream
    (5) routine1 -> assignment0 . routine1
    (2) routine1 -> . class0 routine1
    (3) routine1 -> . function0 routine1
    (4) routine1 -> . declaration0 routine1
    (5) routine1 -> . assignment0 routine1
    (6) routine1 -> . empty
    (7) class0 -> . CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (20) declaration0 -> . ID COLON declaration1 SEMICOLON
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (141) empty -> .

    CLASS           shift and go to state 12
    DEF             shift and go to state 13
    ID              shift and go to state 5
    MAIN            reduce using rule 141 (empty -> .)

    assignment0                    shift and go to state 10
    routine1                       shift and go to state 22
    class0                         shift and go to state 7
    function0                      shift and go to state 8
    declaration0                   shift and go to state 9
    empty                          shift and go to state 11
=======
    (5) routine1 -> declaration0 . routine1
    (2) routine1 -> . statement routine1
    (3) routine1 -> . class0 routine1
    (4) routine1 -> . function0 routine1
    (5) routine1 -> . declaration0 routine1
    (6) routine1 -> . assignment0 routine1
    (7) routine1 -> . empty
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (9) class0 -> . CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global
    (20) function0 -> . DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (26) declaration0 -> . decl_id_def COLON declaration1 SEMICOLON
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (145) empty -> .
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0
    (27) decl_id_def -> . ID

    CLASS           shift and go to state 22
    DEF             shift and go to state 23
    ID              shift and go to state 6
    MAIN            reduce using rule 145 (empty -> .)
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    declaration0                   shift and go to state 11
    routine1                       shift and go to state 39
    statement                      shift and go to state 8
    class0                         shift and go to state 9
    function0                      shift and go to state 10
    assignment0                    shift and go to state 12
    empty                          shift and go to state 13
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21
    decl_id_def                    shift and go to state 24
>>>>>>> Stashed changes

state 11

    (6) routine1 -> assignment0 . routine1
    (130) statement -> assignment0 .
    (2) routine1 -> . statement routine1
    (3) routine1 -> . class0 routine1
    (4) routine1 -> . function0 routine1
    (5) routine1 -> . declaration0 routine1
    (6) routine1 -> . assignment0 routine1
    (7) routine1 -> . empty
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (9) class0 -> . CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global
    (20) function0 -> . DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (26) declaration0 -> . decl_id_def COLON declaration1 SEMICOLON
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (145) empty -> .
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0
    (27) decl_id_def -> . ID

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! reduce/reduce conflict for MAIN resolved using rule 130 (statement -> assignment0 .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    MAIN            reduce using rule 130 (statement -> assignment0 .)
    CLASS           shift and go to state 22
    DEF             shift and go to state 23
    ID              shift and go to state 6
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

  ! CLASS           [ reduce using rule 130 (statement -> assignment0 .) ]
  ! DEF             [ reduce using rule 130 (statement -> assignment0 .) ]
  ! ID              [ reduce using rule 130 (statement -> assignment0 .) ]
  ! IF              [ reduce using rule 130 (statement -> assignment0 .) ]
  ! WRITE           [ reduce using rule 130 (statement -> assignment0 .) ]
  ! READ            [ reduce using rule 130 (statement -> assignment0 .) ]
  ! RETURN          [ reduce using rule 130 (statement -> assignment0 .) ]
  ! WHILE           [ reduce using rule 130 (statement -> assignment0 .) ]
  ! MAIN            [ reduce using rule 145 (empty -> .) ]

    assignment0                    shift and go to state 12
    routine1                       shift and go to state 40
    statement                      shift and go to state 8
    class0                         shift and go to state 9
    function0                      shift and go to state 10
    declaration0                   shift and go to state 11
    empty                          shift and go to state 13
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21
    decl_id_def                    shift and go to state 24

state 12

<<<<<<< Updated upstream
    (7) class0 -> CLASS . ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON

    ID              shift and go to state 23
=======
    (7) routine1 -> empty .

    MAIN            reduce using rule 7 (routine1 -> empty .)
>>>>>>> Stashed changes


state 13

<<<<<<< Updated upstream
    (14) function0 -> DEF . ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    ID              shift and go to state 24
=======
    (131) statement -> object_assignment .

    CLASS           reduce using rule 131 (statement -> object_assignment .)
    DEF             reduce using rule 131 (statement -> object_assignment .)
    ID              reduce using rule 131 (statement -> object_assignment .)
    IF              reduce using rule 131 (statement -> object_assignment .)
    WRITE           reduce using rule 131 (statement -> object_assignment .)
    READ            reduce using rule 131 (statement -> object_assignment .)
    RETURN          reduce using rule 131 (statement -> object_assignment .)
    WHILE           reduce using rule 131 (statement -> object_assignment .)
    MAIN            reduce using rule 131 (statement -> object_assignment .)
    RBRACKET        reduce using rule 131 (statement -> object_assignment .)
>>>>>>> Stashed changes


state 14

    (20) declaration0 -> ID COLON . declaration1 SEMICOLON
    (21) declaration1 -> . type
    (22) declaration1 -> . complex_type
    (23) declaration1 -> . type LSQRBRACKET exp0 RSQRBRACKET declaration2
    (43) type -> . INT
    (44) type -> . FLOAT
    (45) type -> . STRING
    (46) type -> . BOOL
    (49) complex_type -> . ID

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    STRING          shift and go to state 31
    BOOL            shift and go to state 32
    ID              shift and go to state 25

<<<<<<< Updated upstream
    declaration1                   shift and go to state 26
    type                           shift and go to state 27
    complex_type                   shift and go to state 28

state 15
=======
    (132) statement -> condition0 .

    CLASS           reduce using rule 132 (statement -> condition0 .)
    DEF             reduce using rule 132 (statement -> condition0 .)
    ID              reduce using rule 132 (statement -> condition0 .)
    IF              reduce using rule 132 (statement -> condition0 .)
    WRITE           reduce using rule 132 (statement -> condition0 .)
    READ            reduce using rule 132 (statement -> condition0 .)
    RETURN          reduce using rule 132 (statement -> condition0 .)
    WHILE           reduce using rule 132 (statement -> condition0 .)
    MAIN            reduce using rule 132 (statement -> condition0 .)
    RBRACKET        reduce using rule 132 (statement -> condition0 .)
>>>>>>> Stashed changes

    (26) assignment0 -> ID EQUALS . expression0 SEMICOLON
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression0                    shift and go to state 34
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 16

<<<<<<< Updated upstream
    (27) assignment0 -> ID LSQRBRACKET . exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> ID LSQRBRACKET . exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (57) exp0 -> . term0 exp1
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 50
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 17

    (1) routine0 -> ROUTINE ID SEMICOLON routine1 main0 .

    $end            reduce using rule 1 (routine0 -> ROUTINE ID SEMICOLON routine1 main0 .)
=======
    (133) statement -> writing0 .

    CLASS           reduce using rule 133 (statement -> writing0 .)
    DEF             reduce using rule 133 (statement -> writing0 .)
    ID              reduce using rule 133 (statement -> writing0 .)
    IF              reduce using rule 133 (statement -> writing0 .)
    WRITE           reduce using rule 133 (statement -> writing0 .)
    READ            reduce using rule 133 (statement -> writing0 .)
    RETURN          reduce using rule 133 (statement -> writing0 .)
    WHILE           reduce using rule 133 (statement -> writing0 .)
    MAIN            reduce using rule 133 (statement -> writing0 .)
    RBRACKET        reduce using rule 133 (statement -> writing0 .)


state 17

    (134) statement -> reading .

    CLASS           reduce using rule 134 (statement -> reading .)
    DEF             reduce using rule 134 (statement -> reading .)
    ID              reduce using rule 134 (statement -> reading .)
    IF              reduce using rule 134 (statement -> reading .)
    WRITE           reduce using rule 134 (statement -> reading .)
    READ            reduce using rule 134 (statement -> reading .)
    RETURN          reduce using rule 134 (statement -> reading .)
    WHILE           reduce using rule 134 (statement -> reading .)
    MAIN            reduce using rule 134 (statement -> reading .)
    RBRACKET        reduce using rule 134 (statement -> reading .)


state 18

    (135) statement -> return .

    CLASS           reduce using rule 135 (statement -> return .)
    DEF             reduce using rule 135 (statement -> return .)
    ID              reduce using rule 135 (statement -> return .)
    IF              reduce using rule 135 (statement -> return .)
    WRITE           reduce using rule 135 (statement -> return .)
    READ            reduce using rule 135 (statement -> return .)
    RETURN          reduce using rule 135 (statement -> return .)
    WHILE           reduce using rule 135 (statement -> return .)
    MAIN            reduce using rule 135 (statement -> return .)
    RBRACKET        reduce using rule 135 (statement -> return .)
>>>>>>> Stashed changes


state 18

<<<<<<< Updated upstream
    (137) main0 -> MAIN . LBRACKET main1 RBRACKET

    LBRACKET        shift and go to state 52
=======
    (136) statement -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 41
>>>>>>> Stashed changes


state 19

    (137) statement -> method_call0 . SEMICOLON

    SEMICOLON       shift and go to state 42


state 20

    (138) statement -> while .

    CLASS           reduce using rule 138 (statement -> while .)
    DEF             reduce using rule 138 (statement -> while .)
    ID              reduce using rule 138 (statement -> while .)
    IF              reduce using rule 138 (statement -> while .)
    WRITE           reduce using rule 138 (statement -> while .)
    READ            reduce using rule 138 (statement -> while .)
    RETURN          reduce using rule 138 (statement -> while .)
    WHILE           reduce using rule 138 (statement -> while .)
    MAIN            reduce using rule 138 (statement -> while .)
    RBRACKET        reduce using rule 138 (statement -> while .)


state 21

    (9) class0 -> CLASS . class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global
    (13) class_id_def -> . ID

    ID              shift and go to state 44

    class_id_def                   shift and go to state 43

state 22

    (20) function0 -> DEF . id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (12) id_def -> . ID

    ID              shift and go to state 46

    id_def                         shift and go to state 45

state 23

    (7) class0 -> CLASS ID . class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON
    (8) class1 -> . COLON extension0
    (9) class1 -> . empty
    (141) empty -> .

    COLON           shift and go to state 54
    LBRACKET        reduce using rule 141 (empty -> .)

    class1                         shift and go to state 53
    empty                          shift and go to state 55

state 24

<<<<<<< Updated upstream
    (14) function0 -> DEF ID . LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    LPAREN          shift and go to state 56
=======
    (26) declaration0 -> decl_id_def . COLON declaration1 SEMICOLON

    COLON           shift and go to state 47
>>>>>>> Stashed changes


state 25

<<<<<<< Updated upstream
    (49) complex_type -> ID .

    SEMICOLON       reduce using rule 49 (complex_type -> ID .)
=======
    (113) condition0 -> IF . LPAREN expression0 RPAREN block0 condition1 SEMICOLON

    LPAREN          shift and go to state 48
>>>>>>> Stashed changes


state 26

<<<<<<< Updated upstream
    (20) declaration0 -> ID COLON declaration1 . SEMICOLON

    SEMICOLON       shift and go to state 57
=======
    (116) writing0 -> WRITE . push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (117) push_writing_op -> .

    LPAREN          reduce using rule 117 (push_writing_op -> .)
>>>>>>> Stashed changes

    push_writing_op                shift and go to state 49

state 27

<<<<<<< Updated upstream
    (21) declaration1 -> type .
    (23) declaration1 -> type . LSQRBRACKET exp0 RSQRBRACKET declaration2

    SEMICOLON       reduce using rule 21 (declaration1 -> type .)
    LSQRBRACKET     shift and go to state 58
=======
    (123) reading -> READ . ID SEMICOLON

    ID              shift and go to state 50
>>>>>>> Stashed changes


state 28

<<<<<<< Updated upstream
    (22) declaration1 -> complex_type .

    SEMICOLON       reduce using rule 22 (declaration1 -> complex_type .)


state 29

    (43) type -> INT .

    LSQRBRACKET     reduce using rule 43 (type -> INT .)
    SEMICOLON       reduce using rule 43 (type -> INT .)
    ID              reduce using rule 43 (type -> INT .)

=======
    (124) return -> RETURN . expression0 SEMICOLON
    (125) return -> RETURN . SEMICOLON
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    SEMICOLON       shift and go to state 52
    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    expression0                    shift and go to state 51
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 29

    (126) while -> WHILE . LPAREN expression0 RPAREN block0
>>>>>>> Stashed changes

    LPAREN          shift and go to state 64

<<<<<<< Updated upstream
    (44) type -> FLOAT .

    LSQRBRACKET     reduce using rule 44 (type -> FLOAT .)
    SEMICOLON       reduce using rule 44 (type -> FLOAT .)
    ID              reduce using rule 44 (type -> FLOAT .)
=======

state 30
>>>>>>> Stashed changes

    (33) assignment0 -> ID EQUALS . expression0 SEMICOLON
    (139) object_assignment -> ID EQUALS . NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    NEW             shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    expression0                    shift and go to state 65
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 31

<<<<<<< Updated upstream
    (45) type -> STRING .

    LSQRBRACKET     reduce using rule 45 (type -> STRING .)
    SEMICOLON       reduce using rule 45 (type -> STRING .)
    ID              reduce using rule 45 (type -> STRING .)


state 32

    (46) type -> BOOL .

    LSQRBRACKET     reduce using rule 46 (type -> BOOL .)
    SEMICOLON       reduce using rule 46 (type -> BOOL .)
    ID              reduce using rule 46 (type -> BOOL .)


state 33

    (100) attr_access0 -> ID . DOT ID
    (73) power0 -> ID . LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (81) const_var -> ID .
    (82) function_call -> ID . LPAREN function_call_params0 RPAREN
    (101) method_call0 -> ID . DOT function_call

    DOT             shift and go to state 59
    LSQRBRACKET     shift and go to state 60
    POWER           reduce using rule 81 (const_var -> ID .)
    SQRT            reduce using rule 81 (const_var -> ID .)
    MULTIPLY        reduce using rule 81 (const_var -> ID .)
    DIVIDE          reduce using rule 81 (const_var -> ID .)
    PLUS            reduce using rule 81 (const_var -> ID .)
    MINUS           reduce using rule 81 (const_var -> ID .)
    LTHAN           reduce using rule 81 (const_var -> ID .)
    GTHAN           reduce using rule 81 (const_var -> ID .)
    DIFFERENT       reduce using rule 81 (const_var -> ID .)
    EQUIVALENT      reduce using rule 81 (const_var -> ID .)
    SEMICOLON       reduce using rule 81 (const_var -> ID .)
    COMMA           reduce using rule 81 (const_var -> ID .)
    RPAREN          reduce using rule 81 (const_var -> ID .)
    LPAREN          shift and go to state 61


state 34

    (26) assignment0 -> ID EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 62
=======
    (34) assignment0 -> ID LSQRBRACKET . exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> ID LSQRBRACKET . exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 68
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 32

    (84) function_call -> ID LPAREN . function_call_params0 RPAREN
    (85) function_call_params0 -> . expression0 function_call_params1
    (86) function_call_params0 -> . CONST_STRING function_call_params1
    (87) function_call_params0 -> . empty function_call_params1
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (145) empty -> .
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 72
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)
    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    function_call_params0          shift and go to state 70
    expression0                    shift and go to state 71
    empty                          shift and go to state 73
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 33

    (102) method_call0 -> ID DOT . function_call
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN

    ID              shift and go to state 74

    function_call                  shift and go to state 75

state 34

    (1) routine0 -> ROUTINE ID SEMICOLON global_scope routine1 main0 .

    $end            reduce using rule 1 (routine0 -> ROUTINE ID SEMICOLON global_scope routine1 main0 .)
>>>>>>> Stashed changes


state 35

<<<<<<< Updated upstream
    (88) expression0 -> exp0 . expression1
    (91) expression1 -> . empty
    (92) expression1 -> . expression2
    (141) empty -> .
    (93) expression2 -> . LTHAN expression3
    (94) expression2 -> . GTHAN expression3
    (95) expression2 -> . DIFFERENT expression3
    (96) expression2 -> . EQUIVALENT expression3

    SEMICOLON       reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    LTHAN           shift and go to state 66
    GTHAN           shift and go to state 67
    DIFFERENT       shift and go to state 68
    EQUIVALENT      shift and go to state 69

    expression1                    shift and go to state 63
    empty                          shift and go to state 64
    expression2                    shift and go to state 65

state 36

    (89) expression0 -> CONST_BOOL . expression1
    (91) expression1 -> . empty
    (92) expression1 -> . expression2
    (141) empty -> .
    (93) expression2 -> . LTHAN expression3
    (94) expression2 -> . GTHAN expression3
    (95) expression2 -> . DIFFERENT expression3
    (96) expression2 -> . EQUIVALENT expression3

    SEMICOLON       reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    LTHAN           shift and go to state 66
    GTHAN           shift and go to state 67
    DIFFERENT       shift and go to state 68
    EQUIVALENT      shift and go to state 69

    expression1                    shift and go to state 70
    empty                          shift and go to state 64
    expression2                    shift and go to state 65

state 37

    (90) expression0 -> attr_access0 . expression1
    (72) power0 -> attr_access0 . power2
    (91) expression1 -> . empty
    (92) expression1 -> . expression2
    (76) power2 -> . POWER power0
    (77) power2 -> . SQRT power0
    (78) power2 -> . empty
    (141) empty -> .
    (93) expression2 -> . LTHAN expression3
    (94) expression2 -> . GTHAN expression3
    (95) expression2 -> . DIFFERENT expression3
    (96) expression2 -> . EQUIVALENT expression3
=======
    (140) main0 -> MAIN . main_scope LBRACKET main1 RBRACKET
    (144) main_scope -> .

    LBRACKET        reduce using rule 144 (main_scope -> .)

    main_scope                     shift and go to state 76

state 36

    (2) routine1 -> statement routine1 .

    MAIN            reduce using rule 2 (routine1 -> statement routine1 .)


state 37

    (3) routine1 -> class0 routine1 .

    MAIN            reduce using rule 3 (routine1 -> class0 routine1 .)
>>>>>>> Stashed changes

  ! shift/reduce conflict for LTHAN resolved as shift
  ! shift/reduce conflict for GTHAN resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for EQUIVALENT resolved as shift
    POWER           shift and go to state 74
    SQRT            shift and go to state 75
    SEMICOLON       reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    LTHAN           shift and go to state 66
    GTHAN           shift and go to state 67
    DIFFERENT       shift and go to state 68
    EQUIVALENT      shift and go to state 69

  ! LTHAN           [ reduce using rule 141 (empty -> .) ]
  ! GTHAN           [ reduce using rule 141 (empty -> .) ]
  ! DIFFERENT       [ reduce using rule 141 (empty -> .) ]
  ! EQUIVALENT      [ reduce using rule 141 (empty -> .) ]

    expression1                    shift and go to state 71
    power2                         shift and go to state 72
    empty                          shift and go to state 73
    expression2                    shift and go to state 65

state 38

<<<<<<< Updated upstream
    (57) exp0 -> term0 . exp1
    (58) exp1 -> . PLUS exp0
    (59) exp1 -> . MINUS exp0
    (60) exp1 -> . empty
    (141) empty -> .

    PLUS            shift and go to state 77
    MINUS           shift and go to state 78
    LTHAN           reduce using rule 141 (empty -> .)
    GTHAN           reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    EQUIVALENT      reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    RSQRBRACKET     reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)

    exp1                           shift and go to state 76
    empty                          shift and go to state 79

state 39

    (61) term0 -> factor . term1
    (62) term1 -> . MULTIPLY term0
    (63) term1 -> . DIVIDE term0
    (64) term1 -> . empty
    (141) empty -> .

    MULTIPLY        shift and go to state 81
    DIVIDE          shift and go to state 82
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    LTHAN           reduce using rule 141 (empty -> .)
    GTHAN           reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    EQUIVALENT      reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    RSQRBRACKET     reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)

    term1                          shift and go to state 80
    empty                          shift and go to state 83

state 40

    (65) factor -> PLUS . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    power0                         shift and go to state 84
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 41

    (67) factor -> power0 .
=======
    (4) routine1 -> function0 routine1 .

    MAIN            reduce using rule 4 (routine1 -> function0 routine1 .)


state 39

    (5) routine1 -> declaration0 routine1 .

    MAIN            reduce using rule 5 (routine1 -> declaration0 routine1 .)


state 40

    (6) routine1 -> assignment0 routine1 .

    MAIN            reduce using rule 6 (routine1 -> assignment0 routine1 .)


state 41

    (136) statement -> function_call SEMICOLON .

    CLASS           reduce using rule 136 (statement -> function_call SEMICOLON .)
    DEF             reduce using rule 136 (statement -> function_call SEMICOLON .)
    ID              reduce using rule 136 (statement -> function_call SEMICOLON .)
    IF              reduce using rule 136 (statement -> function_call SEMICOLON .)
    WRITE           reduce using rule 136 (statement -> function_call SEMICOLON .)
    READ            reduce using rule 136 (statement -> function_call SEMICOLON .)
    RETURN          reduce using rule 136 (statement -> function_call SEMICOLON .)
    WHILE           reduce using rule 136 (statement -> function_call SEMICOLON .)
    MAIN            reduce using rule 136 (statement -> function_call SEMICOLON .)
    RBRACKET        reduce using rule 136 (statement -> function_call SEMICOLON .)

>>>>>>> Stashed changes

    MULTIPLY        reduce using rule 67 (factor -> power0 .)
    DIVIDE          reduce using rule 67 (factor -> power0 .)
    PLUS            reduce using rule 67 (factor -> power0 .)
    MINUS           reduce using rule 67 (factor -> power0 .)
    LTHAN           reduce using rule 67 (factor -> power0 .)
    GTHAN           reduce using rule 67 (factor -> power0 .)
    DIFFERENT       reduce using rule 67 (factor -> power0 .)
    EQUIVALENT      reduce using rule 67 (factor -> power0 .)
    SEMICOLON       reduce using rule 67 (factor -> power0 .)
    RSQRBRACKET     reduce using rule 67 (factor -> power0 .)
    RPAREN          reduce using rule 67 (factor -> power0 .)
    COMMA           reduce using rule 67 (factor -> power0 .)

<<<<<<< Updated upstream
=======
    (137) statement -> method_call0 SEMICOLON .

    CLASS           reduce using rule 137 (statement -> method_call0 SEMICOLON .)
    DEF             reduce using rule 137 (statement -> method_call0 SEMICOLON .)
    ID              reduce using rule 137 (statement -> method_call0 SEMICOLON .)
    IF              reduce using rule 137 (statement -> method_call0 SEMICOLON .)
    WRITE           reduce using rule 137 (statement -> method_call0 SEMICOLON .)
    READ            reduce using rule 137 (statement -> method_call0 SEMICOLON .)
    RETURN          reduce using rule 137 (statement -> method_call0 SEMICOLON .)
    WHILE           reduce using rule 137 (statement -> method_call0 SEMICOLON .)
    MAIN            reduce using rule 137 (statement -> method_call0 SEMICOLON .)
    RBRACKET        reduce using rule 137 (statement -> method_call0 SEMICOLON .)

>>>>>>> Stashed changes

state 42

<<<<<<< Updated upstream
    (66) factor -> MINUS . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    power0                         shift and go to state 85
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 43

    (68) power0 -> LPAREN . exp0 RPAREN power2
    (57) exp0 -> . term0 exp1
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 86
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 44

    (69) power0 -> const_var . power2
    (76) power2 -> . POWER power0
    (77) power2 -> . SQRT power0
    (78) power2 -> . empty
    (141) empty -> .

    POWER           shift and go to state 74
    SQRT            shift and go to state 75
    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    LTHAN           reduce using rule 141 (empty -> .)
    GTHAN           reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    EQUIVALENT      reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    RSQRBRACKET     reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)

    power2                         shift and go to state 87
    empty                          shift and go to state 88

state 45

    (70) power0 -> function_call . power2
    (76) power2 -> . POWER power0
    (77) power2 -> . SQRT power0
    (78) power2 -> . empty
    (141) empty -> .

    POWER           shift and go to state 74
    SQRT            shift and go to state 75
    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    LTHAN           reduce using rule 141 (empty -> .)
    GTHAN           reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    EQUIVALENT      reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    RSQRBRACKET     reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)
=======
    (9) class0 -> CLASS class_id_def . class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global
    (14) class1 -> . COLON ID
    (15) class1 -> . empty
    (145) empty -> .

    COLON           shift and go to state 78
    LBRACKET        reduce using rule 145 (empty -> .)

    class1                         shift and go to state 77
    empty                          shift and go to state 79

state 44

    (13) class_id_def -> ID .

    COLON           reduce using rule 13 (class_id_def -> ID .)
    LBRACKET        reduce using rule 13 (class_id_def -> ID .)


state 45

    (20) function0 -> DEF id_def . LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope

    LPAREN          shift and go to state 80
>>>>>>> Stashed changes

    power2                         shift and go to state 89
    empty                          shift and go to state 88

state 46

<<<<<<< Updated upstream
    (71) power0 -> method_call0 . power2
    (76) power2 -> . POWER power0
    (77) power2 -> . SQRT power0
    (78) power2 -> . empty
    (141) empty -> .

    POWER           shift and go to state 74
    SQRT            shift and go to state 75
    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    LTHAN           reduce using rule 141 (empty -> .)
    GTHAN           reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    EQUIVALENT      reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    RSQRBRACKET     reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)

    power2                         shift and go to state 90
    empty                          shift and go to state 88

state 47
=======
    (12) id_def -> ID .

    LPAREN          reduce using rule 12 (id_def -> ID .)
>>>>>>> Stashed changes

    (79) const_var -> CONST_INT .

    POWER           reduce using rule 79 (const_var -> CONST_INT .)
    SQRT            reduce using rule 79 (const_var -> CONST_INT .)
    MULTIPLY        reduce using rule 79 (const_var -> CONST_INT .)
    DIVIDE          reduce using rule 79 (const_var -> CONST_INT .)
    PLUS            reduce using rule 79 (const_var -> CONST_INT .)
    MINUS           reduce using rule 79 (const_var -> CONST_INT .)
    LTHAN           reduce using rule 79 (const_var -> CONST_INT .)
    GTHAN           reduce using rule 79 (const_var -> CONST_INT .)
    DIFFERENT       reduce using rule 79 (const_var -> CONST_INT .)
    EQUIVALENT      reduce using rule 79 (const_var -> CONST_INT .)
    SEMICOLON       reduce using rule 79 (const_var -> CONST_INT .)
    RSQRBRACKET     reduce using rule 79 (const_var -> CONST_INT .)
    RPAREN          reduce using rule 79 (const_var -> CONST_INT .)
    COMMA           reduce using rule 79 (const_var -> CONST_INT .)

<<<<<<< Updated upstream

state 48

    (80) const_var -> CONST_FLOAT .

    POWER           reduce using rule 80 (const_var -> CONST_FLOAT .)
    SQRT            reduce using rule 80 (const_var -> CONST_FLOAT .)
    MULTIPLY        reduce using rule 80 (const_var -> CONST_FLOAT .)
    DIVIDE          reduce using rule 80 (const_var -> CONST_FLOAT .)
    PLUS            reduce using rule 80 (const_var -> CONST_FLOAT .)
    MINUS           reduce using rule 80 (const_var -> CONST_FLOAT .)
    LTHAN           reduce using rule 80 (const_var -> CONST_FLOAT .)
    GTHAN           reduce using rule 80 (const_var -> CONST_FLOAT .)
    DIFFERENT       reduce using rule 80 (const_var -> CONST_FLOAT .)
    EQUIVALENT      reduce using rule 80 (const_var -> CONST_FLOAT .)
    SEMICOLON       reduce using rule 80 (const_var -> CONST_FLOAT .)
    RSQRBRACKET     reduce using rule 80 (const_var -> CONST_FLOAT .)
    RPAREN          reduce using rule 80 (const_var -> CONST_FLOAT .)
    COMMA           reduce using rule 80 (const_var -> CONST_FLOAT .)


state 49

    (73) power0 -> ID . LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (81) const_var -> ID .
    (82) function_call -> ID . LPAREN function_call_params0 RPAREN
    (101) method_call0 -> ID . DOT function_call
    (100) attr_access0 -> ID . DOT ID

    LSQRBRACKET     shift and go to state 60
    POWER           reduce using rule 81 (const_var -> ID .)
    SQRT            reduce using rule 81 (const_var -> ID .)
    MULTIPLY        reduce using rule 81 (const_var -> ID .)
    DIVIDE          reduce using rule 81 (const_var -> ID .)
    PLUS            reduce using rule 81 (const_var -> ID .)
    MINUS           reduce using rule 81 (const_var -> ID .)
    RSQRBRACKET     reduce using rule 81 (const_var -> ID .)
    LTHAN           reduce using rule 81 (const_var -> ID .)
    GTHAN           reduce using rule 81 (const_var -> ID .)
    DIFFERENT       reduce using rule 81 (const_var -> ID .)
    EQUIVALENT      reduce using rule 81 (const_var -> ID .)
    SEMICOLON       reduce using rule 81 (const_var -> ID .)
    RPAREN          reduce using rule 81 (const_var -> ID .)
    COMMA           reduce using rule 81 (const_var -> ID .)
    LPAREN          shift and go to state 61
    DOT             shift and go to state 91
=======
    (26) declaration0 -> decl_id_def COLON . declaration1 SEMICOLON
    (28) declaration1 -> . type
    (29) declaration1 -> . complex_type
    (30) declaration1 -> . type LSQRBRACKET exp0 RSQRBRACKET declaration2
    (49) type -> . INT
    (50) type -> . FLOAT
    (51) type -> . STRING
    (52) type -> . BOOL
    (55) complex_type -> . ID

    INT             shift and go to state 84
    FLOAT           shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    ID              shift and go to state 88

    declaration1                   shift and go to state 81
    type                           shift and go to state 82
    complex_type                   shift and go to state 83

state 48

    (113) condition0 -> IF LPAREN . expression0 RPAREN block0 condition1 SEMICOLON
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    expression0                    shift and go to state 89
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 49

    (116) writing0 -> WRITE push_writing_op . LPAREN writing1 RPAREN SEMICOLON

    LPAREN          shift and go to state 90
>>>>>>> Stashed changes


state 50

<<<<<<< Updated upstream
    (27) assignment0 -> ID LSQRBRACKET exp0 . RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> ID LSQRBRACKET exp0 . RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON

    RSQRBRACKET     shift and go to state 92
=======
    (123) reading -> READ ID . SEMICOLON

    SEMICOLON       shift and go to state 91
>>>>>>> Stashed changes


state 51

<<<<<<< Updated upstream
    (72) power0 -> attr_access0 . power2
    (76) power2 -> . POWER power0
    (77) power2 -> . SQRT power0
    (78) power2 -> . empty
    (141) empty -> .

    POWER           shift and go to state 74
    SQRT            shift and go to state 75
    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    LTHAN           reduce using rule 141 (empty -> .)
    GTHAN           reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    EQUIVALENT      reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    RSQRBRACKET     reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)

    power2                         shift and go to state 72
    empty                          shift and go to state 88

state 52

    (137) main0 -> MAIN LBRACKET . main1 RBRACKET
    (138) main1 -> . declaration0 main1
    (139) main1 -> . statement main1
    (140) main1 -> . empty
    (20) declaration0 -> . ID COLON declaration1 SEMICOLON
    (127) statement -> . assignment0
    (128) statement -> . object_assignment
    (129) statement -> . condition0
    (130) statement -> . writing0
    (131) statement -> . reading
    (132) statement -> . return
    (133) statement -> . function_call SEMICOLON
    (134) statement -> . method_call0 SEMICOLON
    (135) statement -> . while
    (141) empty -> .
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (136) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (112) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (115) writing0 -> . WRITE LPAREN writing1 RPAREN SEMICOLON
    (120) reading -> . READ ID SEMICOLON
    (121) return -> . RETURN expression0 SEMICOLON
    (122) return -> . RETURN SEMICOLON
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (123) while -> . WHILE LPAREN expression0 RPAREN block0

    ID              shift and go to state 97
    RBRACKET        reduce using rule 141 (empty -> .)
    IF              shift and go to state 107
    WRITE           shift and go to state 108
    READ            shift and go to state 109
    RETURN          shift and go to state 110
    WHILE           shift and go to state 111

    main1                          shift and go to state 93
    declaration0                   shift and go to state 94
    statement                      shift and go to state 95
    empty                          shift and go to state 96
    assignment0                    shift and go to state 98
    object_assignment              shift and go to state 99
    condition0                     shift and go to state 100
    writing0                       shift and go to state 101
    reading                        shift and go to state 102
    return                         shift and go to state 103
    function_call                  shift and go to state 104
    method_call0                   shift and go to state 105
    while                          shift and go to state 106

state 53

    (7) class0 -> CLASS ID class1 . LBRACKET class2 constructor class3 RBRACKET SEMICOLON

    LBRACKET        shift and go to state 112
=======
    (124) return -> RETURN expression0 . SEMICOLON

    SEMICOLON       shift and go to state 92


state 52

    (125) return -> RETURN SEMICOLON .

    CLASS           reduce using rule 125 (return -> RETURN SEMICOLON .)
    DEF             reduce using rule 125 (return -> RETURN SEMICOLON .)
    ID              reduce using rule 125 (return -> RETURN SEMICOLON .)
    IF              reduce using rule 125 (return -> RETURN SEMICOLON .)
    WRITE           reduce using rule 125 (return -> RETURN SEMICOLON .)
    READ            reduce using rule 125 (return -> RETURN SEMICOLON .)
    RETURN          reduce using rule 125 (return -> RETURN SEMICOLON .)
    WHILE           reduce using rule 125 (return -> RETURN SEMICOLON .)
    MAIN            reduce using rule 125 (return -> RETURN SEMICOLON .)
    RBRACKET        reduce using rule 125 (return -> RETURN SEMICOLON .)


state 53

    (90) expression0 -> exp0 . expression1
    (92) expression1 -> . LTHAN push_rel_op expression3
    (93) expression1 -> . GTHAN push_rel_op expression3
    (94) expression1 -> . DIFFERENT push_rel_op expression3
    (95) expression1 -> . EQUIVALENT push_rel_op expression3
    (96) expression1 -> . empty
    (145) empty -> .

    LTHAN           shift and go to state 94
    GTHAN           shift and go to state 95
    DIFFERENT       shift and go to state 96
    EQUIVALENT      shift and go to state 97
    SEMICOLON       reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    expression1                    shift and go to state 93
    empty                          shift and go to state 98

state 54

<<<<<<< Updated upstream
    (8) class1 -> COLON . extension0
    (30) extension0 -> . ID

    ID              shift and go to state 114

    extension0                     shift and go to state 113

state 55

    (9) class1 -> empty .

    LBRACKET        reduce using rule 9 (class1 -> empty .)
=======
    (91) expression0 -> attr_access0 . expression1
    (72) power0 -> attr_access0 . check_pow_rad_operator power2
    (92) expression1 -> . LTHAN push_rel_op expression3
    (93) expression1 -> . GTHAN push_rel_op expression3
    (94) expression1 -> . DIFFERENT push_rel_op expression3
    (95) expression1 -> . EQUIVALENT push_rel_op expression3
    (96) expression1 -> . empty
    (80) check_pow_rad_operator -> .
    (145) empty -> .

  ! shift/reduce conflict for LTHAN resolved as shift
  ! shift/reduce conflict for GTHAN resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for EQUIVALENT resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 80 (check_pow_rad_operator -> .)
  ! reduce/reduce conflict for COMMA resolved using rule 80 (check_pow_rad_operator -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 80 (check_pow_rad_operator -> .)
    LTHAN           shift and go to state 94
    GTHAN           shift and go to state 95
    DIFFERENT       shift and go to state 96
    EQUIVALENT      shift and go to state 97
    POWER           reduce using rule 80 (check_pow_rad_operator -> .)
    SQRT            reduce using rule 80 (check_pow_rad_operator -> .)
    MULTIPLY        reduce using rule 80 (check_pow_rad_operator -> .)
    DIVIDE          reduce using rule 80 (check_pow_rad_operator -> .)
    PLUS            reduce using rule 80 (check_pow_rad_operator -> .)
    MINUS           reduce using rule 80 (check_pow_rad_operator -> .)
    SEMICOLON       reduce using rule 80 (check_pow_rad_operator -> .)
    COMMA           reduce using rule 80 (check_pow_rad_operator -> .)
    RPAREN          reduce using rule 80 (check_pow_rad_operator -> .)

  ! LTHAN           [ reduce using rule 80 (check_pow_rad_operator -> .) ]
  ! GTHAN           [ reduce using rule 80 (check_pow_rad_operator -> .) ]
  ! DIFFERENT       [ reduce using rule 80 (check_pow_rad_operator -> .) ]
  ! EQUIVALENT      [ reduce using rule 80 (check_pow_rad_operator -> .) ]
  ! SEMICOLON       [ reduce using rule 145 (empty -> .) ]
  ! COMMA           [ reduce using rule 145 (empty -> .) ]
  ! RPAREN          [ reduce using rule 145 (empty -> .) ]

    expression1                    shift and go to state 99
    check_pow_rad_operator         shift and go to state 100
    empty                          shift and go to state 98

state 55

    (56) exp0 -> term0 . check_last_plus_minus_operator exp1
    (61) check_last_plus_minus_operator -> .

    PLUS            reduce using rule 61 (check_last_plus_minus_operator -> .)
    MINUS           reduce using rule 61 (check_last_plus_minus_operator -> .)
    LTHAN           reduce using rule 61 (check_last_plus_minus_operator -> .)
    GTHAN           reduce using rule 61 (check_last_plus_minus_operator -> .)
    DIFFERENT       reduce using rule 61 (check_last_plus_minus_operator -> .)
    EQUIVALENT      reduce using rule 61 (check_last_plus_minus_operator -> .)
    SEMICOLON       reduce using rule 61 (check_last_plus_minus_operator -> .)
    RSQRBRACKET     reduce using rule 61 (check_last_plus_minus_operator -> .)
    COMMA           reduce using rule 61 (check_last_plus_minus_operator -> .)
    RPAREN          reduce using rule 61 (check_last_plus_minus_operator -> .)
>>>>>>> Stashed changes

    check_last_plus_minus_operator shift and go to state 101

state 56

<<<<<<< Updated upstream
    (14) function0 -> DEF ID LPAREN . params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (36) params0 -> . type ID params1
    (37) params0 -> . empty
    (43) type -> . INT
    (44) type -> . FLOAT
    (45) type -> . STRING
    (46) type -> . BOOL
    (141) empty -> .

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    STRING          shift and go to state 31
    BOOL            shift and go to state 32
    RPAREN          reduce using rule 141 (empty -> .)

    params0                        shift and go to state 115
    type                           shift and go to state 116
    empty                          shift and go to state 117

state 57

    (20) declaration0 -> ID COLON declaration1 SEMICOLON .

    CLASS           reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
    DEF             reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
    ID              reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
    MAIN            reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
    IF              reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
    WRITE           reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
    READ            reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
    RETURN          reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
    WHILE           reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
    RBRACKET        reduce using rule 20 (declaration0 -> ID COLON declaration1 SEMICOLON .)
=======
    (101) attr_access0 -> ID . DOT ID
    (73) power0 -> ID . LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (83) const_var -> ID .
    (84) function_call -> ID . LPAREN function_call_params0 RPAREN
    (102) method_call0 -> ID . DOT function_call

    DOT             shift and go to state 102
    LSQRBRACKET     shift and go to state 103
    POWER           reduce using rule 83 (const_var -> ID .)
    SQRT            reduce using rule 83 (const_var -> ID .)
    MULTIPLY        reduce using rule 83 (const_var -> ID .)
    DIVIDE          reduce using rule 83 (const_var -> ID .)
    PLUS            reduce using rule 83 (const_var -> ID .)
    MINUS           reduce using rule 83 (const_var -> ID .)
    LTHAN           reduce using rule 83 (const_var -> ID .)
    GTHAN           reduce using rule 83 (const_var -> ID .)
    DIFFERENT       reduce using rule 83 (const_var -> ID .)
    EQUIVALENT      reduce using rule 83 (const_var -> ID .)
    SEMICOLON       reduce using rule 83 (const_var -> ID .)
    COMMA           reduce using rule 83 (const_var -> ID .)
    RPAREN          reduce using rule 83 (const_var -> ID .)
    LPAREN          shift and go to state 32


state 57

    (62) term0 -> power0 . check_last_times_division_operator term1
    (67) check_last_times_division_operator -> .

    MULTIPLY        reduce using rule 67 (check_last_times_division_operator -> .)
    DIVIDE          reduce using rule 67 (check_last_times_division_operator -> .)
    PLUS            reduce using rule 67 (check_last_times_division_operator -> .)
    MINUS           reduce using rule 67 (check_last_times_division_operator -> .)
    LTHAN           reduce using rule 67 (check_last_times_division_operator -> .)
    GTHAN           reduce using rule 67 (check_last_times_division_operator -> .)
    DIFFERENT       reduce using rule 67 (check_last_times_division_operator -> .)
    EQUIVALENT      reduce using rule 67 (check_last_times_division_operator -> .)
    SEMICOLON       reduce using rule 67 (check_last_times_division_operator -> .)
    RSQRBRACKET     reduce using rule 67 (check_last_times_division_operator -> .)
    COMMA           reduce using rule 67 (check_last_times_division_operator -> .)
    RPAREN          reduce using rule 67 (check_last_times_division_operator -> .)
>>>>>>> Stashed changes

    check_last_times_division_operator shift and go to state 104

state 58

<<<<<<< Updated upstream
    (23) declaration1 -> type LSQRBRACKET . exp0 RSQRBRACKET declaration2
    (57) exp0 -> . term0 exp1
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 118
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 59

    (100) attr_access0 -> ID DOT . ID
    (101) method_call0 -> ID DOT . function_call
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN

    ID              shift and go to state 119

    function_call                  shift and go to state 120

state 60

    (73) power0 -> ID LSQRBRACKET . exp0 RSQRBRACKET power1 power2
    (57) exp0 -> . term0 exp1
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 121
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 61

    (82) function_call -> ID LPAREN . function_call_params0 RPAREN
    (83) function_call_params0 -> . expression0 function_call_params1
    (84) function_call_params0 -> . CONST_STRING function_call_params1
    (85) function_call_params0 -> . empty function_call_params1
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (141) empty -> .
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 124
    CONST_BOOL      shift and go to state 36
    COMMA           reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    function_call_params0          shift and go to state 122
    expression0                    shift and go to state 123
    empty                          shift and go to state 125
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 62

    (26) assignment0 -> ID EQUALS expression0 SEMICOLON .
=======
    (68) power0 -> LPAREN . exp0 RPAREN check_pow_rad_operator power2
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 105
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 59

    (69) power0 -> const_var . check_pow_rad_operator power2
    (80) check_pow_rad_operator -> .

    POWER           reduce using rule 80 (check_pow_rad_operator -> .)
    SQRT            reduce using rule 80 (check_pow_rad_operator -> .)
    MULTIPLY        reduce using rule 80 (check_pow_rad_operator -> .)
    DIVIDE          reduce using rule 80 (check_pow_rad_operator -> .)
    PLUS            reduce using rule 80 (check_pow_rad_operator -> .)
    MINUS           reduce using rule 80 (check_pow_rad_operator -> .)
    LTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    GTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    DIFFERENT       reduce using rule 80 (check_pow_rad_operator -> .)
    EQUIVALENT      reduce using rule 80 (check_pow_rad_operator -> .)
    SEMICOLON       reduce using rule 80 (check_pow_rad_operator -> .)
    RSQRBRACKET     reduce using rule 80 (check_pow_rad_operator -> .)
    COMMA           reduce using rule 80 (check_pow_rad_operator -> .)
    RPAREN          reduce using rule 80 (check_pow_rad_operator -> .)

    check_pow_rad_operator         shift and go to state 106

state 60

    (70) power0 -> function_call . check_pow_rad_operator power2
    (80) check_pow_rad_operator -> .

    POWER           reduce using rule 80 (check_pow_rad_operator -> .)
    SQRT            reduce using rule 80 (check_pow_rad_operator -> .)
    MULTIPLY        reduce using rule 80 (check_pow_rad_operator -> .)
    DIVIDE          reduce using rule 80 (check_pow_rad_operator -> .)
    PLUS            reduce using rule 80 (check_pow_rad_operator -> .)
    MINUS           reduce using rule 80 (check_pow_rad_operator -> .)
    LTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    GTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    DIFFERENT       reduce using rule 80 (check_pow_rad_operator -> .)
    EQUIVALENT      reduce using rule 80 (check_pow_rad_operator -> .)
    SEMICOLON       reduce using rule 80 (check_pow_rad_operator -> .)
    RSQRBRACKET     reduce using rule 80 (check_pow_rad_operator -> .)
    COMMA           reduce using rule 80 (check_pow_rad_operator -> .)
    RPAREN          reduce using rule 80 (check_pow_rad_operator -> .)

    check_pow_rad_operator         shift and go to state 107

state 61

    (71) power0 -> method_call0 . check_pow_rad_operator power2
    (80) check_pow_rad_operator -> .

    POWER           reduce using rule 80 (check_pow_rad_operator -> .)
    SQRT            reduce using rule 80 (check_pow_rad_operator -> .)
    MULTIPLY        reduce using rule 80 (check_pow_rad_operator -> .)
    DIVIDE          reduce using rule 80 (check_pow_rad_operator -> .)
    PLUS            reduce using rule 80 (check_pow_rad_operator -> .)
    MINUS           reduce using rule 80 (check_pow_rad_operator -> .)
    LTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    GTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    DIFFERENT       reduce using rule 80 (check_pow_rad_operator -> .)
    EQUIVALENT      reduce using rule 80 (check_pow_rad_operator -> .)
    SEMICOLON       reduce using rule 80 (check_pow_rad_operator -> .)
    RSQRBRACKET     reduce using rule 80 (check_pow_rad_operator -> .)
    COMMA           reduce using rule 80 (check_pow_rad_operator -> .)
    RPAREN          reduce using rule 80 (check_pow_rad_operator -> .)

    check_pow_rad_operator         shift and go to state 108
>>>>>>> Stashed changes

    CLASS           reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    DEF             reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    MAIN            reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 26 (assignment0 -> ID EQUALS expression0 SEMICOLON .)

<<<<<<< Updated upstream

state 63

    (88) expression0 -> exp0 expression1 .

    SEMICOLON       reduce using rule 88 (expression0 -> exp0 expression1 .)
    COMMA           reduce using rule 88 (expression0 -> exp0 expression1 .)
    RPAREN          reduce using rule 88 (expression0 -> exp0 expression1 .)

=======
    (81) const_var -> CONST_INT .

    POWER           reduce using rule 81 (const_var -> CONST_INT .)
    SQRT            reduce using rule 81 (const_var -> CONST_INT .)
    MULTIPLY        reduce using rule 81 (const_var -> CONST_INT .)
    DIVIDE          reduce using rule 81 (const_var -> CONST_INT .)
    PLUS            reduce using rule 81 (const_var -> CONST_INT .)
    MINUS           reduce using rule 81 (const_var -> CONST_INT .)
    LTHAN           reduce using rule 81 (const_var -> CONST_INT .)
    GTHAN           reduce using rule 81 (const_var -> CONST_INT .)
    DIFFERENT       reduce using rule 81 (const_var -> CONST_INT .)
    EQUIVALENT      reduce using rule 81 (const_var -> CONST_INT .)
    SEMICOLON       reduce using rule 81 (const_var -> CONST_INT .)
    RSQRBRACKET     reduce using rule 81 (const_var -> CONST_INT .)
    COMMA           reduce using rule 81 (const_var -> CONST_INT .)
    RPAREN          reduce using rule 81 (const_var -> CONST_INT .)


state 63

    (82) const_var -> CONST_FLOAT .
>>>>>>> Stashed changes

    POWER           reduce using rule 82 (const_var -> CONST_FLOAT .)
    SQRT            reduce using rule 82 (const_var -> CONST_FLOAT .)
    MULTIPLY        reduce using rule 82 (const_var -> CONST_FLOAT .)
    DIVIDE          reduce using rule 82 (const_var -> CONST_FLOAT .)
    PLUS            reduce using rule 82 (const_var -> CONST_FLOAT .)
    MINUS           reduce using rule 82 (const_var -> CONST_FLOAT .)
    LTHAN           reduce using rule 82 (const_var -> CONST_FLOAT .)
    GTHAN           reduce using rule 82 (const_var -> CONST_FLOAT .)
    DIFFERENT       reduce using rule 82 (const_var -> CONST_FLOAT .)
    EQUIVALENT      reduce using rule 82 (const_var -> CONST_FLOAT .)
    SEMICOLON       reduce using rule 82 (const_var -> CONST_FLOAT .)
    RSQRBRACKET     reduce using rule 82 (const_var -> CONST_FLOAT .)
    COMMA           reduce using rule 82 (const_var -> CONST_FLOAT .)
    RPAREN          reduce using rule 82 (const_var -> CONST_FLOAT .)

<<<<<<< Updated upstream
    (91) expression1 -> empty .

    SEMICOLON       reduce using rule 91 (expression1 -> empty .)
    COMMA           reduce using rule 91 (expression1 -> empty .)
    RPAREN          reduce using rule 91 (expression1 -> empty .)
=======

state 64
>>>>>>> Stashed changes

    (126) while -> WHILE LPAREN . expression0 RPAREN block0
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    expression0                    shift and go to state 109
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 65

<<<<<<< Updated upstream
    (92) expression1 -> expression2 .

    SEMICOLON       reduce using rule 92 (expression1 -> expression2 .)
    COMMA           reduce using rule 92 (expression1 -> expression2 .)
    RPAREN          reduce using rule 92 (expression1 -> expression2 .)
=======
    (33) assignment0 -> ID EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 110
>>>>>>> Stashed changes


state 66

<<<<<<< Updated upstream
    (93) expression2 -> LTHAN . expression3
    (97) expression3 -> . exp0
    (98) expression3 -> . CONST_BOOL
    (99) expression3 -> . attr_access0
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 128
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression3                    shift and go to state 126
    exp0                           shift and go to state 127
    attr_access0                   shift and go to state 129
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 67

    (94) expression2 -> GTHAN . expression3
    (97) expression3 -> . exp0
    (98) expression3 -> . CONST_BOOL
    (99) expression3 -> . attr_access0
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 128
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression3                    shift and go to state 130
    exp0                           shift and go to state 127
    attr_access0                   shift and go to state 129
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 68

    (95) expression2 -> DIFFERENT . expression3
    (97) expression3 -> . exp0
    (98) expression3 -> . CONST_BOOL
    (99) expression3 -> . attr_access0
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 128
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression3                    shift and go to state 131
    exp0                           shift and go to state 127
    attr_access0                   shift and go to state 129
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 69

    (96) expression2 -> EQUIVALENT . expression3
    (97) expression3 -> . exp0
    (98) expression3 -> . CONST_BOOL
    (99) expression3 -> . attr_access0
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 128
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression3                    shift and go to state 132
    exp0                           shift and go to state 127
    attr_access0                   shift and go to state 129
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 70

    (89) expression0 -> CONST_BOOL expression1 .

    SEMICOLON       reduce using rule 89 (expression0 -> CONST_BOOL expression1 .)
    COMMA           reduce using rule 89 (expression0 -> CONST_BOOL expression1 .)
    RPAREN          reduce using rule 89 (expression0 -> CONST_BOOL expression1 .)
=======
    (139) object_assignment -> ID EQUALS NEW . ID LPAREN function_call_params0 RPAREN SEMICOLON

    ID              shift and go to state 111


state 67

    (73) power0 -> ID . LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (83) const_var -> ID .
    (84) function_call -> ID . LPAREN function_call_params0 RPAREN
    (102) method_call0 -> ID . DOT function_call
    (101) attr_access0 -> ID . DOT ID

    LSQRBRACKET     shift and go to state 103
    POWER           reduce using rule 83 (const_var -> ID .)
    SQRT            reduce using rule 83 (const_var -> ID .)
    MULTIPLY        reduce using rule 83 (const_var -> ID .)
    DIVIDE          reduce using rule 83 (const_var -> ID .)
    PLUS            reduce using rule 83 (const_var -> ID .)
    MINUS           reduce using rule 83 (const_var -> ID .)
    RSQRBRACKET     reduce using rule 83 (const_var -> ID .)
    RPAREN          reduce using rule 83 (const_var -> ID .)
    LTHAN           reduce using rule 83 (const_var -> ID .)
    GTHAN           reduce using rule 83 (const_var -> ID .)
    DIFFERENT       reduce using rule 83 (const_var -> ID .)
    EQUIVALENT      reduce using rule 83 (const_var -> ID .)
    SEMICOLON       reduce using rule 83 (const_var -> ID .)
    COMMA           reduce using rule 83 (const_var -> ID .)
    LPAREN          shift and go to state 32
    DOT             shift and go to state 112


state 68

    (34) assignment0 -> ID LSQRBRACKET exp0 . RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> ID LSQRBRACKET exp0 . RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON

    RSQRBRACKET     shift and go to state 113


state 69

    (72) power0 -> attr_access0 . check_pow_rad_operator power2
    (80) check_pow_rad_operator -> .

    POWER           reduce using rule 80 (check_pow_rad_operator -> .)
    SQRT            reduce using rule 80 (check_pow_rad_operator -> .)
    MULTIPLY        reduce using rule 80 (check_pow_rad_operator -> .)
    DIVIDE          reduce using rule 80 (check_pow_rad_operator -> .)
    PLUS            reduce using rule 80 (check_pow_rad_operator -> .)
    MINUS           reduce using rule 80 (check_pow_rad_operator -> .)
    RSQRBRACKET     reduce using rule 80 (check_pow_rad_operator -> .)
    RPAREN          reduce using rule 80 (check_pow_rad_operator -> .)
    LTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    GTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    DIFFERENT       reduce using rule 80 (check_pow_rad_operator -> .)
    EQUIVALENT      reduce using rule 80 (check_pow_rad_operator -> .)
    SEMICOLON       reduce using rule 80 (check_pow_rad_operator -> .)
    COMMA           reduce using rule 80 (check_pow_rad_operator -> .)

    check_pow_rad_operator         shift and go to state 100

state 70

    (84) function_call -> ID LPAREN function_call_params0 . RPAREN

    RPAREN          shift and go to state 114
>>>>>>> Stashed changes


state 71

<<<<<<< Updated upstream
    (90) expression0 -> attr_access0 expression1 .

    SEMICOLON       reduce using rule 90 (expression0 -> attr_access0 expression1 .)
    COMMA           reduce using rule 90 (expression0 -> attr_access0 expression1 .)
    RPAREN          reduce using rule 90 (expression0 -> attr_access0 expression1 .)


state 72

    (72) power0 -> attr_access0 power2 .

    MULTIPLY        reduce using rule 72 (power0 -> attr_access0 power2 .)
    DIVIDE          reduce using rule 72 (power0 -> attr_access0 power2 .)
    PLUS            reduce using rule 72 (power0 -> attr_access0 power2 .)
    MINUS           reduce using rule 72 (power0 -> attr_access0 power2 .)
    LTHAN           reduce using rule 72 (power0 -> attr_access0 power2 .)
    GTHAN           reduce using rule 72 (power0 -> attr_access0 power2 .)
    DIFFERENT       reduce using rule 72 (power0 -> attr_access0 power2 .)
    EQUIVALENT      reduce using rule 72 (power0 -> attr_access0 power2 .)
    SEMICOLON       reduce using rule 72 (power0 -> attr_access0 power2 .)
    RSQRBRACKET     reduce using rule 72 (power0 -> attr_access0 power2 .)
    RPAREN          reduce using rule 72 (power0 -> attr_access0 power2 .)
    COMMA           reduce using rule 72 (power0 -> attr_access0 power2 .)
=======
    (85) function_call_params0 -> expression0 . function_call_params1
    (88) function_call_params1 -> . COMMA function_call_params0
    (89) function_call_params1 -> . empty
    (145) empty -> .

    COMMA           shift and go to state 116
    RPAREN          reduce using rule 145 (empty -> .)

    function_call_params1          shift and go to state 115
    empty                          shift and go to state 117

state 72

    (86) function_call_params0 -> CONST_STRING . function_call_params1
    (88) function_call_params1 -> . COMMA function_call_params0
    (89) function_call_params1 -> . empty
    (145) empty -> .

    COMMA           shift and go to state 116
    RPAREN          reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    function_call_params1          shift and go to state 118
    empty                          shift and go to state 117

state 73

<<<<<<< Updated upstream
    (91) expression1 -> empty .
    (78) power2 -> empty .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 78 (power2 -> empty .)
  ! reduce/reduce conflict for COMMA resolved using rule 78 (power2 -> empty .)
  ! reduce/reduce conflict for RPAREN resolved using rule 78 (power2 -> empty .)
    MULTIPLY        reduce using rule 78 (power2 -> empty .)
    DIVIDE          reduce using rule 78 (power2 -> empty .)
    PLUS            reduce using rule 78 (power2 -> empty .)
    MINUS           reduce using rule 78 (power2 -> empty .)
    LTHAN           reduce using rule 78 (power2 -> empty .)
    GTHAN           reduce using rule 78 (power2 -> empty .)
    DIFFERENT       reduce using rule 78 (power2 -> empty .)
    EQUIVALENT      reduce using rule 78 (power2 -> empty .)
    SEMICOLON       reduce using rule 78 (power2 -> empty .)
    COMMA           reduce using rule 78 (power2 -> empty .)
    RPAREN          reduce using rule 78 (power2 -> empty .)

  ! SEMICOLON       [ reduce using rule 91 (expression1 -> empty .) ]
  ! COMMA           [ reduce using rule 91 (expression1 -> empty .) ]
  ! RPAREN          [ reduce using rule 91 (expression1 -> empty .) ]
=======
    (87) function_call_params0 -> empty . function_call_params1
    (88) function_call_params1 -> . COMMA function_call_params0
    (89) function_call_params1 -> . empty
    (145) empty -> .

    COMMA           shift and go to state 116
    RPAREN          reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    empty                          shift and go to state 117
    function_call_params1          shift and go to state 119

state 74

<<<<<<< Updated upstream
    (76) power2 -> POWER . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    power0                         shift and go to state 133
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 75

    (77) power2 -> SQRT . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    power0                         shift and go to state 134
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 76

    (57) exp0 -> term0 exp1 .

    LTHAN           reduce using rule 57 (exp0 -> term0 exp1 .)
    GTHAN           reduce using rule 57 (exp0 -> term0 exp1 .)
    DIFFERENT       reduce using rule 57 (exp0 -> term0 exp1 .)
    EQUIVALENT      reduce using rule 57 (exp0 -> term0 exp1 .)
    SEMICOLON       reduce using rule 57 (exp0 -> term0 exp1 .)
    RSQRBRACKET     reduce using rule 57 (exp0 -> term0 exp1 .)
    RPAREN          reduce using rule 57 (exp0 -> term0 exp1 .)
    COMMA           reduce using rule 57 (exp0 -> term0 exp1 .)
=======
    (84) function_call -> ID . LPAREN function_call_params0 RPAREN

    LPAREN          shift and go to state 32


state 75

    (102) method_call0 -> ID DOT function_call .

    SEMICOLON       reduce using rule 102 (method_call0 -> ID DOT function_call .)
    POWER           reduce using rule 102 (method_call0 -> ID DOT function_call .)
    SQRT            reduce using rule 102 (method_call0 -> ID DOT function_call .)
    MULTIPLY        reduce using rule 102 (method_call0 -> ID DOT function_call .)
    DIVIDE          reduce using rule 102 (method_call0 -> ID DOT function_call .)
    PLUS            reduce using rule 102 (method_call0 -> ID DOT function_call .)
    MINUS           reduce using rule 102 (method_call0 -> ID DOT function_call .)
    LTHAN           reduce using rule 102 (method_call0 -> ID DOT function_call .)
    GTHAN           reduce using rule 102 (method_call0 -> ID DOT function_call .)
    DIFFERENT       reduce using rule 102 (method_call0 -> ID DOT function_call .)
    EQUIVALENT      reduce using rule 102 (method_call0 -> ID DOT function_call .)
    RSQRBRACKET     reduce using rule 102 (method_call0 -> ID DOT function_call .)
    COMMA           reduce using rule 102 (method_call0 -> ID DOT function_call .)
    RPAREN          reduce using rule 102 (method_call0 -> ID DOT function_call .)


state 76

    (140) main0 -> MAIN main_scope . LBRACKET main1 RBRACKET

    LBRACKET        shift and go to state 120
>>>>>>> Stashed changes


state 77

<<<<<<< Updated upstream
    (58) exp1 -> PLUS . exp0
    (57) exp0 -> . term0 exp1
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 135
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 78

    (59) exp1 -> MINUS . exp0
    (57) exp0 -> . term0 exp1
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 136
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 79
=======
    (9) class0 -> CLASS class_id_def class1 . LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global

    LBRACKET        shift and go to state 121


state 78

    (14) class1 -> COLON . ID

    ID              shift and go to state 122
>>>>>>> Stashed changes

    (60) exp1 -> empty .

    LTHAN           reduce using rule 60 (exp1 -> empty .)
    GTHAN           reduce using rule 60 (exp1 -> empty .)
    DIFFERENT       reduce using rule 60 (exp1 -> empty .)
    EQUIVALENT      reduce using rule 60 (exp1 -> empty .)
    SEMICOLON       reduce using rule 60 (exp1 -> empty .)
    RSQRBRACKET     reduce using rule 60 (exp1 -> empty .)
    RPAREN          reduce using rule 60 (exp1 -> empty .)
    COMMA           reduce using rule 60 (exp1 -> empty .)

<<<<<<< Updated upstream

state 80

    (61) term0 -> factor term1 .
=======
    (15) class1 -> empty .

    LBRACKET        reduce using rule 15 (class1 -> empty .)


state 80

    (20) function0 -> DEF id_def LPAREN . params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (42) params0 -> . type ID params1
    (43) params0 -> . empty
    (49) type -> . INT
    (50) type -> . FLOAT
    (51) type -> . STRING
    (52) type -> . BOOL
    (145) empty -> .

    INT             shift and go to state 84
    FLOAT           shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    RPAREN          reduce using rule 145 (empty -> .)

    params0                        shift and go to state 123
    type                           shift and go to state 124
    empty                          shift and go to state 125
>>>>>>> Stashed changes

    PLUS            reduce using rule 61 (term0 -> factor term1 .)
    MINUS           reduce using rule 61 (term0 -> factor term1 .)
    LTHAN           reduce using rule 61 (term0 -> factor term1 .)
    GTHAN           reduce using rule 61 (term0 -> factor term1 .)
    DIFFERENT       reduce using rule 61 (term0 -> factor term1 .)
    EQUIVALENT      reduce using rule 61 (term0 -> factor term1 .)
    SEMICOLON       reduce using rule 61 (term0 -> factor term1 .)
    RSQRBRACKET     reduce using rule 61 (term0 -> factor term1 .)
    RPAREN          reduce using rule 61 (term0 -> factor term1 .)
    COMMA           reduce using rule 61 (term0 -> factor term1 .)

<<<<<<< Updated upstream

state 81
=======
    (26) declaration0 -> decl_id_def COLON declaration1 . SEMICOLON

    SEMICOLON       shift and go to state 126
>>>>>>> Stashed changes

    (62) term1 -> MULTIPLY . term0
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    term0                          shift and go to state 137
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 82

<<<<<<< Updated upstream
    (63) term1 -> DIVIDE . term0
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    term0                          shift and go to state 138
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 83
=======
    (28) declaration1 -> type .
    (30) declaration1 -> type . LSQRBRACKET exp0 RSQRBRACKET declaration2

    SEMICOLON       reduce using rule 28 (declaration1 -> type .)
    LSQRBRACKET     shift and go to state 127
>>>>>>> Stashed changes

    (64) term1 -> empty .

    PLUS            reduce using rule 64 (term1 -> empty .)
    MINUS           reduce using rule 64 (term1 -> empty .)
    LTHAN           reduce using rule 64 (term1 -> empty .)
    GTHAN           reduce using rule 64 (term1 -> empty .)
    DIFFERENT       reduce using rule 64 (term1 -> empty .)
    EQUIVALENT      reduce using rule 64 (term1 -> empty .)
    SEMICOLON       reduce using rule 64 (term1 -> empty .)
    RSQRBRACKET     reduce using rule 64 (term1 -> empty .)
    RPAREN          reduce using rule 64 (term1 -> empty .)
    COMMA           reduce using rule 64 (term1 -> empty .)

<<<<<<< Updated upstream

state 84

    (65) factor -> PLUS power0 .

    MULTIPLY        reduce using rule 65 (factor -> PLUS power0 .)
    DIVIDE          reduce using rule 65 (factor -> PLUS power0 .)
    PLUS            reduce using rule 65 (factor -> PLUS power0 .)
    MINUS           reduce using rule 65 (factor -> PLUS power0 .)
    LTHAN           reduce using rule 65 (factor -> PLUS power0 .)
    GTHAN           reduce using rule 65 (factor -> PLUS power0 .)
    DIFFERENT       reduce using rule 65 (factor -> PLUS power0 .)
    EQUIVALENT      reduce using rule 65 (factor -> PLUS power0 .)
    SEMICOLON       reduce using rule 65 (factor -> PLUS power0 .)
    RSQRBRACKET     reduce using rule 65 (factor -> PLUS power0 .)
    RPAREN          reduce using rule 65 (factor -> PLUS power0 .)
    COMMA           reduce using rule 65 (factor -> PLUS power0 .)
=======
    (29) declaration1 -> complex_type .

    SEMICOLON       reduce using rule 29 (declaration1 -> complex_type .)


state 84

    (49) type -> INT .

    LSQRBRACKET     reduce using rule 49 (type -> INT .)
    SEMICOLON       reduce using rule 49 (type -> INT .)
    ID              reduce using rule 49 (type -> INT .)
>>>>>>> Stashed changes


state 85

<<<<<<< Updated upstream
    (66) factor -> MINUS power0 .

    MULTIPLY        reduce using rule 66 (factor -> MINUS power0 .)
    DIVIDE          reduce using rule 66 (factor -> MINUS power0 .)
    PLUS            reduce using rule 66 (factor -> MINUS power0 .)
    MINUS           reduce using rule 66 (factor -> MINUS power0 .)
    LTHAN           reduce using rule 66 (factor -> MINUS power0 .)
    GTHAN           reduce using rule 66 (factor -> MINUS power0 .)
    DIFFERENT       reduce using rule 66 (factor -> MINUS power0 .)
    EQUIVALENT      reduce using rule 66 (factor -> MINUS power0 .)
    SEMICOLON       reduce using rule 66 (factor -> MINUS power0 .)
    RSQRBRACKET     reduce using rule 66 (factor -> MINUS power0 .)
    RPAREN          reduce using rule 66 (factor -> MINUS power0 .)
    COMMA           reduce using rule 66 (factor -> MINUS power0 .)
=======
    (50) type -> FLOAT .

    LSQRBRACKET     reduce using rule 50 (type -> FLOAT .)
    SEMICOLON       reduce using rule 50 (type -> FLOAT .)
    ID              reduce using rule 50 (type -> FLOAT .)
>>>>>>> Stashed changes


state 86

<<<<<<< Updated upstream
    (68) power0 -> LPAREN exp0 . RPAREN power2

    RPAREN          shift and go to state 139
=======
    (51) type -> STRING .

    LSQRBRACKET     reduce using rule 51 (type -> STRING .)
    SEMICOLON       reduce using rule 51 (type -> STRING .)
    ID              reduce using rule 51 (type -> STRING .)
>>>>>>> Stashed changes


state 87

<<<<<<< Updated upstream
    (69) power0 -> const_var power2 .

    MULTIPLY        reduce using rule 69 (power0 -> const_var power2 .)
    DIVIDE          reduce using rule 69 (power0 -> const_var power2 .)
    PLUS            reduce using rule 69 (power0 -> const_var power2 .)
    MINUS           reduce using rule 69 (power0 -> const_var power2 .)
    LTHAN           reduce using rule 69 (power0 -> const_var power2 .)
    GTHAN           reduce using rule 69 (power0 -> const_var power2 .)
    DIFFERENT       reduce using rule 69 (power0 -> const_var power2 .)
    EQUIVALENT      reduce using rule 69 (power0 -> const_var power2 .)
    SEMICOLON       reduce using rule 69 (power0 -> const_var power2 .)
    RSQRBRACKET     reduce using rule 69 (power0 -> const_var power2 .)
    RPAREN          reduce using rule 69 (power0 -> const_var power2 .)
    COMMA           reduce using rule 69 (power0 -> const_var power2 .)
=======
    (52) type -> BOOL .

    LSQRBRACKET     reduce using rule 52 (type -> BOOL .)
    SEMICOLON       reduce using rule 52 (type -> BOOL .)
    ID              reduce using rule 52 (type -> BOOL .)
>>>>>>> Stashed changes


state 88

<<<<<<< Updated upstream
    (78) power2 -> empty .

    MULTIPLY        reduce using rule 78 (power2 -> empty .)
    DIVIDE          reduce using rule 78 (power2 -> empty .)
    PLUS            reduce using rule 78 (power2 -> empty .)
    MINUS           reduce using rule 78 (power2 -> empty .)
    LTHAN           reduce using rule 78 (power2 -> empty .)
    GTHAN           reduce using rule 78 (power2 -> empty .)
    DIFFERENT       reduce using rule 78 (power2 -> empty .)
    EQUIVALENT      reduce using rule 78 (power2 -> empty .)
    SEMICOLON       reduce using rule 78 (power2 -> empty .)
    RSQRBRACKET     reduce using rule 78 (power2 -> empty .)
    RPAREN          reduce using rule 78 (power2 -> empty .)
    COMMA           reduce using rule 78 (power2 -> empty .)
=======
    (55) complex_type -> ID .

    SEMICOLON       reduce using rule 55 (complex_type -> ID .)
>>>>>>> Stashed changes


state 89

<<<<<<< Updated upstream
    (70) power0 -> function_call power2 .

    MULTIPLY        reduce using rule 70 (power0 -> function_call power2 .)
    DIVIDE          reduce using rule 70 (power0 -> function_call power2 .)
    PLUS            reduce using rule 70 (power0 -> function_call power2 .)
    MINUS           reduce using rule 70 (power0 -> function_call power2 .)
    LTHAN           reduce using rule 70 (power0 -> function_call power2 .)
    GTHAN           reduce using rule 70 (power0 -> function_call power2 .)
    DIFFERENT       reduce using rule 70 (power0 -> function_call power2 .)
    EQUIVALENT      reduce using rule 70 (power0 -> function_call power2 .)
    SEMICOLON       reduce using rule 70 (power0 -> function_call power2 .)
    RSQRBRACKET     reduce using rule 70 (power0 -> function_call power2 .)
    RPAREN          reduce using rule 70 (power0 -> function_call power2 .)
    COMMA           reduce using rule 70 (power0 -> function_call power2 .)
=======
    (113) condition0 -> IF LPAREN expression0 . RPAREN block0 condition1 SEMICOLON

    RPAREN          shift and go to state 128
>>>>>>> Stashed changes


state 90

<<<<<<< Updated upstream
    (71) power0 -> method_call0 power2 .

    MULTIPLY        reduce using rule 71 (power0 -> method_call0 power2 .)
    DIVIDE          reduce using rule 71 (power0 -> method_call0 power2 .)
    PLUS            reduce using rule 71 (power0 -> method_call0 power2 .)
    MINUS           reduce using rule 71 (power0 -> method_call0 power2 .)
    LTHAN           reduce using rule 71 (power0 -> method_call0 power2 .)
    GTHAN           reduce using rule 71 (power0 -> method_call0 power2 .)
    DIFFERENT       reduce using rule 71 (power0 -> method_call0 power2 .)
    EQUIVALENT      reduce using rule 71 (power0 -> method_call0 power2 .)
    SEMICOLON       reduce using rule 71 (power0 -> method_call0 power2 .)
    RSQRBRACKET     reduce using rule 71 (power0 -> method_call0 power2 .)
    RPAREN          reduce using rule 71 (power0 -> method_call0 power2 .)
    COMMA           reduce using rule 71 (power0 -> method_call0 power2 .)


state 91

    (101) method_call0 -> ID DOT . function_call
    (100) attr_access0 -> ID DOT . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN

    ID              shift and go to state 119
=======
    (116) writing0 -> WRITE push_writing_op LPAREN . writing1 RPAREN SEMICOLON
    (119) writing1 -> . expression0 writing2
    (120) writing1 -> . CONST_STRING push_string_val writing2
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 131
    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    writing1                       shift and go to state 129
    expression0                    shift and go to state 130
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 91

    (123) reading -> READ ID SEMICOLON .

    CLASS           reduce using rule 123 (reading -> READ ID SEMICOLON .)
    DEF             reduce using rule 123 (reading -> READ ID SEMICOLON .)
    ID              reduce using rule 123 (reading -> READ ID SEMICOLON .)
    IF              reduce using rule 123 (reading -> READ ID SEMICOLON .)
    WRITE           reduce using rule 123 (reading -> READ ID SEMICOLON .)
    READ            reduce using rule 123 (reading -> READ ID SEMICOLON .)
    RETURN          reduce using rule 123 (reading -> READ ID SEMICOLON .)
    WHILE           reduce using rule 123 (reading -> READ ID SEMICOLON .)
    MAIN            reduce using rule 123 (reading -> READ ID SEMICOLON .)
    RBRACKET        reduce using rule 123 (reading -> READ ID SEMICOLON .)
>>>>>>> Stashed changes

    function_call                  shift and go to state 120

state 92

<<<<<<< Updated upstream
    (27) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET . EQUALS expression0 SEMICOLON
    (28) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET . LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON

    EQUALS          shift and go to state 141
    LSQRBRACKET     shift and go to state 140
=======
    (124) return -> RETURN expression0 SEMICOLON .

    CLASS           reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
    DEF             reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
    ID              reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
    IF              reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
    WRITE           reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
    READ            reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
    RETURN          reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
    WHILE           reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
    MAIN            reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
    RBRACKET        reduce using rule 124 (return -> RETURN expression0 SEMICOLON .)
>>>>>>> Stashed changes


state 93

<<<<<<< Updated upstream
    (137) main0 -> MAIN LBRACKET main1 . RBRACKET

    RBRACKET        shift and go to state 142
=======
    (90) expression0 -> exp0 expression1 .

    SEMICOLON       reduce using rule 90 (expression0 -> exp0 expression1 .)
    COMMA           reduce using rule 90 (expression0 -> exp0 expression1 .)
    RPAREN          reduce using rule 90 (expression0 -> exp0 expression1 .)
>>>>>>> Stashed changes


state 94

<<<<<<< Updated upstream
    (138) main1 -> declaration0 . main1
    (138) main1 -> . declaration0 main1
    (139) main1 -> . statement main1
    (140) main1 -> . empty
    (20) declaration0 -> . ID COLON declaration1 SEMICOLON
    (127) statement -> . assignment0
    (128) statement -> . object_assignment
    (129) statement -> . condition0
    (130) statement -> . writing0
    (131) statement -> . reading
    (132) statement -> . return
    (133) statement -> . function_call SEMICOLON
    (134) statement -> . method_call0 SEMICOLON
    (135) statement -> . while
    (141) empty -> .
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (136) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (112) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (115) writing0 -> . WRITE LPAREN writing1 RPAREN SEMICOLON
    (120) reading -> . READ ID SEMICOLON
    (121) return -> . RETURN expression0 SEMICOLON
    (122) return -> . RETURN SEMICOLON
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (123) while -> . WHILE LPAREN expression0 RPAREN block0

    ID              shift and go to state 97
    RBRACKET        reduce using rule 141 (empty -> .)
    IF              shift and go to state 107
    WRITE           shift and go to state 108
    READ            shift and go to state 109
    RETURN          shift and go to state 110
    WHILE           shift and go to state 111

    declaration0                   shift and go to state 94
    main1                          shift and go to state 143
    statement                      shift and go to state 95
    empty                          shift and go to state 96
    assignment0                    shift and go to state 98
    object_assignment              shift and go to state 99
    condition0                     shift and go to state 100
    writing0                       shift and go to state 101
    reading                        shift and go to state 102
    return                         shift and go to state 103
    function_call                  shift and go to state 104
    method_call0                   shift and go to state 105
    while                          shift and go to state 106

state 95

    (139) main1 -> statement . main1
    (138) main1 -> . declaration0 main1
    (139) main1 -> . statement main1
    (140) main1 -> . empty
    (20) declaration0 -> . ID COLON declaration1 SEMICOLON
    (127) statement -> . assignment0
    (128) statement -> . object_assignment
    (129) statement -> . condition0
    (130) statement -> . writing0
    (131) statement -> . reading
    (132) statement -> . return
    (133) statement -> . function_call SEMICOLON
    (134) statement -> . method_call0 SEMICOLON
    (135) statement -> . while
    (141) empty -> .
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (136) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (112) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (115) writing0 -> . WRITE LPAREN writing1 RPAREN SEMICOLON
    (120) reading -> . READ ID SEMICOLON
    (121) return -> . RETURN expression0 SEMICOLON
    (122) return -> . RETURN SEMICOLON
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (123) while -> . WHILE LPAREN expression0 RPAREN block0

    ID              shift and go to state 97
    RBRACKET        reduce using rule 141 (empty -> .)
    IF              shift and go to state 107
    WRITE           shift and go to state 108
    READ            shift and go to state 109
    RETURN          shift and go to state 110
    WHILE           shift and go to state 111

    statement                      shift and go to state 95
    main1                          shift and go to state 144
    declaration0                   shift and go to state 94
    empty                          shift and go to state 96
    assignment0                    shift and go to state 98
    object_assignment              shift and go to state 99
    condition0                     shift and go to state 100
    writing0                       shift and go to state 101
    reading                        shift and go to state 102
    return                         shift and go to state 103
    function_call                  shift and go to state 104
    method_call0                   shift and go to state 105
    while                          shift and go to state 106

state 96

    (140) main1 -> empty .

    RBRACKET        reduce using rule 140 (main1 -> empty .)


state 97

    (20) declaration0 -> ID . COLON declaration1 SEMICOLON
    (26) assignment0 -> ID . EQUALS expression0 SEMICOLON
    (27) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (136) object_assignment -> ID . EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (82) function_call -> ID . LPAREN function_call_params0 RPAREN
    (101) method_call0 -> ID . DOT function_call

    COLON           shift and go to state 14
    EQUALS          shift and go to state 145
    LSQRBRACKET     shift and go to state 16
    LPAREN          shift and go to state 61
    DOT             shift and go to state 146
=======
    (92) expression1 -> LTHAN . push_rel_op expression3
    (97) push_rel_op -> .

    ID              reduce using rule 97 (push_rel_op -> .)
    LPAREN          reduce using rule 97 (push_rel_op -> .)
    CONST_INT       reduce using rule 97 (push_rel_op -> .)
    CONST_FLOAT     reduce using rule 97 (push_rel_op -> .)

    push_rel_op                    shift and go to state 132

state 95

    (93) expression1 -> GTHAN . push_rel_op expression3
    (97) push_rel_op -> .

    ID              reduce using rule 97 (push_rel_op -> .)
    LPAREN          reduce using rule 97 (push_rel_op -> .)
    CONST_INT       reduce using rule 97 (push_rel_op -> .)
    CONST_FLOAT     reduce using rule 97 (push_rel_op -> .)

    push_rel_op                    shift and go to state 133

state 96

    (94) expression1 -> DIFFERENT . push_rel_op expression3
    (97) push_rel_op -> .

    ID              reduce using rule 97 (push_rel_op -> .)
    LPAREN          reduce using rule 97 (push_rel_op -> .)
    CONST_INT       reduce using rule 97 (push_rel_op -> .)
    CONST_FLOAT     reduce using rule 97 (push_rel_op -> .)

    push_rel_op                    shift and go to state 134

state 97

    (95) expression1 -> EQUIVALENT . push_rel_op expression3
    (97) push_rel_op -> .

    ID              reduce using rule 97 (push_rel_op -> .)
    LPAREN          reduce using rule 97 (push_rel_op -> .)
    CONST_INT       reduce using rule 97 (push_rel_op -> .)
    CONST_FLOAT     reduce using rule 97 (push_rel_op -> .)
>>>>>>> Stashed changes

    push_rel_op                    shift and go to state 135

state 98

<<<<<<< Updated upstream
    (127) statement -> assignment0 .

    ID              reduce using rule 127 (statement -> assignment0 .)
    IF              reduce using rule 127 (statement -> assignment0 .)
    WRITE           reduce using rule 127 (statement -> assignment0 .)
    READ            reduce using rule 127 (statement -> assignment0 .)
    RETURN          reduce using rule 127 (statement -> assignment0 .)
    WHILE           reduce using rule 127 (statement -> assignment0 .)
    RBRACKET        reduce using rule 127 (statement -> assignment0 .)
=======
    (96) expression1 -> empty .

    SEMICOLON       reduce using rule 96 (expression1 -> empty .)
    COMMA           reduce using rule 96 (expression1 -> empty .)
    RPAREN          reduce using rule 96 (expression1 -> empty .)
>>>>>>> Stashed changes


state 99

<<<<<<< Updated upstream
    (128) statement -> object_assignment .

    ID              reduce using rule 128 (statement -> object_assignment .)
    IF              reduce using rule 128 (statement -> object_assignment .)
    WRITE           reduce using rule 128 (statement -> object_assignment .)
    READ            reduce using rule 128 (statement -> object_assignment .)
    RETURN          reduce using rule 128 (statement -> object_assignment .)
    WHILE           reduce using rule 128 (statement -> object_assignment .)
    RBRACKET        reduce using rule 128 (statement -> object_assignment .)
=======
    (91) expression0 -> attr_access0 expression1 .

    SEMICOLON       reduce using rule 91 (expression0 -> attr_access0 expression1 .)
    COMMA           reduce using rule 91 (expression0 -> attr_access0 expression1 .)
    RPAREN          reduce using rule 91 (expression0 -> attr_access0 expression1 .)
>>>>>>> Stashed changes


state 100

<<<<<<< Updated upstream
    (129) statement -> condition0 .

    ID              reduce using rule 129 (statement -> condition0 .)
    IF              reduce using rule 129 (statement -> condition0 .)
    WRITE           reduce using rule 129 (statement -> condition0 .)
    READ            reduce using rule 129 (statement -> condition0 .)
    RETURN          reduce using rule 129 (statement -> condition0 .)
    WHILE           reduce using rule 129 (statement -> condition0 .)
    RBRACKET        reduce using rule 129 (statement -> condition0 .)


state 101

    (130) statement -> writing0 .

    ID              reduce using rule 130 (statement -> writing0 .)
    IF              reduce using rule 130 (statement -> writing0 .)
    WRITE           reduce using rule 130 (statement -> writing0 .)
    READ            reduce using rule 130 (statement -> writing0 .)
    RETURN          reduce using rule 130 (statement -> writing0 .)
    WHILE           reduce using rule 130 (statement -> writing0 .)
    RBRACKET        reduce using rule 130 (statement -> writing0 .)
=======
    (72) power0 -> attr_access0 check_pow_rad_operator . power2
    (76) power2 -> . POWER push_pow_rad_op power0
    (77) power2 -> . SQRT push_pow_rad_op power0
    (78) power2 -> . empty
    (145) empty -> .

    POWER           shift and go to state 137
    SQRT            shift and go to state 138
    MULTIPLY        reduce using rule 145 (empty -> .)
    DIVIDE          reduce using rule 145 (empty -> .)
    PLUS            reduce using rule 145 (empty -> .)
    MINUS           reduce using rule 145 (empty -> .)
    LTHAN           reduce using rule 145 (empty -> .)
    GTHAN           reduce using rule 145 (empty -> .)
    DIFFERENT       reduce using rule 145 (empty -> .)
    EQUIVALENT      reduce using rule 145 (empty -> .)
    SEMICOLON       reduce using rule 145 (empty -> .)
    RSQRBRACKET     reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)

    power2                         shift and go to state 136
    empty                          shift and go to state 139

state 101

    (56) exp0 -> term0 check_last_plus_minus_operator . exp1
    (57) exp1 -> . PLUS push_plus_minus_op exp0
    (58) exp1 -> . MINUS push_plus_minus_op exp0
    (59) exp1 -> . empty
    (145) empty -> .

    PLUS            shift and go to state 141
    MINUS           shift and go to state 142
    LTHAN           reduce using rule 145 (empty -> .)
    GTHAN           reduce using rule 145 (empty -> .)
    DIFFERENT       reduce using rule 145 (empty -> .)
    EQUIVALENT      reduce using rule 145 (empty -> .)
    SEMICOLON       reduce using rule 145 (empty -> .)
    RSQRBRACKET     reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)

    exp1                           shift and go to state 140
    empty                          shift and go to state 143

state 102
>>>>>>> Stashed changes

    (101) attr_access0 -> ID DOT . ID
    (102) method_call0 -> ID DOT . function_call
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN

    ID              shift and go to state 144

<<<<<<< Updated upstream
    (131) statement -> reading .

    ID              reduce using rule 131 (statement -> reading .)
    IF              reduce using rule 131 (statement -> reading .)
    WRITE           reduce using rule 131 (statement -> reading .)
    READ            reduce using rule 131 (statement -> reading .)
    RETURN          reduce using rule 131 (statement -> reading .)
    WHILE           reduce using rule 131 (statement -> reading .)
    RBRACKET        reduce using rule 131 (statement -> reading .)


state 103

    (132) statement -> return .

    ID              reduce using rule 132 (statement -> return .)
    IF              reduce using rule 132 (statement -> return .)
    WRITE           reduce using rule 132 (statement -> return .)
    READ            reduce using rule 132 (statement -> return .)
    RETURN          reduce using rule 132 (statement -> return .)
    WHILE           reduce using rule 132 (statement -> return .)
    RBRACKET        reduce using rule 132 (statement -> return .)


state 104

    (133) statement -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 147


state 105

    (134) statement -> method_call0 . SEMICOLON

    SEMICOLON       shift and go to state 148
=======
    function_call                  shift and go to state 75

state 103

    (73) power0 -> ID LSQRBRACKET . exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 145
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 104

    (62) term0 -> power0 check_last_times_division_operator . term1
    (63) term1 -> . MULTIPLY push_times_division_op term0
    (64) term1 -> . DIVIDE push_times_division_op term0
    (65) term1 -> . empty
    (145) empty -> .

    MULTIPLY        shift and go to state 147
    DIVIDE          shift and go to state 148
    PLUS            reduce using rule 145 (empty -> .)
    MINUS           reduce using rule 145 (empty -> .)
    LTHAN           reduce using rule 145 (empty -> .)
    GTHAN           reduce using rule 145 (empty -> .)
    DIFFERENT       reduce using rule 145 (empty -> .)
    EQUIVALENT      reduce using rule 145 (empty -> .)
    SEMICOLON       reduce using rule 145 (empty -> .)
    RSQRBRACKET     reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)

    term1                          shift and go to state 146
    empty                          shift and go to state 149

state 105

    (68) power0 -> LPAREN exp0 . RPAREN check_pow_rad_operator power2

    RPAREN          shift and go to state 150
>>>>>>> Stashed changes


state 106

<<<<<<< Updated upstream
    (135) statement -> while .

    ID              reduce using rule 135 (statement -> while .)
    IF              reduce using rule 135 (statement -> while .)
    WRITE           reduce using rule 135 (statement -> while .)
    READ            reduce using rule 135 (statement -> while .)
    RETURN          reduce using rule 135 (statement -> while .)
    WHILE           reduce using rule 135 (statement -> while .)
    RBRACKET        reduce using rule 135 (statement -> while .)


state 107

    (112) condition0 -> IF . LPAREN expression0 RPAREN block0 condition1 SEMICOLON

    LPAREN          shift and go to state 149


state 108

    (115) writing0 -> WRITE . LPAREN writing1 RPAREN SEMICOLON

    LPAREN          shift and go to state 150


state 109

    (120) reading -> READ . ID SEMICOLON

    ID              shift and go to state 151
=======
    (69) power0 -> const_var check_pow_rad_operator . power2
    (76) power2 -> . POWER push_pow_rad_op power0
    (77) power2 -> . SQRT push_pow_rad_op power0
    (78) power2 -> . empty
    (145) empty -> .

    POWER           shift and go to state 137
    SQRT            shift and go to state 138
    MULTIPLY        reduce using rule 145 (empty -> .)
    DIVIDE          reduce using rule 145 (empty -> .)
    PLUS            reduce using rule 145 (empty -> .)
    MINUS           reduce using rule 145 (empty -> .)
    LTHAN           reduce using rule 145 (empty -> .)
    GTHAN           reduce using rule 145 (empty -> .)
    DIFFERENT       reduce using rule 145 (empty -> .)
    EQUIVALENT      reduce using rule 145 (empty -> .)
    SEMICOLON       reduce using rule 145 (empty -> .)
    RSQRBRACKET     reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)

    power2                         shift and go to state 151
    empty                          shift and go to state 139

state 107

    (70) power0 -> function_call check_pow_rad_operator . power2
    (76) power2 -> . POWER push_pow_rad_op power0
    (77) power2 -> . SQRT push_pow_rad_op power0
    (78) power2 -> . empty
    (145) empty -> .

    POWER           shift and go to state 137
    SQRT            shift and go to state 138
    MULTIPLY        reduce using rule 145 (empty -> .)
    DIVIDE          reduce using rule 145 (empty -> .)
    PLUS            reduce using rule 145 (empty -> .)
    MINUS           reduce using rule 145 (empty -> .)
    LTHAN           reduce using rule 145 (empty -> .)
    GTHAN           reduce using rule 145 (empty -> .)
    DIFFERENT       reduce using rule 145 (empty -> .)
    EQUIVALENT      reduce using rule 145 (empty -> .)
    SEMICOLON       reduce using rule 145 (empty -> .)
    RSQRBRACKET     reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)

    power2                         shift and go to state 152
    empty                          shift and go to state 139

state 108

    (71) power0 -> method_call0 check_pow_rad_operator . power2
    (76) power2 -> . POWER push_pow_rad_op power0
    (77) power2 -> . SQRT push_pow_rad_op power0
    (78) power2 -> . empty
    (145) empty -> .

    POWER           shift and go to state 137
    SQRT            shift and go to state 138
    MULTIPLY        reduce using rule 145 (empty -> .)
    DIVIDE          reduce using rule 145 (empty -> .)
    PLUS            reduce using rule 145 (empty -> .)
    MINUS           reduce using rule 145 (empty -> .)
    LTHAN           reduce using rule 145 (empty -> .)
    GTHAN           reduce using rule 145 (empty -> .)
    DIFFERENT       reduce using rule 145 (empty -> .)
    EQUIVALENT      reduce using rule 145 (empty -> .)
    SEMICOLON       reduce using rule 145 (empty -> .)
    RSQRBRACKET     reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)

    power2                         shift and go to state 153
    empty                          shift and go to state 139

state 109

    (126) while -> WHILE LPAREN expression0 . RPAREN block0

    RPAREN          shift and go to state 154
>>>>>>> Stashed changes


state 110

<<<<<<< Updated upstream
    (121) return -> RETURN . expression0 SEMICOLON
    (122) return -> RETURN . SEMICOLON
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    SEMICOLON       shift and go to state 153
    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression0                    shift and go to state 152
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 111

    (123) while -> WHILE . LPAREN expression0 RPAREN block0

    LPAREN          shift and go to state 154
=======
    (33) assignment0 -> ID EQUALS expression0 SEMICOLON .

    CLASS           reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    DEF             reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    MAIN            reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 33 (assignment0 -> ID EQUALS expression0 SEMICOLON .)


state 111

    (139) object_assignment -> ID EQUALS NEW ID . LPAREN function_call_params0 RPAREN SEMICOLON

    LPAREN          shift and go to state 155
>>>>>>> Stashed changes


state 112

<<<<<<< Updated upstream
    (7) class0 -> CLASS ID class1 LBRACKET . class2 constructor class3 RBRACKET SEMICOLON
    (10) class2 -> . attributes
    (11) class2 -> . empty
    (31) attributes -> . data_access simple_declaration attributes
    (32) attributes -> . simple_assignment attributes
    (33) attributes -> . empty
    (141) empty -> .
    (102) data_access -> . PRIVATE
    (103) data_access -> . PUBLIC
    (48) simple_assignment -> . ID EQUALS expression0 SEMICOLON

    CONSTRUCT       reduce using rule 141 (empty -> .)
    PRIVATE         shift and go to state 161
    PUBLIC          shift and go to state 162
    ID              shift and go to state 155

    class2                         shift and go to state 156
    attributes                     shift and go to state 157
    empty                          shift and go to state 158
    data_access                    shift and go to state 159
    simple_assignment              shift and go to state 160

state 113

    (8) class1 -> COLON extension0 .
=======
    (102) method_call0 -> ID DOT . function_call
    (101) attr_access0 -> ID DOT . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN

    ID              shift and go to state 144

    function_call                  shift and go to state 75
>>>>>>> Stashed changes

    LBRACKET        reduce using rule 8 (class1 -> COLON extension0 .)

<<<<<<< Updated upstream

state 114

    (30) extension0 -> ID .

    LBRACKET        reduce using rule 30 (extension0 -> ID .)
=======
    (34) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET . EQUALS expression0 SEMICOLON
    (35) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET . LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON

    EQUALS          shift and go to state 157
    LSQRBRACKET     shift and go to state 156


state 114

    (84) function_call -> ID LPAREN function_call_params0 RPAREN .

    SEMICOLON       reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    POWER           reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    SQRT            reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    MULTIPLY        reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    DIVIDE          reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    PLUS            reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    MINUS           reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    LTHAN           reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    GTHAN           reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    DIFFERENT       reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    EQUIVALENT      reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    RSQRBRACKET     reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    COMMA           reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    RPAREN          reduce using rule 84 (function_call -> ID LPAREN function_call_params0 RPAREN .)
>>>>>>> Stashed changes


state 115

<<<<<<< Updated upstream
    (14) function0 -> DEF ID LPAREN params0 . RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    RPAREN          shift and go to state 163
=======
    (85) function_call_params0 -> expression0 function_call_params1 .

    RPAREN          reduce using rule 85 (function_call_params0 -> expression0 function_call_params1 .)
>>>>>>> Stashed changes


state 116

<<<<<<< Updated upstream
    (36) params0 -> type . ID params1

    ID              shift and go to state 164


state 117

    (37) params0 -> empty .

    RPAREN          reduce using rule 37 (params0 -> empty .)
=======
    (88) function_call_params1 -> COMMA . function_call_params0
    (85) function_call_params0 -> . expression0 function_call_params1
    (86) function_call_params0 -> . CONST_STRING function_call_params1
    (87) function_call_params0 -> . empty function_call_params1
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (145) empty -> .
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 72
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)
    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    function_call_params0          shift and go to state 158
    expression0                    shift and go to state 71
    empty                          shift and go to state 73
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 117

    (89) function_call_params1 -> empty .

    RPAREN          reduce using rule 89 (function_call_params1 -> empty .)
>>>>>>> Stashed changes


state 118

<<<<<<< Updated upstream
    (23) declaration1 -> type LSQRBRACKET exp0 . RSQRBRACKET declaration2

    RSQRBRACKET     shift and go to state 165
=======
    (86) function_call_params0 -> CONST_STRING function_call_params1 .

    RPAREN          reduce using rule 86 (function_call_params0 -> CONST_STRING function_call_params1 .)
>>>>>>> Stashed changes


state 119

<<<<<<< Updated upstream
    (100) attr_access0 -> ID DOT ID .
    (82) function_call -> ID . LPAREN function_call_params0 RPAREN

    POWER           reduce using rule 100 (attr_access0 -> ID DOT ID .)
    SQRT            reduce using rule 100 (attr_access0 -> ID DOT ID .)
    LTHAN           reduce using rule 100 (attr_access0 -> ID DOT ID .)
    GTHAN           reduce using rule 100 (attr_access0 -> ID DOT ID .)
    DIFFERENT       reduce using rule 100 (attr_access0 -> ID DOT ID .)
    EQUIVALENT      reduce using rule 100 (attr_access0 -> ID DOT ID .)
    SEMICOLON       reduce using rule 100 (attr_access0 -> ID DOT ID .)
    MULTIPLY        reduce using rule 100 (attr_access0 -> ID DOT ID .)
    DIVIDE          reduce using rule 100 (attr_access0 -> ID DOT ID .)
    PLUS            reduce using rule 100 (attr_access0 -> ID DOT ID .)
    MINUS           reduce using rule 100 (attr_access0 -> ID DOT ID .)
    RSQRBRACKET     reduce using rule 100 (attr_access0 -> ID DOT ID .)
    RPAREN          reduce using rule 100 (attr_access0 -> ID DOT ID .)
    COMMA           reduce using rule 100 (attr_access0 -> ID DOT ID .)
    LPAREN          shift and go to state 61
=======
    (87) function_call_params0 -> empty function_call_params1 .

    RPAREN          reduce using rule 87 (function_call_params0 -> empty function_call_params1 .)
>>>>>>> Stashed changes


state 120

<<<<<<< Updated upstream
    (101) method_call0 -> ID DOT function_call .

    POWER           reduce using rule 101 (method_call0 -> ID DOT function_call .)
    SQRT            reduce using rule 101 (method_call0 -> ID DOT function_call .)
    MULTIPLY        reduce using rule 101 (method_call0 -> ID DOT function_call .)
    DIVIDE          reduce using rule 101 (method_call0 -> ID DOT function_call .)
    PLUS            reduce using rule 101 (method_call0 -> ID DOT function_call .)
    MINUS           reduce using rule 101 (method_call0 -> ID DOT function_call .)
    LTHAN           reduce using rule 101 (method_call0 -> ID DOT function_call .)
    GTHAN           reduce using rule 101 (method_call0 -> ID DOT function_call .)
    DIFFERENT       reduce using rule 101 (method_call0 -> ID DOT function_call .)
    EQUIVALENT      reduce using rule 101 (method_call0 -> ID DOT function_call .)
    SEMICOLON       reduce using rule 101 (method_call0 -> ID DOT function_call .)
    RSQRBRACKET     reduce using rule 101 (method_call0 -> ID DOT function_call .)
    RPAREN          reduce using rule 101 (method_call0 -> ID DOT function_call .)
    COMMA           reduce using rule 101 (method_call0 -> ID DOT function_call .)


state 121

    (73) power0 -> ID LSQRBRACKET exp0 . RSQRBRACKET power1 power2

    RSQRBRACKET     shift and go to state 166


state 122

    (82) function_call -> ID LPAREN function_call_params0 . RPAREN

    RPAREN          shift and go to state 167
=======
    (140) main0 -> MAIN main_scope LBRACKET . main1 RBRACKET
    (141) main1 -> . declaration0 main1
    (142) main1 -> . statement main1
    (143) main1 -> . empty
    (26) declaration0 -> . decl_id_def COLON declaration1 SEMICOLON
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (145) empty -> .
    (27) decl_id_def -> . ID
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 145 (empty -> .)
    ID              shift and go to state 164
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    main1                          shift and go to state 159
    declaration0                   shift and go to state 160
    statement                      shift and go to state 161
    empty                          shift and go to state 162
    decl_id_def                    shift and go to state 24
    assignment0                    shift and go to state 163
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21

state 121

    (9) class0 -> CLASS class_id_def class1 LBRACKET . class2 constructor class3 RBRACKET SEMICOLON revert_global
    (16) class2 -> . attributes
    (17) class2 -> . empty
    (37) attributes -> . data_access simple_declaration attributes
    (38) attributes -> . simple_assignment attributes
    (39) attributes -> . empty
    (145) empty -> .
    (103) data_access -> . PRIVATE
    (104) data_access -> . PUBLIC
    (54) simple_assignment -> . ID EQUALS expression0 SEMICOLON

    CONSTRUCT       reduce using rule 145 (empty -> .)
    PRIVATE         shift and go to state 170
    PUBLIC          shift and go to state 171
    ID              shift and go to state 172

    class2                         shift and go to state 165
    attributes                     shift and go to state 166
    empty                          shift and go to state 167
    data_access                    shift and go to state 168
    simple_assignment              shift and go to state 169

state 122

    (14) class1 -> COLON ID .

    LBRACKET        reduce using rule 14 (class1 -> COLON ID .)
>>>>>>> Stashed changes


state 123

<<<<<<< Updated upstream
    (83) function_call_params0 -> expression0 . function_call_params1
    (86) function_call_params1 -> . COMMA function_call_params0
    (87) function_call_params1 -> . empty
    (141) empty -> .

    COMMA           shift and go to state 169
    RPAREN          reduce using rule 141 (empty -> .)

    function_call_params1          shift and go to state 168
    empty                          shift and go to state 170

state 124

    (84) function_call_params0 -> CONST_STRING . function_call_params1
    (86) function_call_params1 -> . COMMA function_call_params0
    (87) function_call_params1 -> . empty
    (141) empty -> .

    COMMA           shift and go to state 169
    RPAREN          reduce using rule 141 (empty -> .)

    function_call_params1          shift and go to state 171
    empty                          shift and go to state 170

state 125

    (85) function_call_params0 -> empty . function_call_params1
    (86) function_call_params1 -> . COMMA function_call_params0
    (87) function_call_params1 -> . empty
    (141) empty -> .

    COMMA           shift and go to state 169
    RPAREN          reduce using rule 141 (empty -> .)

    empty                          shift and go to state 170
    function_call_params1          shift and go to state 172

state 126

    (93) expression2 -> LTHAN expression3 .

    SEMICOLON       reduce using rule 93 (expression2 -> LTHAN expression3 .)
    COMMA           reduce using rule 93 (expression2 -> LTHAN expression3 .)
    RPAREN          reduce using rule 93 (expression2 -> LTHAN expression3 .)
=======
    (20) function0 -> DEF id_def LPAREN params0 . RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope

    RPAREN          shift and go to state 173


state 124

    (42) params0 -> type . ID params1

    ID              shift and go to state 174


state 125

    (43) params0 -> empty .

    RPAREN          reduce using rule 43 (params0 -> empty .)


state 126

    (26) declaration0 -> decl_id_def COLON declaration1 SEMICOLON .

    CLASS           reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
    DEF             reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
    ID              reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
    IF              reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
    WRITE           reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
    READ            reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
    RETURN          reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
    WHILE           reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
    MAIN            reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
    RBRACKET        reduce using rule 26 (declaration0 -> decl_id_def COLON declaration1 SEMICOLON .)
>>>>>>> Stashed changes


state 127

<<<<<<< Updated upstream
    (97) expression3 -> exp0 .

    SEMICOLON       reduce using rule 97 (expression3 -> exp0 .)
    COMMA           reduce using rule 97 (expression3 -> exp0 .)
    RPAREN          reduce using rule 97 (expression3 -> exp0 .)


state 128

    (98) expression3 -> CONST_BOOL .
=======
    (30) declaration1 -> type LSQRBRACKET . exp0 RSQRBRACKET declaration2
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 175
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 128

    (113) condition0 -> IF LPAREN expression0 RPAREN . block0 condition1 SEMICOLON
    (127) block0 -> . LBRACKET block1 RBRACKET

    LBRACKET        shift and go to state 177

    block0                         shift and go to state 176
>>>>>>> Stashed changes

    SEMICOLON       reduce using rule 98 (expression3 -> CONST_BOOL .)
    COMMA           reduce using rule 98 (expression3 -> CONST_BOOL .)
    RPAREN          reduce using rule 98 (expression3 -> CONST_BOOL .)

<<<<<<< Updated upstream

state 129
=======
    (116) writing0 -> WRITE push_writing_op LPAREN writing1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 178
>>>>>>> Stashed changes

    (99) expression3 -> attr_access0 .
    (72) power0 -> attr_access0 . power2
    (76) power2 -> . POWER power0
    (77) power2 -> . SQRT power0
    (78) power2 -> . empty
    (141) empty -> .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 99 (expression3 -> attr_access0 .)
  ! reduce/reduce conflict for COMMA resolved using rule 99 (expression3 -> attr_access0 .)
  ! reduce/reduce conflict for RPAREN resolved using rule 99 (expression3 -> attr_access0 .)
    SEMICOLON       reduce using rule 99 (expression3 -> attr_access0 .)
    COMMA           reduce using rule 99 (expression3 -> attr_access0 .)
    RPAREN          reduce using rule 99 (expression3 -> attr_access0 .)
    POWER           shift and go to state 74
    SQRT            shift and go to state 75
    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)

  ! SEMICOLON       [ reduce using rule 141 (empty -> .) ]
  ! COMMA           [ reduce using rule 141 (empty -> .) ]
  ! RPAREN          [ reduce using rule 141 (empty -> .) ]

    power2                         shift and go to state 72
    empty                          shift and go to state 88

state 130

<<<<<<< Updated upstream
    (94) expression2 -> GTHAN expression3 .

    SEMICOLON       reduce using rule 94 (expression2 -> GTHAN expression3 .)
    COMMA           reduce using rule 94 (expression2 -> GTHAN expression3 .)
    RPAREN          reduce using rule 94 (expression2 -> GTHAN expression3 .)
=======
    (119) writing1 -> expression0 . writing2
    (121) writing2 -> . COMMA writing1
    (122) writing2 -> . empty
    (145) empty -> .

    COMMA           shift and go to state 180
    RPAREN          reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    writing2                       shift and go to state 179
    empty                          shift and go to state 181

state 131

<<<<<<< Updated upstream
    (95) expression2 -> DIFFERENT expression3 .

    SEMICOLON       reduce using rule 95 (expression2 -> DIFFERENT expression3 .)
    COMMA           reduce using rule 95 (expression2 -> DIFFERENT expression3 .)
    RPAREN          reduce using rule 95 (expression2 -> DIFFERENT expression3 .)
=======
    (120) writing1 -> CONST_STRING . push_string_val writing2
    (118) push_string_val -> .

    COMMA           reduce using rule 118 (push_string_val -> .)
    RPAREN          reduce using rule 118 (push_string_val -> .)
>>>>>>> Stashed changes

    push_string_val                shift and go to state 182

state 132

<<<<<<< Updated upstream
    (96) expression2 -> EQUIVALENT expression3 .

    SEMICOLON       reduce using rule 96 (expression2 -> EQUIVALENT expression3 .)
    COMMA           reduce using rule 96 (expression2 -> EQUIVALENT expression3 .)
    RPAREN          reduce using rule 96 (expression2 -> EQUIVALENT expression3 .)


state 133

    (76) power2 -> POWER power0 .

    MULTIPLY        reduce using rule 76 (power2 -> POWER power0 .)
    DIVIDE          reduce using rule 76 (power2 -> POWER power0 .)
    PLUS            reduce using rule 76 (power2 -> POWER power0 .)
    MINUS           reduce using rule 76 (power2 -> POWER power0 .)
    LTHAN           reduce using rule 76 (power2 -> POWER power0 .)
    GTHAN           reduce using rule 76 (power2 -> POWER power0 .)
    DIFFERENT       reduce using rule 76 (power2 -> POWER power0 .)
    EQUIVALENT      reduce using rule 76 (power2 -> POWER power0 .)
    SEMICOLON       reduce using rule 76 (power2 -> POWER power0 .)
    COMMA           reduce using rule 76 (power2 -> POWER power0 .)
    RPAREN          reduce using rule 76 (power2 -> POWER power0 .)
    RSQRBRACKET     reduce using rule 76 (power2 -> POWER power0 .)


state 134

    (77) power2 -> SQRT power0 .

    MULTIPLY        reduce using rule 77 (power2 -> SQRT power0 .)
    DIVIDE          reduce using rule 77 (power2 -> SQRT power0 .)
    PLUS            reduce using rule 77 (power2 -> SQRT power0 .)
    MINUS           reduce using rule 77 (power2 -> SQRT power0 .)
    LTHAN           reduce using rule 77 (power2 -> SQRT power0 .)
    GTHAN           reduce using rule 77 (power2 -> SQRT power0 .)
    DIFFERENT       reduce using rule 77 (power2 -> SQRT power0 .)
    EQUIVALENT      reduce using rule 77 (power2 -> SQRT power0 .)
    SEMICOLON       reduce using rule 77 (power2 -> SQRT power0 .)
    COMMA           reduce using rule 77 (power2 -> SQRT power0 .)
    RPAREN          reduce using rule 77 (power2 -> SQRT power0 .)
    RSQRBRACKET     reduce using rule 77 (power2 -> SQRT power0 .)


state 135

    (58) exp1 -> PLUS exp0 .

    LTHAN           reduce using rule 58 (exp1 -> PLUS exp0 .)
    GTHAN           reduce using rule 58 (exp1 -> PLUS exp0 .)
    DIFFERENT       reduce using rule 58 (exp1 -> PLUS exp0 .)
    EQUIVALENT      reduce using rule 58 (exp1 -> PLUS exp0 .)
    SEMICOLON       reduce using rule 58 (exp1 -> PLUS exp0 .)
    RSQRBRACKET     reduce using rule 58 (exp1 -> PLUS exp0 .)
    RPAREN          reduce using rule 58 (exp1 -> PLUS exp0 .)
    COMMA           reduce using rule 58 (exp1 -> PLUS exp0 .)


state 136

    (59) exp1 -> MINUS exp0 .

    LTHAN           reduce using rule 59 (exp1 -> MINUS exp0 .)
    GTHAN           reduce using rule 59 (exp1 -> MINUS exp0 .)
    DIFFERENT       reduce using rule 59 (exp1 -> MINUS exp0 .)
    EQUIVALENT      reduce using rule 59 (exp1 -> MINUS exp0 .)
    SEMICOLON       reduce using rule 59 (exp1 -> MINUS exp0 .)
    RSQRBRACKET     reduce using rule 59 (exp1 -> MINUS exp0 .)
    RPAREN          reduce using rule 59 (exp1 -> MINUS exp0 .)
    COMMA           reduce using rule 59 (exp1 -> MINUS exp0 .)
=======
    (92) expression1 -> LTHAN push_rel_op . expression3
    (99) expression3 -> . exp0 check_rel_operator
    (100) expression3 -> . attr_access0
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    expression3                    shift and go to state 183
    exp0                           shift and go to state 184
    attr_access0                   shift and go to state 185
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 133

    (93) expression1 -> GTHAN push_rel_op . expression3
    (99) expression3 -> . exp0 check_rel_operator
    (100) expression3 -> . attr_access0
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    expression3                    shift and go to state 186
    exp0                           shift and go to state 184
    attr_access0                   shift and go to state 185
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 134

    (94) expression1 -> DIFFERENT push_rel_op . expression3
    (99) expression3 -> . exp0 check_rel_operator
    (100) expression3 -> . attr_access0
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    expression3                    shift and go to state 187
    exp0                           shift and go to state 184
    attr_access0                   shift and go to state 185
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 135

    (95) expression1 -> EQUIVALENT push_rel_op . expression3
    (99) expression3 -> . exp0 check_rel_operator
    (100) expression3 -> . attr_access0
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    expression3                    shift and go to state 188
    exp0                           shift and go to state 184
    attr_access0                   shift and go to state 185
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 136

    (72) power0 -> attr_access0 check_pow_rad_operator power2 .

    MULTIPLY        reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    DIVIDE          reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    PLUS            reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    MINUS           reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    LTHAN           reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    GTHAN           reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    DIFFERENT       reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    EQUIVALENT      reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    SEMICOLON       reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    RSQRBRACKET     reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    COMMA           reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
    RPAREN          reduce using rule 72 (power0 -> attr_access0 check_pow_rad_operator power2 .)
>>>>>>> Stashed changes


state 137

<<<<<<< Updated upstream
    (62) term1 -> MULTIPLY term0 .

    PLUS            reduce using rule 62 (term1 -> MULTIPLY term0 .)
    MINUS           reduce using rule 62 (term1 -> MULTIPLY term0 .)
    LTHAN           reduce using rule 62 (term1 -> MULTIPLY term0 .)
    GTHAN           reduce using rule 62 (term1 -> MULTIPLY term0 .)
    DIFFERENT       reduce using rule 62 (term1 -> MULTIPLY term0 .)
    EQUIVALENT      reduce using rule 62 (term1 -> MULTIPLY term0 .)
    SEMICOLON       reduce using rule 62 (term1 -> MULTIPLY term0 .)
    RSQRBRACKET     reduce using rule 62 (term1 -> MULTIPLY term0 .)
    RPAREN          reduce using rule 62 (term1 -> MULTIPLY term0 .)
    COMMA           reduce using rule 62 (term1 -> MULTIPLY term0 .)
=======
    (76) power2 -> POWER . push_pow_rad_op power0
    (79) push_pow_rad_op -> .

    LPAREN          reduce using rule 79 (push_pow_rad_op -> .)
    ID              reduce using rule 79 (push_pow_rad_op -> .)
    CONST_INT       reduce using rule 79 (push_pow_rad_op -> .)
    CONST_FLOAT     reduce using rule 79 (push_pow_rad_op -> .)
>>>>>>> Stashed changes

    push_pow_rad_op                shift and go to state 189

state 138

<<<<<<< Updated upstream
    (63) term1 -> DIVIDE term0 .

    PLUS            reduce using rule 63 (term1 -> DIVIDE term0 .)
    MINUS           reduce using rule 63 (term1 -> DIVIDE term0 .)
    LTHAN           reduce using rule 63 (term1 -> DIVIDE term0 .)
    GTHAN           reduce using rule 63 (term1 -> DIVIDE term0 .)
    DIFFERENT       reduce using rule 63 (term1 -> DIVIDE term0 .)
    EQUIVALENT      reduce using rule 63 (term1 -> DIVIDE term0 .)
    SEMICOLON       reduce using rule 63 (term1 -> DIVIDE term0 .)
    RSQRBRACKET     reduce using rule 63 (term1 -> DIVIDE term0 .)
    RPAREN          reduce using rule 63 (term1 -> DIVIDE term0 .)
    COMMA           reduce using rule 63 (term1 -> DIVIDE term0 .)
=======
    (77) power2 -> SQRT . push_pow_rad_op power0
    (79) push_pow_rad_op -> .

    LPAREN          reduce using rule 79 (push_pow_rad_op -> .)
    ID              reduce using rule 79 (push_pow_rad_op -> .)
    CONST_INT       reduce using rule 79 (push_pow_rad_op -> .)
    CONST_FLOAT     reduce using rule 79 (push_pow_rad_op -> .)
>>>>>>> Stashed changes

    push_pow_rad_op                shift and go to state 190

state 139

<<<<<<< Updated upstream
    (68) power0 -> LPAREN exp0 RPAREN . power2
    (76) power2 -> . POWER power0
    (77) power2 -> . SQRT power0
    (78) power2 -> . empty
    (141) empty -> .

    POWER           shift and go to state 74
    SQRT            shift and go to state 75
    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    LTHAN           reduce using rule 141 (empty -> .)
    GTHAN           reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    EQUIVALENT      reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    RSQRBRACKET     reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)

    power2                         shift and go to state 173
    empty                          shift and go to state 88

state 140

    (28) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET . exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (57) exp0 -> . term0 exp1
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 174
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 141

    (27) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS . expression0 SEMICOLON
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 35
    expression0                    shift and go to state 175
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 142

    (137) main0 -> MAIN LBRACKET main1 RBRACKET .

    $end            reduce using rule 137 (main0 -> MAIN LBRACKET main1 RBRACKET .)
=======
    (78) power2 -> empty .

    MULTIPLY        reduce using rule 78 (power2 -> empty .)
    DIVIDE          reduce using rule 78 (power2 -> empty .)
    PLUS            reduce using rule 78 (power2 -> empty .)
    MINUS           reduce using rule 78 (power2 -> empty .)
    LTHAN           reduce using rule 78 (power2 -> empty .)
    GTHAN           reduce using rule 78 (power2 -> empty .)
    DIFFERENT       reduce using rule 78 (power2 -> empty .)
    EQUIVALENT      reduce using rule 78 (power2 -> empty .)
    SEMICOLON       reduce using rule 78 (power2 -> empty .)
    RSQRBRACKET     reduce using rule 78 (power2 -> empty .)
    COMMA           reduce using rule 78 (power2 -> empty .)
    RPAREN          reduce using rule 78 (power2 -> empty .)


state 140

    (56) exp0 -> term0 check_last_plus_minus_operator exp1 .

    LTHAN           reduce using rule 56 (exp0 -> term0 check_last_plus_minus_operator exp1 .)
    GTHAN           reduce using rule 56 (exp0 -> term0 check_last_plus_minus_operator exp1 .)
    DIFFERENT       reduce using rule 56 (exp0 -> term0 check_last_plus_minus_operator exp1 .)
    EQUIVALENT      reduce using rule 56 (exp0 -> term0 check_last_plus_minus_operator exp1 .)
    SEMICOLON       reduce using rule 56 (exp0 -> term0 check_last_plus_minus_operator exp1 .)
    RSQRBRACKET     reduce using rule 56 (exp0 -> term0 check_last_plus_minus_operator exp1 .)
    COMMA           reduce using rule 56 (exp0 -> term0 check_last_plus_minus_operator exp1 .)
    RPAREN          reduce using rule 56 (exp0 -> term0 check_last_plus_minus_operator exp1 .)


state 141

    (57) exp1 -> PLUS . push_plus_minus_op exp0
    (60) push_plus_minus_op -> .

    LPAREN          reduce using rule 60 (push_plus_minus_op -> .)
    ID              reduce using rule 60 (push_plus_minus_op -> .)
    CONST_INT       reduce using rule 60 (push_plus_minus_op -> .)
    CONST_FLOAT     reduce using rule 60 (push_plus_minus_op -> .)

    push_plus_minus_op             shift and go to state 191

state 142

    (58) exp1 -> MINUS . push_plus_minus_op exp0
    (60) push_plus_minus_op -> .

    LPAREN          reduce using rule 60 (push_plus_minus_op -> .)
    ID              reduce using rule 60 (push_plus_minus_op -> .)
    CONST_INT       reduce using rule 60 (push_plus_minus_op -> .)
    CONST_FLOAT     reduce using rule 60 (push_plus_minus_op -> .)
>>>>>>> Stashed changes

    push_plus_minus_op             shift and go to state 192

state 143

<<<<<<< Updated upstream
    (138) main1 -> declaration0 main1 .

    RBRACKET        reduce using rule 138 (main1 -> declaration0 main1 .)


state 144
=======
    (59) exp1 -> empty .

    LTHAN           reduce using rule 59 (exp1 -> empty .)
    GTHAN           reduce using rule 59 (exp1 -> empty .)
    DIFFERENT       reduce using rule 59 (exp1 -> empty .)
    EQUIVALENT      reduce using rule 59 (exp1 -> empty .)
    SEMICOLON       reduce using rule 59 (exp1 -> empty .)
    RSQRBRACKET     reduce using rule 59 (exp1 -> empty .)
    COMMA           reduce using rule 59 (exp1 -> empty .)
    RPAREN          reduce using rule 59 (exp1 -> empty .)


state 144

    (101) attr_access0 -> ID DOT ID .
    (84) function_call -> ID . LPAREN function_call_params0 RPAREN

    LTHAN           reduce using rule 101 (attr_access0 -> ID DOT ID .)
    GTHAN           reduce using rule 101 (attr_access0 -> ID DOT ID .)
    DIFFERENT       reduce using rule 101 (attr_access0 -> ID DOT ID .)
    EQUIVALENT      reduce using rule 101 (attr_access0 -> ID DOT ID .)
    POWER           reduce using rule 101 (attr_access0 -> ID DOT ID .)
    SQRT            reduce using rule 101 (attr_access0 -> ID DOT ID .)
    SEMICOLON       reduce using rule 101 (attr_access0 -> ID DOT ID .)
    MULTIPLY        reduce using rule 101 (attr_access0 -> ID DOT ID .)
    DIVIDE          reduce using rule 101 (attr_access0 -> ID DOT ID .)
    PLUS            reduce using rule 101 (attr_access0 -> ID DOT ID .)
    MINUS           reduce using rule 101 (attr_access0 -> ID DOT ID .)
    RSQRBRACKET     reduce using rule 101 (attr_access0 -> ID DOT ID .)
    COMMA           reduce using rule 101 (attr_access0 -> ID DOT ID .)
    RPAREN          reduce using rule 101 (attr_access0 -> ID DOT ID .)
    LPAREN          shift and go to state 32
>>>>>>> Stashed changes

    (139) main1 -> statement main1 .

    RBRACKET        reduce using rule 139 (main1 -> statement main1 .)

<<<<<<< Updated upstream

state 145

    (26) assignment0 -> ID EQUALS . expression0 SEMICOLON
    (136) object_assignment -> ID EQUALS . NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    NEW             shift and go to state 176
    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression0                    shift and go to state 34
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 146

    (101) method_call0 -> ID DOT . function_call
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN

    ID              shift and go to state 177
=======
    (73) power0 -> ID LSQRBRACKET exp0 . RSQRBRACKET check_pow_rad_operator power1 power2

    RSQRBRACKET     shift and go to state 193


state 146

    (62) term0 -> power0 check_last_times_division_operator term1 .

    PLUS            reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
    MINUS           reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
    LTHAN           reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
    GTHAN           reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
    DIFFERENT       reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
    EQUIVALENT      reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
    SEMICOLON       reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
    RSQRBRACKET     reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
    COMMA           reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
    RPAREN          reduce using rule 62 (term0 -> power0 check_last_times_division_operator term1 .)
>>>>>>> Stashed changes

    function_call                  shift and go to state 120

state 147

<<<<<<< Updated upstream
    (133) statement -> function_call SEMICOLON .

    ID              reduce using rule 133 (statement -> function_call SEMICOLON .)
    IF              reduce using rule 133 (statement -> function_call SEMICOLON .)
    WRITE           reduce using rule 133 (statement -> function_call SEMICOLON .)
    READ            reduce using rule 133 (statement -> function_call SEMICOLON .)
    RETURN          reduce using rule 133 (statement -> function_call SEMICOLON .)
    WHILE           reduce using rule 133 (statement -> function_call SEMICOLON .)
    RBRACKET        reduce using rule 133 (statement -> function_call SEMICOLON .)
=======
    (63) term1 -> MULTIPLY . push_times_division_op term0
    (66) push_times_division_op -> .

    LPAREN          reduce using rule 66 (push_times_division_op -> .)
    ID              reduce using rule 66 (push_times_division_op -> .)
    CONST_INT       reduce using rule 66 (push_times_division_op -> .)
    CONST_FLOAT     reduce using rule 66 (push_times_division_op -> .)
>>>>>>> Stashed changes

    push_times_division_op         shift and go to state 194

state 148

<<<<<<< Updated upstream
    (134) statement -> method_call0 SEMICOLON .

    ID              reduce using rule 134 (statement -> method_call0 SEMICOLON .)
    IF              reduce using rule 134 (statement -> method_call0 SEMICOLON .)
    WRITE           reduce using rule 134 (statement -> method_call0 SEMICOLON .)
    READ            reduce using rule 134 (statement -> method_call0 SEMICOLON .)
    RETURN          reduce using rule 134 (statement -> method_call0 SEMICOLON .)
    WHILE           reduce using rule 134 (statement -> method_call0 SEMICOLON .)
    RBRACKET        reduce using rule 134 (statement -> method_call0 SEMICOLON .)


state 149

    (112) condition0 -> IF LPAREN . expression0 RPAREN block0 condition1 SEMICOLON
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression0                    shift and go to state 178
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
=======
    (64) term1 -> DIVIDE . push_times_division_op term0
    (66) push_times_division_op -> .

    LPAREN          reduce using rule 66 (push_times_division_op -> .)
    ID              reduce using rule 66 (push_times_division_op -> .)
    CONST_INT       reduce using rule 66 (push_times_division_op -> .)
    CONST_FLOAT     reduce using rule 66 (push_times_division_op -> .)

    push_times_division_op         shift and go to state 195

state 149

    (65) term1 -> empty .
>>>>>>> Stashed changes

    PLUS            reduce using rule 65 (term1 -> empty .)
    MINUS           reduce using rule 65 (term1 -> empty .)
    LTHAN           reduce using rule 65 (term1 -> empty .)
    GTHAN           reduce using rule 65 (term1 -> empty .)
    DIFFERENT       reduce using rule 65 (term1 -> empty .)
    EQUIVALENT      reduce using rule 65 (term1 -> empty .)
    SEMICOLON       reduce using rule 65 (term1 -> empty .)
    RSQRBRACKET     reduce using rule 65 (term1 -> empty .)
    COMMA           reduce using rule 65 (term1 -> empty .)
    RPAREN          reduce using rule 65 (term1 -> empty .)

<<<<<<< Updated upstream
    (115) writing0 -> WRITE LPAREN . writing1 RPAREN SEMICOLON
    (116) writing1 -> . expression0 writing2
    (117) writing1 -> . CONST_STRING writing2
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 181
    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    writing1                       shift and go to state 179
    expression0                    shift and go to state 180
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 151

    (120) reading -> READ ID . SEMICOLON

    SEMICOLON       shift and go to state 182
=======

state 150

    (68) power0 -> LPAREN exp0 RPAREN . check_pow_rad_operator power2
    (80) check_pow_rad_operator -> .

    POWER           reduce using rule 80 (check_pow_rad_operator -> .)
    SQRT            reduce using rule 80 (check_pow_rad_operator -> .)
    MULTIPLY        reduce using rule 80 (check_pow_rad_operator -> .)
    DIVIDE          reduce using rule 80 (check_pow_rad_operator -> .)
    PLUS            reduce using rule 80 (check_pow_rad_operator -> .)
    MINUS           reduce using rule 80 (check_pow_rad_operator -> .)
    LTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    GTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    DIFFERENT       reduce using rule 80 (check_pow_rad_operator -> .)
    EQUIVALENT      reduce using rule 80 (check_pow_rad_operator -> .)
    SEMICOLON       reduce using rule 80 (check_pow_rad_operator -> .)
    RSQRBRACKET     reduce using rule 80 (check_pow_rad_operator -> .)
    COMMA           reduce using rule 80 (check_pow_rad_operator -> .)
    RPAREN          reduce using rule 80 (check_pow_rad_operator -> .)

    check_pow_rad_operator         shift and go to state 196

state 151

    (69) power0 -> const_var check_pow_rad_operator power2 .

    MULTIPLY        reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    DIVIDE          reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    PLUS            reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    MINUS           reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    LTHAN           reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    GTHAN           reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    DIFFERENT       reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    EQUIVALENT      reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    SEMICOLON       reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    RSQRBRACKET     reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    COMMA           reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
    RPAREN          reduce using rule 69 (power0 -> const_var check_pow_rad_operator power2 .)
>>>>>>> Stashed changes


state 152

<<<<<<< Updated upstream
    (121) return -> RETURN expression0 . SEMICOLON

    SEMICOLON       shift and go to state 183
=======
    (70) power0 -> function_call check_pow_rad_operator power2 .

    MULTIPLY        reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    DIVIDE          reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    PLUS            reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    MINUS           reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    LTHAN           reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    GTHAN           reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    DIFFERENT       reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    EQUIVALENT      reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    SEMICOLON       reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    RSQRBRACKET     reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    COMMA           reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
    RPAREN          reduce using rule 70 (power0 -> function_call check_pow_rad_operator power2 .)
>>>>>>> Stashed changes


state 153

<<<<<<< Updated upstream
    (122) return -> RETURN SEMICOLON .

    ID              reduce using rule 122 (return -> RETURN SEMICOLON .)
    IF              reduce using rule 122 (return -> RETURN SEMICOLON .)
    WRITE           reduce using rule 122 (return -> RETURN SEMICOLON .)
    READ            reduce using rule 122 (return -> RETURN SEMICOLON .)
    RETURN          reduce using rule 122 (return -> RETURN SEMICOLON .)
    WHILE           reduce using rule 122 (return -> RETURN SEMICOLON .)
    RBRACKET        reduce using rule 122 (return -> RETURN SEMICOLON .)
=======
    (71) power0 -> method_call0 check_pow_rad_operator power2 .

    MULTIPLY        reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    DIVIDE          reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    PLUS            reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    MINUS           reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    LTHAN           reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    GTHAN           reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    DIFFERENT       reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    EQUIVALENT      reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    SEMICOLON       reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    RSQRBRACKET     reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    COMMA           reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
    RPAREN          reduce using rule 71 (power0 -> method_call0 check_pow_rad_operator power2 .)
>>>>>>> Stashed changes


state 154

<<<<<<< Updated upstream
    (123) while -> WHILE LPAREN . expression0 RPAREN block0
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression0                    shift and go to state 184
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 155

    (48) simple_assignment -> ID . EQUALS expression0 SEMICOLON

    EQUALS          shift and go to state 185


state 156

    (7) class0 -> CLASS ID class1 LBRACKET class2 . constructor class3 RBRACKET SEMICOLON
    (29) constructor -> . CONSTRUCT ID LPAREN params0 RPAREN function_block0

    CONSTRUCT       shift and go to state 187

    constructor                    shift and go to state 186

state 157

    (10) class2 -> attributes .

    CONSTRUCT       reduce using rule 10 (class2 -> attributes .)


state 158

    (11) class2 -> empty .
    (33) attributes -> empty .

  ! reduce/reduce conflict for CONSTRUCT resolved using rule 11 (class2 -> empty .)
    CONSTRUCT       reduce using rule 11 (class2 -> empty .)

  ! CONSTRUCT       [ reduce using rule 33 (attributes -> empty .) ]
=======
    (126) while -> WHILE LPAREN expression0 RPAREN . block0
    (127) block0 -> . LBRACKET block1 RBRACKET

    LBRACKET        shift and go to state 177

    block0                         shift and go to state 197

state 155

    (139) object_assignment -> ID EQUALS NEW ID LPAREN . function_call_params0 RPAREN SEMICOLON
    (85) function_call_params0 -> . expression0 function_call_params1
    (86) function_call_params0 -> . CONST_STRING function_call_params1
    (87) function_call_params0 -> . empty function_call_params1
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (145) empty -> .
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 72
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)
    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    function_call_params0          shift and go to state 198
    expression0                    shift and go to state 71
    empty                          shift and go to state 73
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 156

    (35) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET . exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 199
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 157

    (34) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS . expression0 SEMICOLON
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 53
    expression0                    shift and go to state 200
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 158

    (88) function_call_params1 -> COMMA function_call_params0 .

    RPAREN          reduce using rule 88 (function_call_params1 -> COMMA function_call_params0 .)
>>>>>>> Stashed changes


state 159

<<<<<<< Updated upstream
    (31) attributes -> data_access . simple_declaration attributes
    (47) simple_declaration -> . ID COLON type SEMICOLON

    ID              shift and go to state 189

    simple_declaration             shift and go to state 188

state 160

    (32) attributes -> simple_assignment . attributes
    (31) attributes -> . data_access simple_declaration attributes
    (32) attributes -> . simple_assignment attributes
    (33) attributes -> . empty
    (102) data_access -> . PRIVATE
    (103) data_access -> . PUBLIC
    (48) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (141) empty -> .

    PRIVATE         shift and go to state 161
    PUBLIC          shift and go to state 162
    ID              shift and go to state 155
    CONSTRUCT       reduce using rule 141 (empty -> .)

    simple_assignment              shift and go to state 160
    attributes                     shift and go to state 190
    data_access                    shift and go to state 159
    empty                          shift and go to state 191

state 161

    (102) data_access -> PRIVATE .

    ID              reduce using rule 102 (data_access -> PRIVATE .)
    DEF             reduce using rule 102 (data_access -> PRIVATE .)


state 162

    (103) data_access -> PUBLIC .

    ID              reduce using rule 103 (data_access -> PUBLIC .)
    DEF             reduce using rule 103 (data_access -> PUBLIC .)
=======
    (140) main0 -> MAIN main_scope LBRACKET main1 . RBRACKET

    RBRACKET        shift and go to state 201


state 160

    (141) main1 -> declaration0 . main1
    (141) main1 -> . declaration0 main1
    (142) main1 -> . statement main1
    (143) main1 -> . empty
    (26) declaration0 -> . decl_id_def COLON declaration1 SEMICOLON
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (145) empty -> .
    (27) decl_id_def -> . ID
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 145 (empty -> .)
    ID              shift and go to state 164
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    declaration0                   shift and go to state 160
    main1                          shift and go to state 202
    statement                      shift and go to state 161
    empty                          shift and go to state 162
    decl_id_def                    shift and go to state 24
    assignment0                    shift and go to state 163
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21

state 161

    (142) main1 -> statement . main1
    (141) main1 -> . declaration0 main1
    (142) main1 -> . statement main1
    (143) main1 -> . empty
    (26) declaration0 -> . decl_id_def COLON declaration1 SEMICOLON
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (145) empty -> .
    (27) decl_id_def -> . ID
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 145 (empty -> .)
    ID              shift and go to state 164
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    statement                      shift and go to state 161
    main1                          shift and go to state 203
    declaration0                   shift and go to state 160
    empty                          shift and go to state 162
    decl_id_def                    shift and go to state 24
    assignment0                    shift and go to state 163
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21

state 162

    (143) main1 -> empty .

    RBRACKET        reduce using rule 143 (main1 -> empty .)
>>>>>>> Stashed changes


state 163

<<<<<<< Updated upstream
    (14) function0 -> DEF ID LPAREN params0 RPAREN . ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    ARROW           shift and go to state 192
=======
    (130) statement -> assignment0 .

    ID              reduce using rule 130 (statement -> assignment0 .)
    IF              reduce using rule 130 (statement -> assignment0 .)
    WRITE           reduce using rule 130 (statement -> assignment0 .)
    READ            reduce using rule 130 (statement -> assignment0 .)
    RETURN          reduce using rule 130 (statement -> assignment0 .)
    WHILE           reduce using rule 130 (statement -> assignment0 .)
    RBRACKET        reduce using rule 130 (statement -> assignment0 .)
>>>>>>> Stashed changes


state 164

<<<<<<< Updated upstream
    (36) params0 -> type ID . params1
    (38) params1 -> . COMMA params0
    (39) params1 -> . empty
    (141) empty -> .

    COMMA           shift and go to state 194
    RPAREN          reduce using rule 141 (empty -> .)
=======
    (27) decl_id_def -> ID .
    (33) assignment0 -> ID . EQUALS expression0 SEMICOLON
    (34) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (139) object_assignment -> ID . EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (84) function_call -> ID . LPAREN function_call_params0 RPAREN
    (102) method_call0 -> ID . DOT function_call

    COLON           reduce using rule 27 (decl_id_def -> ID .)
    EQUALS          shift and go to state 30
    LSQRBRACKET     shift and go to state 31
    LPAREN          shift and go to state 32
    DOT             shift and go to state 33
>>>>>>> Stashed changes

    params1                        shift and go to state 193
    empty                          shift and go to state 195

state 165

<<<<<<< Updated upstream
    (23) declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET . declaration2
    (24) declaration2 -> . LSQRBRACKET exp0 RSQRBRACKET
    (25) declaration2 -> . empty
    (141) empty -> .

    LSQRBRACKET     shift and go to state 196
    SEMICOLON       reduce using rule 141 (empty -> .)

    declaration2                   shift and go to state 197
    empty                          shift and go to state 198

state 166

    (73) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET . power1 power2
    (74) power1 -> . LSQRBRACKET exp0 RSQRBRACKET
    (75) power1 -> . empty
    (141) empty -> .

    LSQRBRACKET     shift and go to state 199
    POWER           reduce using rule 141 (empty -> .)
    SQRT            reduce using rule 141 (empty -> .)
    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    LTHAN           reduce using rule 141 (empty -> .)
    GTHAN           reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    EQUIVALENT      reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    RSQRBRACKET     reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)

    power1                         shift and go to state 200
    empty                          shift and go to state 201

state 167

    (82) function_call -> ID LPAREN function_call_params0 RPAREN .

    POWER           reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    SQRT            reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    MULTIPLY        reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    DIVIDE          reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    PLUS            reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    MINUS           reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    LTHAN           reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    GTHAN           reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    DIFFERENT       reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    EQUIVALENT      reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    SEMICOLON       reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    RSQRBRACKET     reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    RPAREN          reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
    COMMA           reduce using rule 82 (function_call -> ID LPAREN function_call_params0 RPAREN .)
=======
    (9) class0 -> CLASS class_id_def class1 LBRACKET class2 . constructor class3 RBRACKET SEMICOLON revert_global
    (36) constructor -> . CONSTRUCT ID LPAREN params0 RPAREN function_block0

    CONSTRUCT       shift and go to state 205

    constructor                    shift and go to state 204

state 166

    (16) class2 -> attributes .

    CONSTRUCT       reduce using rule 16 (class2 -> attributes .)


state 167

    (17) class2 -> empty .
    (39) attributes -> empty .

  ! reduce/reduce conflict for CONSTRUCT resolved using rule 17 (class2 -> empty .)
    CONSTRUCT       reduce using rule 17 (class2 -> empty .)

  ! CONSTRUCT       [ reduce using rule 39 (attributes -> empty .) ]
>>>>>>> Stashed changes


state 168

<<<<<<< Updated upstream
    (83) function_call_params0 -> expression0 function_call_params1 .

    RPAREN          reduce using rule 83 (function_call_params0 -> expression0 function_call_params1 .)
=======
    (37) attributes -> data_access . simple_declaration attributes
    (53) simple_declaration -> . ID COLON type SEMICOLON

    ID              shift and go to state 207
>>>>>>> Stashed changes

    simple_declaration             shift and go to state 206

state 169

<<<<<<< Updated upstream
    (86) function_call_params1 -> COMMA . function_call_params0
    (83) function_call_params0 -> . expression0 function_call_params1
    (84) function_call_params0 -> . CONST_STRING function_call_params1
    (85) function_call_params0 -> . empty function_call_params1
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (141) empty -> .
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 124
    CONST_BOOL      shift and go to state 36
    COMMA           reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    function_call_params0          shift and go to state 202
    expression0                    shift and go to state 123
    empty                          shift and go to state 125
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 170

    (87) function_call_params1 -> empty .

    RPAREN          reduce using rule 87 (function_call_params1 -> empty .)
=======
    (38) attributes -> simple_assignment . attributes
    (37) attributes -> . data_access simple_declaration attributes
    (38) attributes -> . simple_assignment attributes
    (39) attributes -> . empty
    (103) data_access -> . PRIVATE
    (104) data_access -> . PUBLIC
    (54) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (145) empty -> .

    PRIVATE         shift and go to state 170
    PUBLIC          shift and go to state 171
    ID              shift and go to state 172
    CONSTRUCT       reduce using rule 145 (empty -> .)

    simple_assignment              shift and go to state 169
    attributes                     shift and go to state 208
    data_access                    shift and go to state 168
    empty                          shift and go to state 209

state 170

    (103) data_access -> PRIVATE .

    ID              reduce using rule 103 (data_access -> PRIVATE .)
    DEF             reduce using rule 103 (data_access -> PRIVATE .)
>>>>>>> Stashed changes


state 171

<<<<<<< Updated upstream
    (84) function_call_params0 -> CONST_STRING function_call_params1 .

    RPAREN          reduce using rule 84 (function_call_params0 -> CONST_STRING function_call_params1 .)
=======
    (104) data_access -> PUBLIC .

    ID              reduce using rule 104 (data_access -> PUBLIC .)
    DEF             reduce using rule 104 (data_access -> PUBLIC .)
>>>>>>> Stashed changes


state 172

<<<<<<< Updated upstream
    (85) function_call_params0 -> empty function_call_params1 .

    RPAREN          reduce using rule 85 (function_call_params0 -> empty function_call_params1 .)
=======
    (54) simple_assignment -> ID . EQUALS expression0 SEMICOLON

    EQUALS          shift and go to state 210
>>>>>>> Stashed changes


state 173

<<<<<<< Updated upstream
    (68) power0 -> LPAREN exp0 RPAREN power2 .

    MULTIPLY        reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    DIVIDE          reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    PLUS            reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    MINUS           reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    LTHAN           reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    GTHAN           reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    DIFFERENT       reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    EQUIVALENT      reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    SEMICOLON       reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    RSQRBRACKET     reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    RPAREN          reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
    COMMA           reduce using rule 68 (power0 -> LPAREN exp0 RPAREN power2 .)
=======
    (20) function0 -> DEF id_def LPAREN params0 RPAREN . ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope

    ARROW           shift and go to state 211
>>>>>>> Stashed changes


state 174

<<<<<<< Updated upstream
    (28) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 . RSQRBRACKET EQUALS expression0 SEMICOLON

    RSQRBRACKET     shift and go to state 203


state 175

    (27) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 204
=======
    (42) params0 -> type ID . params1
    (44) params1 -> . COMMA params0
    (45) params1 -> . empty
    (145) empty -> .

    COMMA           shift and go to state 213
    RPAREN          reduce using rule 145 (empty -> .)

    params1                        shift and go to state 212
    empty                          shift and go to state 214

state 175

    (30) declaration1 -> type LSQRBRACKET exp0 . RSQRBRACKET declaration2

    RSQRBRACKET     shift and go to state 215
>>>>>>> Stashed changes


state 176

<<<<<<< Updated upstream
    (136) object_assignment -> ID EQUALS NEW . ID LPAREN function_call_params0 RPAREN SEMICOLON

    ID              shift and go to state 205
=======
    (113) condition0 -> IF LPAREN expression0 RPAREN block0 . condition1 SEMICOLON
    (114) condition1 -> . ELSE block0
    (115) condition1 -> . empty
    (145) empty -> .

    ELSE            shift and go to state 217
    SEMICOLON       reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    condition1                     shift and go to state 216
    empty                          shift and go to state 218

state 177

<<<<<<< Updated upstream
    (82) function_call -> ID . LPAREN function_call_params0 RPAREN

    LPAREN          shift and go to state 61
=======
    (127) block0 -> LBRACKET . block1 RBRACKET
    (128) block1 -> . statement block1
    (129) block1 -> . empty
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (145) empty -> .
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 145 (empty -> .)
    ID              shift and go to state 222
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    block1                         shift and go to state 219
    statement                      shift and go to state 220
    empty                          shift and go to state 221
    assignment0                    shift and go to state 163
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21

state 178
>>>>>>> Stashed changes

    (116) writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 223

<<<<<<< Updated upstream
    (112) condition0 -> IF LPAREN expression0 . RPAREN block0 condition1 SEMICOLON

    RPAREN          shift and go to state 206


state 179

    (115) writing0 -> WRITE LPAREN writing1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 207
=======

state 179

    (119) writing1 -> expression0 writing2 .

    RPAREN          reduce using rule 119 (writing1 -> expression0 writing2 .)
>>>>>>> Stashed changes


state 180

<<<<<<< Updated upstream
    (116) writing1 -> expression0 . writing2
    (118) writing2 -> . COMMA writing1
    (119) writing2 -> . empty
    (141) empty -> .

    COMMA           shift and go to state 209
    RPAREN          reduce using rule 141 (empty -> .)

    writing2                       shift and go to state 208
    empty                          shift and go to state 210
=======
    (121) writing2 -> COMMA . writing1
    (119) writing1 -> . expression0 writing2
    (120) writing1 -> . CONST_STRING push_string_val writing2
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 131
    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    writing1                       shift and go to state 224
    expression0                    shift and go to state 130
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 181

    (122) writing2 -> empty .
>>>>>>> Stashed changes

    RPAREN          reduce using rule 122 (writing2 -> empty .)

<<<<<<< Updated upstream
    (117) writing1 -> CONST_STRING . writing2
    (118) writing2 -> . COMMA writing1
    (119) writing2 -> . empty
    (141) empty -> .

    COMMA           shift and go to state 209
    RPAREN          reduce using rule 141 (empty -> .)

    writing2                       shift and go to state 211
    empty                          shift and go to state 210

state 182

    (120) reading -> READ ID SEMICOLON .

    ID              reduce using rule 120 (reading -> READ ID SEMICOLON .)
    IF              reduce using rule 120 (reading -> READ ID SEMICOLON .)
    WRITE           reduce using rule 120 (reading -> READ ID SEMICOLON .)
    READ            reduce using rule 120 (reading -> READ ID SEMICOLON .)
    RETURN          reduce using rule 120 (reading -> READ ID SEMICOLON .)
    WHILE           reduce using rule 120 (reading -> READ ID SEMICOLON .)
    RBRACKET        reduce using rule 120 (reading -> READ ID SEMICOLON .)
=======

state 182

    (120) writing1 -> CONST_STRING push_string_val . writing2
    (121) writing2 -> . COMMA writing1
    (122) writing2 -> . empty
    (145) empty -> .

    COMMA           shift and go to state 180
    RPAREN          reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    writing2                       shift and go to state 225
    empty                          shift and go to state 181

state 183

<<<<<<< Updated upstream
    (121) return -> RETURN expression0 SEMICOLON .

    ID              reduce using rule 121 (return -> RETURN expression0 SEMICOLON .)
    IF              reduce using rule 121 (return -> RETURN expression0 SEMICOLON .)
    WRITE           reduce using rule 121 (return -> RETURN expression0 SEMICOLON .)
    READ            reduce using rule 121 (return -> RETURN expression0 SEMICOLON .)
    RETURN          reduce using rule 121 (return -> RETURN expression0 SEMICOLON .)
    WHILE           reduce using rule 121 (return -> RETURN expression0 SEMICOLON .)
    RBRACKET        reduce using rule 121 (return -> RETURN expression0 SEMICOLON .)
=======
    (92) expression1 -> LTHAN push_rel_op expression3 .

    SEMICOLON       reduce using rule 92 (expression1 -> LTHAN push_rel_op expression3 .)
    COMMA           reduce using rule 92 (expression1 -> LTHAN push_rel_op expression3 .)
    RPAREN          reduce using rule 92 (expression1 -> LTHAN push_rel_op expression3 .)
>>>>>>> Stashed changes


state 184

<<<<<<< Updated upstream
    (123) while -> WHILE LPAREN expression0 . RPAREN block0

    RPAREN          shift and go to state 212
=======
    (99) expression3 -> exp0 . check_rel_operator
    (98) check_rel_operator -> .

    SEMICOLON       reduce using rule 98 (check_rel_operator -> .)
    COMMA           reduce using rule 98 (check_rel_operator -> .)
    RPAREN          reduce using rule 98 (check_rel_operator -> .)
>>>>>>> Stashed changes

    check_rel_operator             shift and go to state 226

state 185

<<<<<<< Updated upstream
    (48) simple_assignment -> ID EQUALS . expression0 SEMICOLON
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    expression0                    shift and go to state 213
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 186

    (7) class0 -> CLASS ID class1 LBRACKET class2 constructor . class3 RBRACKET SEMICOLON
    (12) class3 -> . methods
    (13) class3 -> . empty
    (34) methods -> . data_access function0 methods
    (35) methods -> . empty
    (141) empty -> .
    (102) data_access -> . PRIVATE
    (103) data_access -> . PUBLIC

    RBRACKET        reduce using rule 141 (empty -> .)
    PRIVATE         shift and go to state 161
    PUBLIC          shift and go to state 162

    class3                         shift and go to state 214
    methods                        shift and go to state 215
    empty                          shift and go to state 216
    data_access                    shift and go to state 217

state 187

    (29) constructor -> CONSTRUCT . ID LPAREN params0 RPAREN function_block0

    ID              shift and go to state 218
=======
    (100) expression3 -> attr_access0 .
    (72) power0 -> attr_access0 . check_pow_rad_operator power2
    (80) check_pow_rad_operator -> .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 80 (check_pow_rad_operator -> .)
  ! reduce/reduce conflict for COMMA resolved using rule 80 (check_pow_rad_operator -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 80 (check_pow_rad_operator -> .)
    POWER           reduce using rule 80 (check_pow_rad_operator -> .)
    SQRT            reduce using rule 80 (check_pow_rad_operator -> .)
    MULTIPLY        reduce using rule 80 (check_pow_rad_operator -> .)
    DIVIDE          reduce using rule 80 (check_pow_rad_operator -> .)
    PLUS            reduce using rule 80 (check_pow_rad_operator -> .)
    MINUS           reduce using rule 80 (check_pow_rad_operator -> .)
    SEMICOLON       reduce using rule 80 (check_pow_rad_operator -> .)
    COMMA           reduce using rule 80 (check_pow_rad_operator -> .)
    RPAREN          reduce using rule 80 (check_pow_rad_operator -> .)

  ! SEMICOLON       [ reduce using rule 100 (expression3 -> attr_access0 .) ]
  ! COMMA           [ reduce using rule 100 (expression3 -> attr_access0 .) ]
  ! RPAREN          [ reduce using rule 100 (expression3 -> attr_access0 .) ]

    check_pow_rad_operator         shift and go to state 100

state 186

    (93) expression1 -> GTHAN push_rel_op expression3 .

    SEMICOLON       reduce using rule 93 (expression1 -> GTHAN push_rel_op expression3 .)
    COMMA           reduce using rule 93 (expression1 -> GTHAN push_rel_op expression3 .)
    RPAREN          reduce using rule 93 (expression1 -> GTHAN push_rel_op expression3 .)


state 187

    (94) expression1 -> DIFFERENT push_rel_op expression3 .

    SEMICOLON       reduce using rule 94 (expression1 -> DIFFERENT push_rel_op expression3 .)
    COMMA           reduce using rule 94 (expression1 -> DIFFERENT push_rel_op expression3 .)
    RPAREN          reduce using rule 94 (expression1 -> DIFFERENT push_rel_op expression3 .)
>>>>>>> Stashed changes


state 188

<<<<<<< Updated upstream
    (31) attributes -> data_access simple_declaration . attributes
    (31) attributes -> . data_access simple_declaration attributes
    (32) attributes -> . simple_assignment attributes
    (33) attributes -> . empty
    (102) data_access -> . PRIVATE
    (103) data_access -> . PUBLIC
    (48) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (141) empty -> .

    PRIVATE         shift and go to state 161
    PUBLIC          shift and go to state 162
    ID              shift and go to state 155
    CONSTRUCT       reduce using rule 141 (empty -> .)

    data_access                    shift and go to state 159
    attributes                     shift and go to state 219
    simple_assignment              shift and go to state 160
    empty                          shift and go to state 191
=======
    (95) expression1 -> EQUIVALENT push_rel_op expression3 .
>>>>>>> Stashed changes

    SEMICOLON       reduce using rule 95 (expression1 -> EQUIVALENT push_rel_op expression3 .)
    COMMA           reduce using rule 95 (expression1 -> EQUIVALENT push_rel_op expression3 .)
    RPAREN          reduce using rule 95 (expression1 -> EQUIVALENT push_rel_op expression3 .)

<<<<<<< Updated upstream
    (47) simple_declaration -> ID . COLON type SEMICOLON

    COLON           shift and go to state 220
=======

state 189
>>>>>>> Stashed changes

    (76) power2 -> POWER push_pow_rad_op . power0
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    power0                         shift and go to state 227
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 190

<<<<<<< Updated upstream
    (32) attributes -> simple_assignment attributes .

    CONSTRUCT       reduce using rule 32 (attributes -> simple_assignment attributes .)


state 191

    (33) attributes -> empty .

    CONSTRUCT       reduce using rule 33 (attributes -> empty .)


state 192

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW . function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0
    (15) function1 -> . type
    (16) function1 -> . VOID
    (43) type -> . INT
    (44) type -> . FLOAT
    (45) type -> . STRING
    (46) type -> . BOOL
=======
    (77) power2 -> SQRT push_pow_rad_op . power0
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    power0                         shift and go to state 228
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 191

    (57) exp1 -> PLUS push_plus_minus_op . exp0
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 229
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 192

    (58) exp1 -> MINUS push_plus_minus_op . exp0
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 230
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69
>>>>>>> Stashed changes

    VOID            shift and go to state 223
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    STRING          shift and go to state 31
    BOOL            shift and go to state 32

<<<<<<< Updated upstream
    function1                      shift and go to state 221
    type                           shift and go to state 222

state 193

    (36) params0 -> type ID params1 .
=======
    (73) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET . check_pow_rad_operator power1 power2
    (80) check_pow_rad_operator -> .

    LSQRBRACKET     reduce using rule 80 (check_pow_rad_operator -> .)
    POWER           reduce using rule 80 (check_pow_rad_operator -> .)
    SQRT            reduce using rule 80 (check_pow_rad_operator -> .)
    MULTIPLY        reduce using rule 80 (check_pow_rad_operator -> .)
    DIVIDE          reduce using rule 80 (check_pow_rad_operator -> .)
    PLUS            reduce using rule 80 (check_pow_rad_operator -> .)
    MINUS           reduce using rule 80 (check_pow_rad_operator -> .)
    LTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    GTHAN           reduce using rule 80 (check_pow_rad_operator -> .)
    DIFFERENT       reduce using rule 80 (check_pow_rad_operator -> .)
    EQUIVALENT      reduce using rule 80 (check_pow_rad_operator -> .)
    SEMICOLON       reduce using rule 80 (check_pow_rad_operator -> .)
    RSQRBRACKET     reduce using rule 80 (check_pow_rad_operator -> .)
    COMMA           reduce using rule 80 (check_pow_rad_operator -> .)
    RPAREN          reduce using rule 80 (check_pow_rad_operator -> .)

    check_pow_rad_operator         shift and go to state 231
>>>>>>> Stashed changes

    RPAREN          reduce using rule 36 (params0 -> type ID params1 .)

<<<<<<< Updated upstream

state 194

    (38) params1 -> COMMA . params0
    (36) params0 -> . type ID params1
    (37) params0 -> . empty
    (43) type -> . INT
    (44) type -> . FLOAT
    (45) type -> . STRING
    (46) type -> . BOOL
    (141) empty -> .

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    STRING          shift and go to state 31
    BOOL            shift and go to state 32
    RPAREN          reduce using rule 141 (empty -> .)

    params0                        shift and go to state 224
    type                           shift and go to state 116
    empty                          shift and go to state 117

state 195

    (39) params1 -> empty .

    RPAREN          reduce using rule 39 (params1 -> empty .)


state 196

    (24) declaration2 -> LSQRBRACKET . exp0 RSQRBRACKET
    (57) exp0 -> . term0 exp1
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 225
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 197

    (23) declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET declaration2 .

    SEMICOLON       reduce using rule 23 (declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET declaration2 .)
=======
    (63) term1 -> MULTIPLY push_times_division_op . term0
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    term0                          shift and go to state 232
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 195

    (64) term1 -> DIVIDE push_times_division_op . term0
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    term0                          shift and go to state 233
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 196

    (68) power0 -> LPAREN exp0 RPAREN check_pow_rad_operator . power2
    (76) power2 -> . POWER push_pow_rad_op power0
    (77) power2 -> . SQRT push_pow_rad_op power0
    (78) power2 -> . empty
    (145) empty -> .

    POWER           shift and go to state 137
    SQRT            shift and go to state 138
    MULTIPLY        reduce using rule 145 (empty -> .)
    DIVIDE          reduce using rule 145 (empty -> .)
    PLUS            reduce using rule 145 (empty -> .)
    MINUS           reduce using rule 145 (empty -> .)
    LTHAN           reduce using rule 145 (empty -> .)
    GTHAN           reduce using rule 145 (empty -> .)
    DIFFERENT       reduce using rule 145 (empty -> .)
    EQUIVALENT      reduce using rule 145 (empty -> .)
    SEMICOLON       reduce using rule 145 (empty -> .)
    RSQRBRACKET     reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)

    power2                         shift and go to state 234
    empty                          shift and go to state 139

state 197

    (126) while -> WHILE LPAREN expression0 RPAREN block0 .

    CLASS           reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    DEF             reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    ID              reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    IF              reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    WRITE           reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    READ            reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    RETURN          reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    WHILE           reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    MAIN            reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    RBRACKET        reduce using rule 126 (while -> WHILE LPAREN expression0 RPAREN block0 .)
>>>>>>> Stashed changes


state 198

<<<<<<< Updated upstream
    (25) declaration2 -> empty .

    SEMICOLON       reduce using rule 25 (declaration2 -> empty .)
=======
    (139) object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 . RPAREN SEMICOLON

    RPAREN          shift and go to state 235
>>>>>>> Stashed changes


state 199

<<<<<<< Updated upstream
    (74) power1 -> LSQRBRACKET . exp0 RSQRBRACKET
    (57) exp0 -> . term0 exp1
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (100) attr_access0 -> . ID DOT ID

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    ID              shift and go to state 49
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 226
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46
    attr_access0                   shift and go to state 51

state 200

    (73) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 . power2
    (76) power2 -> . POWER power0
    (77) power2 -> . SQRT power0
    (78) power2 -> . empty
    (141) empty -> .

    POWER           shift and go to state 74
    SQRT            shift and go to state 75
    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    LTHAN           reduce using rule 141 (empty -> .)
    GTHAN           reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    EQUIVALENT      reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    RSQRBRACKET     reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    COMMA           reduce using rule 141 (empty -> .)

    power2                         shift and go to state 227
    empty                          shift and go to state 88

state 201

    (75) power1 -> empty .

    POWER           reduce using rule 75 (power1 -> empty .)
    SQRT            reduce using rule 75 (power1 -> empty .)
    MULTIPLY        reduce using rule 75 (power1 -> empty .)
    DIVIDE          reduce using rule 75 (power1 -> empty .)
    PLUS            reduce using rule 75 (power1 -> empty .)
    MINUS           reduce using rule 75 (power1 -> empty .)
    LTHAN           reduce using rule 75 (power1 -> empty .)
    GTHAN           reduce using rule 75 (power1 -> empty .)
    DIFFERENT       reduce using rule 75 (power1 -> empty .)
    EQUIVALENT      reduce using rule 75 (power1 -> empty .)
    SEMICOLON       reduce using rule 75 (power1 -> empty .)
    RSQRBRACKET     reduce using rule 75 (power1 -> empty .)
    RPAREN          reduce using rule 75 (power1 -> empty .)
    COMMA           reduce using rule 75 (power1 -> empty .)
=======
    (35) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 . RSQRBRACKET EQUALS expression0 SEMICOLON

    RSQRBRACKET     shift and go to state 236


state 200

    (34) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 237


state 201

    (140) main0 -> MAIN main_scope LBRACKET main1 RBRACKET .

    $end            reduce using rule 140 (main0 -> MAIN main_scope LBRACKET main1 RBRACKET .)
>>>>>>> Stashed changes


state 202

<<<<<<< Updated upstream
    (86) function_call_params1 -> COMMA function_call_params0 .

    RPAREN          reduce using rule 86 (function_call_params1 -> COMMA function_call_params0 .)
=======
    (141) main1 -> declaration0 main1 .

    RBRACKET        reduce using rule 141 (main1 -> declaration0 main1 .)
>>>>>>> Stashed changes


state 203

<<<<<<< Updated upstream
    (28) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET . EQUALS expression0 SEMICOLON

    EQUALS          shift and go to state 228
=======
    (142) main1 -> statement main1 .

    RBRACKET        reduce using rule 142 (main1 -> statement main1 .)
>>>>>>> Stashed changes


state 204

<<<<<<< Updated upstream
    (27) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .

    CLASS           reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    DEF             reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    MAIN            reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 27 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
=======
    (9) class0 -> CLASS class_id_def class1 LBRACKET class2 constructor . class3 RBRACKET SEMICOLON revert_global
    (18) class3 -> . methods
    (19) class3 -> . empty
    (40) methods -> . data_access function0 methods
    (41) methods -> . empty
    (145) empty -> .
    (103) data_access -> . PRIVATE
    (104) data_access -> . PUBLIC

    RBRACKET        reduce using rule 145 (empty -> .)
    PRIVATE         shift and go to state 170
    PUBLIC          shift and go to state 171
>>>>>>> Stashed changes

    class3                         shift and go to state 238
    methods                        shift and go to state 239
    empty                          shift and go to state 240
    data_access                    shift and go to state 241

state 205

<<<<<<< Updated upstream
    (136) object_assignment -> ID EQUALS NEW ID . LPAREN function_call_params0 RPAREN SEMICOLON

    LPAREN          shift and go to state 229
=======
    (36) constructor -> CONSTRUCT . ID LPAREN params0 RPAREN function_block0

    ID              shift and go to state 242
>>>>>>> Stashed changes


state 206

<<<<<<< Updated upstream
    (112) condition0 -> IF LPAREN expression0 RPAREN . block0 condition1 SEMICOLON
    (124) block0 -> . LBRACKET block1 RBRACKET

    LBRACKET        shift and go to state 231

    block0                         shift and go to state 230

state 207

    (115) writing0 -> WRITE LPAREN writing1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 232
=======
    (37) attributes -> data_access simple_declaration . attributes
    (37) attributes -> . data_access simple_declaration attributes
    (38) attributes -> . simple_assignment attributes
    (39) attributes -> . empty
    (103) data_access -> . PRIVATE
    (104) data_access -> . PUBLIC
    (54) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (145) empty -> .

    PRIVATE         shift and go to state 170
    PUBLIC          shift and go to state 171
    ID              shift and go to state 172
    CONSTRUCT       reduce using rule 145 (empty -> .)

    data_access                    shift and go to state 168
    attributes                     shift and go to state 243
    simple_assignment              shift and go to state 169
    empty                          shift and go to state 209

state 207

    (53) simple_declaration -> ID . COLON type SEMICOLON

    COLON           shift and go to state 244
>>>>>>> Stashed changes


state 208

<<<<<<< Updated upstream
    (116) writing1 -> expression0 writing2 .

    RPAREN          reduce using rule 116 (writing1 -> expression0 writing2 .)
=======
    (38) attributes -> simple_assignment attributes .

    CONSTRUCT       reduce using rule 38 (attributes -> simple_assignment attributes .)
>>>>>>> Stashed changes


state 209

<<<<<<< Updated upstream
    (118) writing2 -> COMMA . writing1
    (116) writing1 -> . expression0 writing2
    (117) writing1 -> . CONST_STRING writing2
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 181
    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    writing1                       shift and go to state 233
    expression0                    shift and go to state 180
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 210

    (119) writing2 -> empty .

    RPAREN          reduce using rule 119 (writing2 -> empty .)


state 211

    (117) writing1 -> CONST_STRING writing2 .

    RPAREN          reduce using rule 117 (writing1 -> CONST_STRING writing2 .)
=======
    (39) attributes -> empty .

    CONSTRUCT       reduce using rule 39 (attributes -> empty .)


state 210

    (54) simple_assignment -> ID EQUALS . expression0 SEMICOLON
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    expression0                    shift and go to state 245
    exp0                           shift and go to state 53
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 211

    (20) function0 -> DEF id_def LPAREN params0 RPAREN ARROW . function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (21) function1 -> . type
    (22) function1 -> . VOID
    (49) type -> . INT
    (50) type -> . FLOAT
    (51) type -> . STRING
    (52) type -> . BOOL

    VOID            shift and go to state 248
    INT             shift and go to state 84
    FLOAT           shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
>>>>>>> Stashed changes

    function1                      shift and go to state 246
    type                           shift and go to state 247

state 212

<<<<<<< Updated upstream
    (123) while -> WHILE LPAREN expression0 RPAREN . block0
    (124) block0 -> . LBRACKET block1 RBRACKET

    LBRACKET        shift and go to state 231

    block0                         shift and go to state 234

state 213

    (48) simple_assignment -> ID EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 235


state 214

    (7) class0 -> CLASS ID class1 LBRACKET class2 constructor class3 . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 236
=======
    (42) params0 -> type ID params1 .

    RPAREN          reduce using rule 42 (params0 -> type ID params1 .)


state 213

    (44) params1 -> COMMA . params0
    (42) params0 -> . type ID params1
    (43) params0 -> . empty
    (49) type -> . INT
    (50) type -> . FLOAT
    (51) type -> . STRING
    (52) type -> . BOOL
    (145) empty -> .

    INT             shift and go to state 84
    FLOAT           shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    RPAREN          reduce using rule 145 (empty -> .)

    params0                        shift and go to state 249
    type                           shift and go to state 124
    empty                          shift and go to state 125

state 214

    (45) params1 -> empty .

    RPAREN          reduce using rule 45 (params1 -> empty .)
>>>>>>> Stashed changes


state 215

<<<<<<< Updated upstream
    (12) class3 -> methods .

    RBRACKET        reduce using rule 12 (class3 -> methods .)
=======
    (30) declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET . declaration2
    (31) declaration2 -> . LSQRBRACKET exp0 RSQRBRACKET
    (32) declaration2 -> . empty
    (145) empty -> .

    LSQRBRACKET     shift and go to state 250
    SEMICOLON       reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    declaration2                   shift and go to state 251
    empty                          shift and go to state 252

state 216

<<<<<<< Updated upstream
    (13) class3 -> empty .
    (35) methods -> empty .

  ! reduce/reduce conflict for RBRACKET resolved using rule 13 (class3 -> empty .)
    RBRACKET        reduce using rule 13 (class3 -> empty .)

  ! RBRACKET        [ reduce using rule 35 (methods -> empty .) ]
=======
    (113) condition0 -> IF LPAREN expression0 RPAREN block0 condition1 . SEMICOLON

    SEMICOLON       shift and go to state 253
>>>>>>> Stashed changes


state 217

<<<<<<< Updated upstream
    (34) methods -> data_access . function0 methods
    (14) function0 -> . DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    DEF             shift and go to state 13

    function0                      shift and go to state 237

state 218

    (29) constructor -> CONSTRUCT ID . LPAREN params0 RPAREN function_block0

    LPAREN          shift and go to state 238

=======
    (114) condition1 -> ELSE . block0
    (127) block0 -> . LBRACKET block1 RBRACKET

    LBRACKET        shift and go to state 177

    block0                         shift and go to state 254

state 218

    (115) condition1 -> empty .
>>>>>>> Stashed changes

    SEMICOLON       reduce using rule 115 (condition1 -> empty .)

<<<<<<< Updated upstream
    (31) attributes -> data_access simple_declaration attributes .

    CONSTRUCT       reduce using rule 31 (attributes -> data_access simple_declaration attributes .)
=======

state 219
>>>>>>> Stashed changes

    (127) block0 -> LBRACKET block1 . RBRACKET

    RBRACKET        shift and go to state 255

<<<<<<< Updated upstream
    (47) simple_declaration -> ID COLON . type SEMICOLON
    (43) type -> . INT
    (44) type -> . FLOAT
    (45) type -> . STRING
    (46) type -> . BOOL

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    STRING          shift and go to state 31
    BOOL            shift and go to state 32

    type                           shift and go to state 239

state 221

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 . LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    LSQRBRACKET     shift and go to state 240
=======

state 220

    (128) block1 -> statement . block1
    (128) block1 -> . statement block1
    (129) block1 -> . empty
    (130) statement -> . assignment0
    (131) statement -> . object_assignment
    (132) statement -> . condition0
    (133) statement -> . writing0
    (134) statement -> . reading
    (135) statement -> . return
    (136) statement -> . function_call SEMICOLON
    (137) statement -> . method_call0 SEMICOLON
    (138) statement -> . while
    (145) empty -> .
    (33) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (34) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (139) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 145 (empty -> .)
    ID              shift and go to state 222
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    statement                      shift and go to state 220
    block1                         shift and go to state 256
    empty                          shift and go to state 221
    assignment0                    shift and go to state 163
    object_assignment              shift and go to state 14
    condition0                     shift and go to state 15
    writing0                       shift and go to state 16
    reading                        shift and go to state 17
    return                         shift and go to state 18
    function_call                  shift and go to state 19
    method_call0                   shift and go to state 20
    while                          shift and go to state 21

state 221

    (129) block1 -> empty .

    RBRACKET        reduce using rule 129 (block1 -> empty .)
>>>>>>> Stashed changes


state 222

<<<<<<< Updated upstream
    (15) function1 -> type .

    LSQRBRACKET     reduce using rule 15 (function1 -> type .)
=======
    (33) assignment0 -> ID . EQUALS expression0 SEMICOLON
    (34) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (35) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (139) object_assignment -> ID . EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (84) function_call -> ID . LPAREN function_call_params0 RPAREN
    (102) method_call0 -> ID . DOT function_call

    EQUALS          shift and go to state 30
    LSQRBRACKET     shift and go to state 31
    LPAREN          shift and go to state 32
    DOT             shift and go to state 33
>>>>>>> Stashed changes


state 223

<<<<<<< Updated upstream
    (16) function1 -> VOID .

    LSQRBRACKET     reduce using rule 16 (function1 -> VOID .)
=======
    (116) writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .

    CLASS           reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
    DEF             reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
    ID              reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
    IF              reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
    WRITE           reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
    READ            reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
    RETURN          reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
    MAIN            reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 116 (writing0 -> WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON .)
>>>>>>> Stashed changes


state 224

<<<<<<< Updated upstream
    (38) params1 -> COMMA params0 .

    RPAREN          reduce using rule 38 (params1 -> COMMA params0 .)
=======
    (121) writing2 -> COMMA writing1 .

    RPAREN          reduce using rule 121 (writing2 -> COMMA writing1 .)
>>>>>>> Stashed changes


state 225

<<<<<<< Updated upstream
    (24) declaration2 -> LSQRBRACKET exp0 . RSQRBRACKET

    RSQRBRACKET     shift and go to state 241
=======
    (120) writing1 -> CONST_STRING push_string_val writing2 .

    RPAREN          reduce using rule 120 (writing1 -> CONST_STRING push_string_val writing2 .)
>>>>>>> Stashed changes


state 226

<<<<<<< Updated upstream
    (74) power1 -> LSQRBRACKET exp0 . RSQRBRACKET

    RSQRBRACKET     shift and go to state 242
=======
    (99) expression3 -> exp0 check_rel_operator .

    SEMICOLON       reduce using rule 99 (expression3 -> exp0 check_rel_operator .)
    COMMA           reduce using rule 99 (expression3 -> exp0 check_rel_operator .)
    RPAREN          reduce using rule 99 (expression3 -> exp0 check_rel_operator .)
>>>>>>> Stashed changes


state 227

<<<<<<< Updated upstream
    (73) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .

    MULTIPLY        reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    DIVIDE          reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    PLUS            reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    MINUS           reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    LTHAN           reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    GTHAN           reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    DIFFERENT       reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    EQUIVALENT      reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    SEMICOLON       reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    RSQRBRACKET     reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    RPAREN          reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
    COMMA           reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET power1 power2 .)
=======
    (76) power2 -> POWER push_pow_rad_op power0 .

    MULTIPLY        reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    DIVIDE          reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    PLUS            reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    MINUS           reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    LTHAN           reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    GTHAN           reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    DIFFERENT       reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    EQUIVALENT      reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    SEMICOLON       reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    RSQRBRACKET     reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    COMMA           reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
    RPAREN          reduce using rule 76 (power2 -> POWER push_pow_rad_op power0 .)
>>>>>>> Stashed changes


state 228

<<<<<<< Updated upstream
    (28) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS . expression0 SEMICOLON
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_BOOL      shift and go to state 36
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    exp0                           shift and go to state 35
    expression0                    shift and go to state 243
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 229

    (136) object_assignment -> ID EQUALS NEW ID LPAREN . function_call_params0 RPAREN SEMICOLON
    (83) function_call_params0 -> . expression0 function_call_params1
    (84) function_call_params0 -> . CONST_STRING function_call_params1
    (85) function_call_params0 -> . empty function_call_params1
    (88) expression0 -> . exp0 expression1
    (89) expression0 -> . CONST_BOOL expression1
    (90) expression0 -> . attr_access0 expression1
    (141) empty -> .
    (57) exp0 -> . term0 exp1
    (100) attr_access0 -> . ID DOT ID
    (61) term0 -> . factor term1
    (65) factor -> . PLUS power0
    (66) factor -> . MINUS power0
    (67) factor -> . power0
    (68) power0 -> . LPAREN exp0 RPAREN power2
    (69) power0 -> . const_var power2
    (70) power0 -> . function_call power2
    (71) power0 -> . method_call0 power2
    (72) power0 -> . attr_access0 power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET power1 power2
    (79) const_var -> . CONST_INT
    (80) const_var -> . CONST_FLOAT
    (81) const_var -> . ID
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call

    CONST_STRING    shift and go to state 124
    CONST_BOOL      shift and go to state 36
    COMMA           reduce using rule 141 (empty -> .)
    RPAREN          reduce using rule 141 (empty -> .)
    ID              shift and go to state 33
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    LPAREN          shift and go to state 43
    CONST_INT       shift and go to state 47
    CONST_FLOAT     shift and go to state 48

    function_call_params0          shift and go to state 244
    expression0                    shift and go to state 123
    empty                          shift and go to state 125
    exp0                           shift and go to state 35
    attr_access0                   shift and go to state 37
    term0                          shift and go to state 38
    factor                         shift and go to state 39
    power0                         shift and go to state 41
    const_var                      shift and go to state 44
    function_call                  shift and go to state 45
    method_call0                   shift and go to state 46

state 230

    (112) condition0 -> IF LPAREN expression0 RPAREN block0 . condition1 SEMICOLON
    (113) condition1 -> . ELSE block0
    (114) condition1 -> . empty
    (141) empty -> .

    ELSE            shift and go to state 246
    SEMICOLON       reduce using rule 141 (empty -> .)
=======
    (77) power2 -> SQRT push_pow_rad_op power0 .

    MULTIPLY        reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    DIVIDE          reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    PLUS            reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    MINUS           reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    LTHAN           reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    GTHAN           reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    DIFFERENT       reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    EQUIVALENT      reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    SEMICOLON       reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    RSQRBRACKET     reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    COMMA           reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)
    RPAREN          reduce using rule 77 (power2 -> SQRT push_pow_rad_op power0 .)


state 229

    (57) exp1 -> PLUS push_plus_minus_op exp0 .

    LTHAN           reduce using rule 57 (exp1 -> PLUS push_plus_minus_op exp0 .)
    GTHAN           reduce using rule 57 (exp1 -> PLUS push_plus_minus_op exp0 .)
    DIFFERENT       reduce using rule 57 (exp1 -> PLUS push_plus_minus_op exp0 .)
    EQUIVALENT      reduce using rule 57 (exp1 -> PLUS push_plus_minus_op exp0 .)
    SEMICOLON       reduce using rule 57 (exp1 -> PLUS push_plus_minus_op exp0 .)
    RSQRBRACKET     reduce using rule 57 (exp1 -> PLUS push_plus_minus_op exp0 .)
    COMMA           reduce using rule 57 (exp1 -> PLUS push_plus_minus_op exp0 .)
    RPAREN          reduce using rule 57 (exp1 -> PLUS push_plus_minus_op exp0 .)


state 230

    (58) exp1 -> MINUS push_plus_minus_op exp0 .

    LTHAN           reduce using rule 58 (exp1 -> MINUS push_plus_minus_op exp0 .)
    GTHAN           reduce using rule 58 (exp1 -> MINUS push_plus_minus_op exp0 .)
    DIFFERENT       reduce using rule 58 (exp1 -> MINUS push_plus_minus_op exp0 .)
    EQUIVALENT      reduce using rule 58 (exp1 -> MINUS push_plus_minus_op exp0 .)
    SEMICOLON       reduce using rule 58 (exp1 -> MINUS push_plus_minus_op exp0 .)
    RSQRBRACKET     reduce using rule 58 (exp1 -> MINUS push_plus_minus_op exp0 .)
    COMMA           reduce using rule 58 (exp1 -> MINUS push_plus_minus_op exp0 .)
    RPAREN          reduce using rule 58 (exp1 -> MINUS push_plus_minus_op exp0 .)
>>>>>>> Stashed changes

    condition1                     shift and go to state 245
    empty                          shift and go to state 247

state 231

<<<<<<< Updated upstream
    (124) block0 -> LBRACKET . block1 RBRACKET
    (125) block1 -> . statement block1
    (126) block1 -> . empty
    (127) statement -> . assignment0
    (128) statement -> . object_assignment
    (129) statement -> . condition0
    (130) statement -> . writing0
    (131) statement -> . reading
    (132) statement -> . return
    (133) statement -> . function_call SEMICOLON
    (134) statement -> . method_call0 SEMICOLON
    (135) statement -> . while
    (141) empty -> .
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (136) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (112) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (115) writing0 -> . WRITE LPAREN writing1 RPAREN SEMICOLON
    (120) reading -> . READ ID SEMICOLON
    (121) return -> . RETURN expression0 SEMICOLON
    (122) return -> . RETURN SEMICOLON
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (123) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 141 (empty -> .)
    ID              shift and go to state 251
    IF              shift and go to state 107
    WRITE           shift and go to state 108
    READ            shift and go to state 109
    RETURN          shift and go to state 110
    WHILE           shift and go to state 111

    block1                         shift and go to state 248
    statement                      shift and go to state 249
    empty                          shift and go to state 250
    assignment0                    shift and go to state 98
    object_assignment              shift and go to state 99
    condition0                     shift and go to state 100
    writing0                       shift and go to state 101
    reading                        shift and go to state 102
    return                         shift and go to state 103
    function_call                  shift and go to state 104
    method_call0                   shift and go to state 105
    while                          shift and go to state 106

state 232

    (115) writing0 -> WRITE LPAREN writing1 RPAREN SEMICOLON .

    ID              reduce using rule 115 (writing0 -> WRITE LPAREN writing1 RPAREN SEMICOLON .)
    IF              reduce using rule 115 (writing0 -> WRITE LPAREN writing1 RPAREN SEMICOLON .)
    WRITE           reduce using rule 115 (writing0 -> WRITE LPAREN writing1 RPAREN SEMICOLON .)
    READ            reduce using rule 115 (writing0 -> WRITE LPAREN writing1 RPAREN SEMICOLON .)
    RETURN          reduce using rule 115 (writing0 -> WRITE LPAREN writing1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 115 (writing0 -> WRITE LPAREN writing1 RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 115 (writing0 -> WRITE LPAREN writing1 RPAREN SEMICOLON .)
=======
    (73) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator . power1 power2
    (74) power1 -> . LSQRBRACKET exp0 RSQRBRACKET
    (75) power1 -> . empty
    (145) empty -> .

    LSQRBRACKET     shift and go to state 257
    POWER           reduce using rule 145 (empty -> .)
    SQRT            reduce using rule 145 (empty -> .)
    MULTIPLY        reduce using rule 145 (empty -> .)
    DIVIDE          reduce using rule 145 (empty -> .)
    PLUS            reduce using rule 145 (empty -> .)
    MINUS           reduce using rule 145 (empty -> .)
    LTHAN           reduce using rule 145 (empty -> .)
    GTHAN           reduce using rule 145 (empty -> .)
    DIFFERENT       reduce using rule 145 (empty -> .)
    EQUIVALENT      reduce using rule 145 (empty -> .)
    SEMICOLON       reduce using rule 145 (empty -> .)
    RSQRBRACKET     reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)

    power1                         shift and go to state 258
    empty                          shift and go to state 259

state 232

    (63) term1 -> MULTIPLY push_times_division_op term0 .

    PLUS            reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
    MINUS           reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
    LTHAN           reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
    GTHAN           reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
    DIFFERENT       reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
    EQUIVALENT      reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
    SEMICOLON       reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
    RSQRBRACKET     reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
    COMMA           reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
    RPAREN          reduce using rule 63 (term1 -> MULTIPLY push_times_division_op term0 .)
>>>>>>> Stashed changes


state 233

<<<<<<< Updated upstream
    (118) writing2 -> COMMA writing1 .

    RPAREN          reduce using rule 118 (writing2 -> COMMA writing1 .)
=======
    (64) term1 -> DIVIDE push_times_division_op term0 .

    PLUS            reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
    MINUS           reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
    LTHAN           reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
    GTHAN           reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
    DIFFERENT       reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
    EQUIVALENT      reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
    SEMICOLON       reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
    RSQRBRACKET     reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
    COMMA           reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
    RPAREN          reduce using rule 64 (term1 -> DIVIDE push_times_division_op term0 .)
>>>>>>> Stashed changes


state 234

<<<<<<< Updated upstream
    (123) while -> WHILE LPAREN expression0 RPAREN block0 .

    ID              reduce using rule 123 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    IF              reduce using rule 123 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    WRITE           reduce using rule 123 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    READ            reduce using rule 123 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    RETURN          reduce using rule 123 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    WHILE           reduce using rule 123 (while -> WHILE LPAREN expression0 RPAREN block0 .)
    RBRACKET        reduce using rule 123 (while -> WHILE LPAREN expression0 RPAREN block0 .)
=======
    (68) power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .

    MULTIPLY        reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    DIVIDE          reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    PLUS            reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    MINUS           reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    LTHAN           reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    GTHAN           reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    DIFFERENT       reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    EQUIVALENT      reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    SEMICOLON       reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    RSQRBRACKET     reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    COMMA           reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
    RPAREN          reduce using rule 68 (power0 -> LPAREN exp0 RPAREN check_pow_rad_operator power2 .)
>>>>>>> Stashed changes


state 235

<<<<<<< Updated upstream
    (48) simple_assignment -> ID EQUALS expression0 SEMICOLON .

    PRIVATE         reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    PUBLIC          reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    CONSTRUCT       reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    RSQRBRACKET     reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 48 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
=======
    (139) object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 260
>>>>>>> Stashed changes


state 236

<<<<<<< Updated upstream
    (7) class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 252
=======
    (35) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET . EQUALS expression0 SEMICOLON

    EQUALS          shift and go to state 261
>>>>>>> Stashed changes


state 237

<<<<<<< Updated upstream
    (34) methods -> data_access function0 . methods
    (34) methods -> . data_access function0 methods
    (35) methods -> . empty
    (102) data_access -> . PRIVATE
    (103) data_access -> . PUBLIC
    (141) empty -> .

    PRIVATE         shift and go to state 161
    PUBLIC          shift and go to state 162
    RBRACKET        reduce using rule 141 (empty -> .)
=======
    (34) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .

    CLASS           reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    DEF             reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    MAIN            reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 34 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
>>>>>>> Stashed changes

    data_access                    shift and go to state 217
    methods                        shift and go to state 253
    empty                          shift and go to state 254

state 238

<<<<<<< Updated upstream
    (29) constructor -> CONSTRUCT ID LPAREN . params0 RPAREN function_block0
    (36) params0 -> . type ID params1
    (37) params0 -> . empty
    (43) type -> . INT
    (44) type -> . FLOAT
    (45) type -> . STRING
    (46) type -> . BOOL
    (141) empty -> .

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    STRING          shift and go to state 31
    BOOL            shift and go to state 32
    RPAREN          reduce using rule 141 (empty -> .)

    params0                        shift and go to state 255
    type                           shift and go to state 116
    empty                          shift and go to state 117

state 239

    (47) simple_declaration -> ID COLON type . SEMICOLON

    SEMICOLON       shift and go to state 256
=======
    (9) class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 . RBRACKET SEMICOLON revert_global

    RBRACKET        shift and go to state 262


state 239

    (18) class3 -> methods .

    RBRACKET        reduce using rule 18 (class3 -> methods .)
>>>>>>> Stashed changes


state 240

<<<<<<< Updated upstream
    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET . LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0

    LSQRBRACKET     shift and go to state 257
=======
    (19) class3 -> empty .
    (41) methods -> empty .

  ! reduce/reduce conflict for RBRACKET resolved using rule 19 (class3 -> empty .)
    RBRACKET        reduce using rule 19 (class3 -> empty .)

  ! RBRACKET        [ reduce using rule 41 (methods -> empty .) ]
>>>>>>> Stashed changes


state 241

<<<<<<< Updated upstream
    (24) declaration2 -> LSQRBRACKET exp0 RSQRBRACKET .

    SEMICOLON       reduce using rule 24 (declaration2 -> LSQRBRACKET exp0 RSQRBRACKET .)


state 242

    (74) power1 -> LSQRBRACKET exp0 RSQRBRACKET .

    POWER           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    SQRT            reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    MULTIPLY        reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    DIVIDE          reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    PLUS            reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    MINUS           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    LTHAN           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    GTHAN           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    DIFFERENT       reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    EQUIVALENT      reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    SEMICOLON       reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    RSQRBRACKET     reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    RPAREN          reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    COMMA           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
=======
    (40) methods -> data_access . function0 methods
    (20) function0 -> . DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope

    DEF             shift and go to state 23

    function0                      shift and go to state 263

state 242

    (36) constructor -> CONSTRUCT ID . LPAREN params0 RPAREN function_block0

    LPAREN          shift and go to state 264
>>>>>>> Stashed changes


state 243

<<<<<<< Updated upstream
    (28) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 258
=======
    (37) attributes -> data_access simple_declaration attributes .

    CONSTRUCT       reduce using rule 37 (attributes -> data_access simple_declaration attributes .)
>>>>>>> Stashed changes


state 244

<<<<<<< Updated upstream
    (136) object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 . RPAREN SEMICOLON

    RPAREN          shift and go to state 259
=======
    (53) simple_declaration -> ID COLON . type SEMICOLON
    (49) type -> . INT
    (50) type -> . FLOAT
    (51) type -> . STRING
    (52) type -> . BOOL

    INT             shift and go to state 84
    FLOAT           shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
>>>>>>> Stashed changes

    type                           shift and go to state 265

state 245

<<<<<<< Updated upstream
    (112) condition0 -> IF LPAREN expression0 RPAREN block0 condition1 . SEMICOLON

    SEMICOLON       shift and go to state 260
=======
    (54) simple_assignment -> ID EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 266
>>>>>>> Stashed changes


state 246

<<<<<<< Updated upstream
    (113) condition1 -> ELSE . block0
    (124) block0 -> . LBRACKET block1 RBRACKET

    LBRACKET        shift and go to state 231
=======
    (20) function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 . LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope

    LSQRBRACKET     shift and go to state 267
>>>>>>> Stashed changes

    block0                         shift and go to state 261

state 247

<<<<<<< Updated upstream
    (114) condition1 -> empty .

    SEMICOLON       reduce using rule 114 (condition1 -> empty .)
=======
    (21) function1 -> type .

    LSQRBRACKET     reduce using rule 21 (function1 -> type .)
>>>>>>> Stashed changes


state 248

<<<<<<< Updated upstream
    (124) block0 -> LBRACKET block1 . RBRACKET

    RBRACKET        shift and go to state 262
=======
    (22) function1 -> VOID .

    LSQRBRACKET     reduce using rule 22 (function1 -> VOID .)
>>>>>>> Stashed changes


state 249

<<<<<<< Updated upstream
    (125) block1 -> statement . block1
    (125) block1 -> . statement block1
    (126) block1 -> . empty
    (127) statement -> . assignment0
    (128) statement -> . object_assignment
    (129) statement -> . condition0
    (130) statement -> . writing0
    (131) statement -> . reading
    (132) statement -> . return
    (133) statement -> . function_call SEMICOLON
    (134) statement -> . method_call0 SEMICOLON
    (135) statement -> . while
    (141) empty -> .
    (26) assignment0 -> . ID EQUALS expression0 SEMICOLON
    (27) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> . ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (136) object_assignment -> . ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (112) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (115) writing0 -> . WRITE LPAREN writing1 RPAREN SEMICOLON
    (120) reading -> . READ ID SEMICOLON
    (121) return -> . RETURN expression0 SEMICOLON
    (122) return -> . RETURN SEMICOLON
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (123) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 141 (empty -> .)
    ID              shift and go to state 251
    IF              shift and go to state 107
    WRITE           shift and go to state 108
    READ            shift and go to state 109
    RETURN          shift and go to state 110
    WHILE           shift and go to state 111

    statement                      shift and go to state 249
    block1                         shift and go to state 263
    empty                          shift and go to state 250
    assignment0                    shift and go to state 98
    object_assignment              shift and go to state 99
    condition0                     shift and go to state 100
    writing0                       shift and go to state 101
    reading                        shift and go to state 102
    return                         shift and go to state 103
    function_call                  shift and go to state 104
    method_call0                   shift and go to state 105
    while                          shift and go to state 106

state 250

    (126) block1 -> empty .

    RBRACKET        reduce using rule 126 (block1 -> empty .)


state 251

    (26) assignment0 -> ID . EQUALS expression0 SEMICOLON
    (27) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (28) assignment0 -> ID . LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON
    (136) object_assignment -> ID . EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON
    (82) function_call -> ID . LPAREN function_call_params0 RPAREN
    (101) method_call0 -> ID . DOT function_call

    EQUALS          shift and go to state 145
    LSQRBRACKET     shift and go to state 16
    LPAREN          shift and go to state 61
    DOT             shift and go to state 146
=======
    (44) params1 -> COMMA params0 .

    RPAREN          reduce using rule 44 (params1 -> COMMA params0 .)


state 250

    (31) declaration2 -> LSQRBRACKET . exp0 RSQRBRACKET
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 268
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 251

    (30) declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET declaration2 .

    SEMICOLON       reduce using rule 30 (declaration1 -> type LSQRBRACKET exp0 RSQRBRACKET declaration2 .)
>>>>>>> Stashed changes


state 252

<<<<<<< Updated upstream
    (7) class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .

    CLASS           reduce using rule 7 (class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .)
    DEF             reduce using rule 7 (class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .)
    ID              reduce using rule 7 (class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .)
    MAIN            reduce using rule 7 (class0 -> CLASS ID class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON .)
=======
    (32) declaration2 -> empty .

    SEMICOLON       reduce using rule 32 (declaration2 -> empty .)
>>>>>>> Stashed changes


state 253

<<<<<<< Updated upstream
    (34) methods -> data_access function0 methods .

    RBRACKET        reduce using rule 34 (methods -> data_access function0 methods .)
=======
    (113) condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .

    CLASS           reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    DEF             reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    ID              reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    IF              reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    WRITE           reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    READ            reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    RETURN          reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    WHILE           reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    MAIN            reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    RBRACKET        reduce using rule 113 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
>>>>>>> Stashed changes


state 254

<<<<<<< Updated upstream
    (35) methods -> empty .

    RBRACKET        reduce using rule 35 (methods -> empty .)
=======
    (114) condition1 -> ELSE block0 .

    SEMICOLON       reduce using rule 114 (condition1 -> ELSE block0 .)
>>>>>>> Stashed changes


state 255

<<<<<<< Updated upstream
    (29) constructor -> CONSTRUCT ID LPAREN params0 . RPAREN function_block0

    RPAREN          shift and go to state 264
=======
    (127) block0 -> LBRACKET block1 RBRACKET .

    ELSE            reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    SEMICOLON       reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    CLASS           reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    DEF             reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    ID              reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    IF              reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    WRITE           reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    READ            reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    RETURN          reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    WHILE           reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    MAIN            reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
    RBRACKET        reduce using rule 127 (block0 -> LBRACKET block1 RBRACKET .)
>>>>>>> Stashed changes


state 256

<<<<<<< Updated upstream
    (47) simple_declaration -> ID COLON type SEMICOLON .

    PRIVATE         reduce using rule 47 (simple_declaration -> ID COLON type SEMICOLON .)
    PUBLIC          reduce using rule 47 (simple_declaration -> ID COLON type SEMICOLON .)
    ID              reduce using rule 47 (simple_declaration -> ID COLON type SEMICOLON .)
    CONSTRUCT       reduce using rule 47 (simple_declaration -> ID COLON type SEMICOLON .)
    RSQRBRACKET     reduce using rule 47 (simple_declaration -> ID COLON type SEMICOLON .)
=======
    (128) block1 -> statement block1 .

    RBRACKET        reduce using rule 128 (block1 -> statement block1 .)
>>>>>>> Stashed changes


state 257

<<<<<<< Updated upstream
    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET . function2 RSQRBRACKET RSQRBRACKET function_block0
    (17) function2 -> . simple_declaration function2
    (18) function2 -> . simple_assignment function2
    (19) function2 -> . empty
    (47) simple_declaration -> . ID COLON type SEMICOLON
    (48) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (141) empty -> .

    ID              shift and go to state 265
    RSQRBRACKET     reduce using rule 141 (empty -> .)

    function2                      shift and go to state 266
    simple_declaration             shift and go to state 267
    simple_assignment              shift and go to state 268
    empty                          shift and go to state 269

state 258

    (28) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .

    CLASS           reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    DEF             reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    MAIN            reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 28 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)


state 259

    (136) object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 270
=======
    (74) power1 -> LSQRBRACKET . exp0 RSQRBRACKET
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (101) attr_access0 -> . ID DOT ID

    LPAREN          shift and go to state 58
    ID              shift and go to state 67
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 269
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61
    attr_access0                   shift and go to state 69

state 258

    (73) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 . power2
    (76) power2 -> . POWER push_pow_rad_op power0
    (77) power2 -> . SQRT push_pow_rad_op power0
    (78) power2 -> . empty
    (145) empty -> .

    POWER           shift and go to state 137
    SQRT            shift and go to state 138
    MULTIPLY        reduce using rule 145 (empty -> .)
    DIVIDE          reduce using rule 145 (empty -> .)
    PLUS            reduce using rule 145 (empty -> .)
    MINUS           reduce using rule 145 (empty -> .)
    LTHAN           reduce using rule 145 (empty -> .)
    GTHAN           reduce using rule 145 (empty -> .)
    DIFFERENT       reduce using rule 145 (empty -> .)
    EQUIVALENT      reduce using rule 145 (empty -> .)
    SEMICOLON       reduce using rule 145 (empty -> .)
    RSQRBRACKET     reduce using rule 145 (empty -> .)
    COMMA           reduce using rule 145 (empty -> .)
    RPAREN          reduce using rule 145 (empty -> .)

    power2                         shift and go to state 270
    empty                          shift and go to state 139

state 259

    (75) power1 -> empty .

    POWER           reduce using rule 75 (power1 -> empty .)
    SQRT            reduce using rule 75 (power1 -> empty .)
    MULTIPLY        reduce using rule 75 (power1 -> empty .)
    DIVIDE          reduce using rule 75 (power1 -> empty .)
    PLUS            reduce using rule 75 (power1 -> empty .)
    MINUS           reduce using rule 75 (power1 -> empty .)
    LTHAN           reduce using rule 75 (power1 -> empty .)
    GTHAN           reduce using rule 75 (power1 -> empty .)
    DIFFERENT       reduce using rule 75 (power1 -> empty .)
    EQUIVALENT      reduce using rule 75 (power1 -> empty .)
    SEMICOLON       reduce using rule 75 (power1 -> empty .)
    RSQRBRACKET     reduce using rule 75 (power1 -> empty .)
    COMMA           reduce using rule 75 (power1 -> empty .)
    RPAREN          reduce using rule 75 (power1 -> empty .)
>>>>>>> Stashed changes


state 260

<<<<<<< Updated upstream
    (112) condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .

    ID              reduce using rule 112 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    IF              reduce using rule 112 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    WRITE           reduce using rule 112 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    READ            reduce using rule 112 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    RETURN          reduce using rule 112 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    WHILE           reduce using rule 112 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)
    RBRACKET        reduce using rule 112 (condition0 -> IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON .)

=======
    (139) object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .
>>>>>>> Stashed changes

    CLASS           reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    DEF             reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    ID              reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    IF              reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    WRITE           reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    READ            reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    RETURN          reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    WHILE           reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    MAIN            reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 139 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)

<<<<<<< Updated upstream
    (113) condition1 -> ELSE block0 .

    SEMICOLON       reduce using rule 113 (condition1 -> ELSE block0 .)
=======

state 261
>>>>>>> Stashed changes

    (35) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS . expression0 SEMICOLON
    (90) expression0 -> . exp0 expression1
    (91) expression0 -> . attr_access0 expression1
    (56) exp0 -> . term0 check_last_plus_minus_operator exp1
    (101) attr_access0 -> . ID DOT ID
    (62) term0 -> . power0 check_last_times_division_operator term1
    (68) power0 -> . LPAREN exp0 RPAREN check_pow_rad_operator power2
    (69) power0 -> . const_var check_pow_rad_operator power2
    (70) power0 -> . function_call check_pow_rad_operator power2
    (71) power0 -> . method_call0 check_pow_rad_operator power2
    (72) power0 -> . attr_access0 check_pow_rad_operator power2
    (73) power0 -> . ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2
    (81) const_var -> . CONST_INT
    (82) const_var -> . CONST_FLOAT
    (83) const_var -> . ID
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call

    ID              shift and go to state 56
    LPAREN          shift and go to state 58
    CONST_INT       shift and go to state 62
    CONST_FLOAT     shift and go to state 63

    exp0                           shift and go to state 53
    expression0                    shift and go to state 271
    attr_access0                   shift and go to state 54
    term0                          shift and go to state 55
    power0                         shift and go to state 57
    const_var                      shift and go to state 59
    function_call                  shift and go to state 60
    method_call0                   shift and go to state 61

state 262

<<<<<<< Updated upstream
    (124) block0 -> LBRACKET block1 RBRACKET .

    ELSE            reduce using rule 124 (block0 -> LBRACKET block1 RBRACKET .)
    SEMICOLON       reduce using rule 124 (block0 -> LBRACKET block1 RBRACKET .)
    ID              reduce using rule 124 (block0 -> LBRACKET block1 RBRACKET .)
    IF              reduce using rule 124 (block0 -> LBRACKET block1 RBRACKET .)
    WRITE           reduce using rule 124 (block0 -> LBRACKET block1 RBRACKET .)
    READ            reduce using rule 124 (block0 -> LBRACKET block1 RBRACKET .)
    RETURN          reduce using rule 124 (block0 -> LBRACKET block1 RBRACKET .)
    WHILE           reduce using rule 124 (block0 -> LBRACKET block1 RBRACKET .)
    RBRACKET        reduce using rule 124 (block0 -> LBRACKET block1 RBRACKET .)
=======
    (9) class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET . SEMICOLON revert_global

    SEMICOLON       shift and go to state 272
>>>>>>> Stashed changes


state 263

<<<<<<< Updated upstream
    (125) block1 -> statement block1 .

    RBRACKET        reduce using rule 125 (block1 -> statement block1 .)
=======
    (40) methods -> data_access function0 . methods
    (40) methods -> . data_access function0 methods
    (41) methods -> . empty
    (103) data_access -> . PRIVATE
    (104) data_access -> . PUBLIC
    (145) empty -> .

    PRIVATE         shift and go to state 170
    PUBLIC          shift and go to state 171
    RBRACKET        reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    data_access                    shift and go to state 241
    methods                        shift and go to state 273
    empty                          shift and go to state 274

state 264

<<<<<<< Updated upstream
    (29) constructor -> CONSTRUCT ID LPAREN params0 RPAREN . function_block0
    (40) function_block0 -> . LBRACKET function_block1 RBRACKET

    LBRACKET        shift and go to state 272

    function_block0                shift and go to state 271

state 265

    (47) simple_declaration -> ID . COLON type SEMICOLON
    (48) simple_assignment -> ID . EQUALS expression0 SEMICOLON

    COLON           shift and go to state 220
    EQUALS          shift and go to state 185
=======
    (36) constructor -> CONSTRUCT ID LPAREN . params0 RPAREN function_block0
    (42) params0 -> . type ID params1
    (43) params0 -> . empty
    (49) type -> . INT
    (50) type -> . FLOAT
    (51) type -> . STRING
    (52) type -> . BOOL
    (145) empty -> .

    INT             shift and go to state 84
    FLOAT           shift and go to state 85
    STRING          shift and go to state 86
    BOOL            shift and go to state 87
    RPAREN          reduce using rule 145 (empty -> .)

    params0                        shift and go to state 275
    type                           shift and go to state 124
    empty                          shift and go to state 125

state 265

    (53) simple_declaration -> ID COLON type . SEMICOLON

    SEMICOLON       shift and go to state 276
>>>>>>> Stashed changes


state 266

<<<<<<< Updated upstream
    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 . RSQRBRACKET RSQRBRACKET function_block0

    RSQRBRACKET     shift and go to state 273
=======
    (54) simple_assignment -> ID EQUALS expression0 SEMICOLON .

    PRIVATE         reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    PUBLIC          reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    CONSTRUCT       reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    RSQRBRACKET     reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 54 (simple_assignment -> ID EQUALS expression0 SEMICOLON .)
>>>>>>> Stashed changes


state 267

<<<<<<< Updated upstream
    (17) function2 -> simple_declaration . function2
    (17) function2 -> . simple_declaration function2
    (18) function2 -> . simple_assignment function2
    (19) function2 -> . empty
    (47) simple_declaration -> . ID COLON type SEMICOLON
    (48) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (141) empty -> .

    ID              shift and go to state 265
    RSQRBRACKET     reduce using rule 141 (empty -> .)

    simple_declaration             shift and go to state 267
    function2                      shift and go to state 274
    simple_assignment              shift and go to state 268
    empty                          shift and go to state 269

state 268

    (18) function2 -> simple_assignment . function2
    (17) function2 -> . simple_declaration function2
    (18) function2 -> . simple_assignment function2
    (19) function2 -> . empty
    (47) simple_declaration -> . ID COLON type SEMICOLON
    (48) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (141) empty -> .

    ID              shift and go to state 265
    RSQRBRACKET     reduce using rule 141 (empty -> .)
=======
    (20) function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET . LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope

    LSQRBRACKET     shift and go to state 277


state 268

    (31) declaration2 -> LSQRBRACKET exp0 . RSQRBRACKET

    RSQRBRACKET     shift and go to state 278
>>>>>>> Stashed changes

    simple_assignment              shift and go to state 268
    function2                      shift and go to state 275
    simple_declaration             shift and go to state 267
    empty                          shift and go to state 269

state 269

<<<<<<< Updated upstream
    (19) function2 -> empty .

    RSQRBRACKET     reduce using rule 19 (function2 -> empty .)
=======
    (74) power1 -> LSQRBRACKET exp0 . RSQRBRACKET

    RSQRBRACKET     shift and go to state 279
>>>>>>> Stashed changes


state 270

<<<<<<< Updated upstream
    (136) object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .

    ID              reduce using rule 136 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    IF              reduce using rule 136 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    WRITE           reduce using rule 136 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    READ            reduce using rule 136 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    RETURN          reduce using rule 136 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    WHILE           reduce using rule 136 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 136 (object_assignment -> ID EQUALS NEW ID LPAREN function_call_params0 RPAREN SEMICOLON .)
=======
    (73) power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .

    MULTIPLY        reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    DIVIDE          reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    PLUS            reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    MINUS           reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    LTHAN           reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    GTHAN           reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    DIFFERENT       reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    EQUIVALENT      reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    SEMICOLON       reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    RSQRBRACKET     reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    COMMA           reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
    RPAREN          reduce using rule 73 (power0 -> ID LSQRBRACKET exp0 RSQRBRACKET check_pow_rad_operator power1 power2 .)
>>>>>>> Stashed changes


state 271

<<<<<<< Updated upstream
    (29) constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .

    PRIVATE         reduce using rule 29 (constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .)
    PUBLIC          reduce using rule 29 (constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .)
    RBRACKET        reduce using rule 29 (constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .)
=======
    (35) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 . SEMICOLON

    SEMICOLON       shift and go to state 280
>>>>>>> Stashed changes


state 272

<<<<<<< Updated upstream
    (40) function_block0 -> LBRACKET . function_block1 RBRACKET
    (41) function_block1 -> . function_statement function_block1
    (42) function_block1 -> . empty
    (104) function_statement -> . simple_assignment
    (105) function_statement -> . condition0
    (106) function_statement -> . writing0
    (107) function_statement -> . reading
    (108) function_statement -> . return
    (109) function_statement -> . function_call SEMICOLON
    (110) function_statement -> . method_call0 SEMICOLON
    (111) function_statement -> . while
    (141) empty -> .
    (48) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (112) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (115) writing0 -> . WRITE LPAREN writing1 RPAREN SEMICOLON
    (120) reading -> . READ ID SEMICOLON
    (121) return -> . RETURN expression0 SEMICOLON
    (122) return -> . RETURN SEMICOLON
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (123) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 141 (empty -> .)
    ID              shift and go to state 287
    IF              shift and go to state 107
    WRITE           shift and go to state 108
    READ            shift and go to state 109
    RETURN          shift and go to state 110
    WHILE           shift and go to state 111

    function_block1                shift and go to state 276
    function_statement             shift and go to state 277
    empty                          shift and go to state 278
    simple_assignment              shift and go to state 279
    condition0                     shift and go to state 280
    writing0                       shift and go to state 281
    reading                        shift and go to state 282
    return                         shift and go to state 283
    function_call                  shift and go to state 284
    method_call0                   shift and go to state 285
    while                          shift and go to state 286

state 273

    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET . RSQRBRACKET function_block0

    RSQRBRACKET     shift and go to state 288
=======
    (9) class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON . revert_global
    (10) revert_global -> .

    CLASS           reduce using rule 10 (revert_global -> .)
    DEF             reduce using rule 10 (revert_global -> .)
    ID              reduce using rule 10 (revert_global -> .)
    IF              reduce using rule 10 (revert_global -> .)
    WRITE           reduce using rule 10 (revert_global -> .)
    READ            reduce using rule 10 (revert_global -> .)
    RETURN          reduce using rule 10 (revert_global -> .)
    WHILE           reduce using rule 10 (revert_global -> .)
    MAIN            reduce using rule 10 (revert_global -> .)

    revert_global                  shift and go to state 281

state 273

    (40) methods -> data_access function0 methods .

    RBRACKET        reduce using rule 40 (methods -> data_access function0 methods .)
>>>>>>> Stashed changes


state 274

<<<<<<< Updated upstream
    (17) function2 -> simple_declaration function2 .

    RSQRBRACKET     reduce using rule 17 (function2 -> simple_declaration function2 .)
=======
    (41) methods -> empty .

    RBRACKET        reduce using rule 41 (methods -> empty .)
>>>>>>> Stashed changes


state 275

<<<<<<< Updated upstream
    (18) function2 -> simple_assignment function2 .

    RSQRBRACKET     reduce using rule 18 (function2 -> simple_assignment function2 .)
=======
    (36) constructor -> CONSTRUCT ID LPAREN params0 . RPAREN function_block0

    RPAREN          shift and go to state 282
>>>>>>> Stashed changes


state 276

<<<<<<< Updated upstream
    (40) function_block0 -> LBRACKET function_block1 . RBRACKET
=======
    (53) simple_declaration -> ID COLON type SEMICOLON .

    PRIVATE         reduce using rule 53 (simple_declaration -> ID COLON type SEMICOLON .)
    PUBLIC          reduce using rule 53 (simple_declaration -> ID COLON type SEMICOLON .)
    ID              reduce using rule 53 (simple_declaration -> ID COLON type SEMICOLON .)
    CONSTRUCT       reduce using rule 53 (simple_declaration -> ID COLON type SEMICOLON .)
    RSQRBRACKET     reduce using rule 53 (simple_declaration -> ID COLON type SEMICOLON .)

>>>>>>> Stashed changes

    RBRACKET        shift and go to state 289

<<<<<<< Updated upstream

state 277

    (41) function_block1 -> function_statement . function_block1
    (41) function_block1 -> . function_statement function_block1
    (42) function_block1 -> . empty
    (104) function_statement -> . simple_assignment
    (105) function_statement -> . condition0
    (106) function_statement -> . writing0
    (107) function_statement -> . reading
    (108) function_statement -> . return
    (109) function_statement -> . function_call SEMICOLON
    (110) function_statement -> . method_call0 SEMICOLON
    (111) function_statement -> . while
    (141) empty -> .
    (48) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (112) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (115) writing0 -> . WRITE LPAREN writing1 RPAREN SEMICOLON
    (120) reading -> . READ ID SEMICOLON
    (121) return -> . RETURN expression0 SEMICOLON
    (122) return -> . RETURN SEMICOLON
    (82) function_call -> . ID LPAREN function_call_params0 RPAREN
    (101) method_call0 -> . ID DOT function_call
    (123) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 141 (empty -> .)
    ID              shift and go to state 287
    IF              shift and go to state 107
    WRITE           shift and go to state 108
    READ            shift and go to state 109
    RETURN          shift and go to state 110
    WHILE           shift and go to state 111

    function_statement             shift and go to state 277
    function_block1                shift and go to state 290
    empty                          shift and go to state 278
    simple_assignment              shift and go to state 279
    condition0                     shift and go to state 280
    writing0                       shift and go to state 281
    reading                        shift and go to state 282
    return                         shift and go to state 283
    function_call                  shift and go to state 284
    method_call0                   shift and go to state 285
    while                          shift and go to state 286

state 278

    (42) function_block1 -> empty .

    RBRACKET        reduce using rule 42 (function_block1 -> empty .)
=======
    (20) function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET . function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope
    (23) function2 -> . simple_declaration function2
    (24) function2 -> . simple_assignment function2
    (25) function2 -> . empty
    (53) simple_declaration -> . ID COLON type SEMICOLON
    (54) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (145) empty -> .

    ID              shift and go to state 287
    RSQRBRACKET     reduce using rule 145 (empty -> .)

    function2                      shift and go to state 283
    simple_declaration             shift and go to state 284
    simple_assignment              shift and go to state 285
    empty                          shift and go to state 286

state 278

    (31) declaration2 -> LSQRBRACKET exp0 RSQRBRACKET .

    SEMICOLON       reduce using rule 31 (declaration2 -> LSQRBRACKET exp0 RSQRBRACKET .)
>>>>>>> Stashed changes


state 279

<<<<<<< Updated upstream
    (104) function_statement -> simple_assignment .

    ID              reduce using rule 104 (function_statement -> simple_assignment .)
    IF              reduce using rule 104 (function_statement -> simple_assignment .)
    WRITE           reduce using rule 104 (function_statement -> simple_assignment .)
    READ            reduce using rule 104 (function_statement -> simple_assignment .)
    RETURN          reduce using rule 104 (function_statement -> simple_assignment .)
    WHILE           reduce using rule 104 (function_statement -> simple_assignment .)
    RBRACKET        reduce using rule 104 (function_statement -> simple_assignment .)
=======
    (74) power1 -> LSQRBRACKET exp0 RSQRBRACKET .

    POWER           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    SQRT            reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    MULTIPLY        reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    DIVIDE          reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    PLUS            reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    MINUS           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    LTHAN           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    GTHAN           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    DIFFERENT       reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    EQUIVALENT      reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    SEMICOLON       reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    RSQRBRACKET     reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    COMMA           reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
    RPAREN          reduce using rule 74 (power1 -> LSQRBRACKET exp0 RSQRBRACKET .)
>>>>>>> Stashed changes


state 280

<<<<<<< Updated upstream
    (105) function_statement -> condition0 .

    ID              reduce using rule 105 (function_statement -> condition0 .)
    IF              reduce using rule 105 (function_statement -> condition0 .)
    WRITE           reduce using rule 105 (function_statement -> condition0 .)
    READ            reduce using rule 105 (function_statement -> condition0 .)
    RETURN          reduce using rule 105 (function_statement -> condition0 .)
    WHILE           reduce using rule 105 (function_statement -> condition0 .)
    RBRACKET        reduce using rule 105 (function_statement -> condition0 .)
=======
    (35) assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .

    CLASS           reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    DEF             reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    ID              reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    IF              reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    WRITE           reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    READ            reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    RETURN          reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    WHILE           reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    MAIN            reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
    RBRACKET        reduce using rule 35 (assignment0 -> ID LSQRBRACKET exp0 RSQRBRACKET LSQRBRACKET exp0 RSQRBRACKET EQUALS expression0 SEMICOLON .)
>>>>>>> Stashed changes


state 281

<<<<<<< Updated upstream
    (106) function_statement -> writing0 .

    ID              reduce using rule 106 (function_statement -> writing0 .)
    IF              reduce using rule 106 (function_statement -> writing0 .)
    WRITE           reduce using rule 106 (function_statement -> writing0 .)
    READ            reduce using rule 106 (function_statement -> writing0 .)
    RETURN          reduce using rule 106 (function_statement -> writing0 .)
    WHILE           reduce using rule 106 (function_statement -> writing0 .)
    RBRACKET        reduce using rule 106 (function_statement -> writing0 .)
=======
    (9) class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .

    CLASS           reduce using rule 9 (class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .)
    DEF             reduce using rule 9 (class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .)
    ID              reduce using rule 9 (class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .)
    IF              reduce using rule 9 (class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .)
    WRITE           reduce using rule 9 (class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .)
    READ            reduce using rule 9 (class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .)
    RETURN          reduce using rule 9 (class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .)
    WHILE           reduce using rule 9 (class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .)
    MAIN            reduce using rule 9 (class0 -> CLASS class_id_def class1 LBRACKET class2 constructor class3 RBRACKET SEMICOLON revert_global .)
>>>>>>> Stashed changes


state 282

<<<<<<< Updated upstream
    (107) function_statement -> reading .

    ID              reduce using rule 107 (function_statement -> reading .)
    IF              reduce using rule 107 (function_statement -> reading .)
    WRITE           reduce using rule 107 (function_statement -> reading .)
    READ            reduce using rule 107 (function_statement -> reading .)
    RETURN          reduce using rule 107 (function_statement -> reading .)
    WHILE           reduce using rule 107 (function_statement -> reading .)
    RBRACKET        reduce using rule 107 (function_statement -> reading .)


state 283

    (108) function_statement -> return .

    ID              reduce using rule 108 (function_statement -> return .)
    IF              reduce using rule 108 (function_statement -> return .)
    WRITE           reduce using rule 108 (function_statement -> return .)
    READ            reduce using rule 108 (function_statement -> return .)
    RETURN          reduce using rule 108 (function_statement -> return .)
    WHILE           reduce using rule 108 (function_statement -> return .)
    RBRACKET        reduce using rule 108 (function_statement -> return .)
=======
    (36) constructor -> CONSTRUCT ID LPAREN params0 RPAREN . function_block0
    (46) function_block0 -> . LBRACKET function_block1 RBRACKET

    LBRACKET        shift and go to state 289

    function_block0                shift and go to state 288

state 283

    (20) function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 . RSQRBRACKET RSQRBRACKET function_block0 revert_scope

    RSQRBRACKET     shift and go to state 290
>>>>>>> Stashed changes


state 284

<<<<<<< Updated upstream
    (109) function_statement -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 291
=======
    (23) function2 -> simple_declaration . function2
    (23) function2 -> . simple_declaration function2
    (24) function2 -> . simple_assignment function2
    (25) function2 -> . empty
    (53) simple_declaration -> . ID COLON type SEMICOLON
    (54) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (145) empty -> .

    ID              shift and go to state 287
    RSQRBRACKET     reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    simple_declaration             shift and go to state 284
    function2                      shift and go to state 291
    simple_assignment              shift and go to state 285
    empty                          shift and go to state 286

state 285

<<<<<<< Updated upstream
    (110) function_statement -> method_call0 . SEMICOLON

    SEMICOLON       shift and go to state 292
=======
    (24) function2 -> simple_assignment . function2
    (23) function2 -> . simple_declaration function2
    (24) function2 -> . simple_assignment function2
    (25) function2 -> . empty
    (53) simple_declaration -> . ID COLON type SEMICOLON
    (54) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (145) empty -> .

    ID              shift and go to state 287
    RSQRBRACKET     reduce using rule 145 (empty -> .)
>>>>>>> Stashed changes

    simple_assignment              shift and go to state 285
    function2                      shift and go to state 292
    simple_declaration             shift and go to state 284
    empty                          shift and go to state 286

state 286

<<<<<<< Updated upstream
    (111) function_statement -> while .

    ID              reduce using rule 111 (function_statement -> while .)
    IF              reduce using rule 111 (function_statement -> while .)
    WRITE           reduce using rule 111 (function_statement -> while .)
    READ            reduce using rule 111 (function_statement -> while .)
    RETURN          reduce using rule 111 (function_statement -> while .)
    WHILE           reduce using rule 111 (function_statement -> while .)
    RBRACKET        reduce using rule 111 (function_statement -> while .)
=======
    (25) function2 -> empty .

    RSQRBRACKET     reduce using rule 25 (function2 -> empty .)
>>>>>>> Stashed changes


state 287

<<<<<<< Updated upstream
    (48) simple_assignment -> ID . EQUALS expression0 SEMICOLON
    (82) function_call -> ID . LPAREN function_call_params0 RPAREN
    (101) method_call0 -> ID . DOT function_call

    EQUALS          shift and go to state 185
    LPAREN          shift and go to state 61
    DOT             shift and go to state 146
=======
    (53) simple_declaration -> ID . COLON type SEMICOLON
    (54) simple_assignment -> ID . EQUALS expression0 SEMICOLON

    COLON           shift and go to state 244
    EQUALS          shift and go to state 210
>>>>>>> Stashed changes


state 288

<<<<<<< Updated upstream
    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET . function_block0
    (40) function_block0 -> . LBRACKET function_block1 RBRACKET

    LBRACKET        shift and go to state 272
=======
    (36) constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .

    PRIVATE         reduce using rule 36 (constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .)
    PUBLIC          reduce using rule 36 (constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .)
    RBRACKET        reduce using rule 36 (constructor -> CONSTRUCT ID LPAREN params0 RPAREN function_block0 .)
>>>>>>> Stashed changes

    function_block0                shift and go to state 293

state 289

<<<<<<< Updated upstream
    (40) function_block0 -> LBRACKET function_block1 RBRACKET .

    PRIVATE         reduce using rule 40 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    PUBLIC          reduce using rule 40 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    RBRACKET        reduce using rule 40 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    CLASS           reduce using rule 40 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    DEF             reduce using rule 40 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    ID              reduce using rule 40 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    MAIN            reduce using rule 40 (function_block0 -> LBRACKET function_block1 RBRACKET .)


state 290

    (41) function_block1 -> function_statement function_block1 .

    RBRACKET        reduce using rule 41 (function_block1 -> function_statement function_block1 .)
=======
    (46) function_block0 -> LBRACKET . function_block1 RBRACKET
    (47) function_block1 -> . function_statement function_block1
    (48) function_block1 -> . empty
    (105) function_statement -> . simple_assignment
    (106) function_statement -> . condition0
    (107) function_statement -> . writing0
    (108) function_statement -> . reading
    (109) function_statement -> . return
    (110) function_statement -> . function_call SEMICOLON
    (111) function_statement -> . method_call0 SEMICOLON
    (112) function_statement -> . while
    (145) empty -> .
    (54) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 145 (empty -> .)
    ID              shift and go to state 304
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    function_block1                shift and go to state 293
    function_statement             shift and go to state 294
    empty                          shift and go to state 295
    simple_assignment              shift and go to state 296
    condition0                     shift and go to state 297
    writing0                       shift and go to state 298
    reading                        shift and go to state 299
    return                         shift and go to state 300
    function_call                  shift and go to state 301
    method_call0                   shift and go to state 302
    while                          shift and go to state 303

state 290

    (20) function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET . RSQRBRACKET function_block0 revert_scope

    RSQRBRACKET     shift and go to state 305
>>>>>>> Stashed changes


state 291

<<<<<<< Updated upstream
    (109) function_statement -> function_call SEMICOLON .

    ID              reduce using rule 109 (function_statement -> function_call SEMICOLON .)
    IF              reduce using rule 109 (function_statement -> function_call SEMICOLON .)
    WRITE           reduce using rule 109 (function_statement -> function_call SEMICOLON .)
    READ            reduce using rule 109 (function_statement -> function_call SEMICOLON .)
    RETURN          reduce using rule 109 (function_statement -> function_call SEMICOLON .)
    WHILE           reduce using rule 109 (function_statement -> function_call SEMICOLON .)
    RBRACKET        reduce using rule 109 (function_statement -> function_call SEMICOLON .)
=======
    (23) function2 -> simple_declaration function2 .

    RSQRBRACKET     reduce using rule 23 (function2 -> simple_declaration function2 .)
>>>>>>> Stashed changes


state 292

<<<<<<< Updated upstream
    (110) function_statement -> method_call0 SEMICOLON .

    ID              reduce using rule 110 (function_statement -> method_call0 SEMICOLON .)
    IF              reduce using rule 110 (function_statement -> method_call0 SEMICOLON .)
    WRITE           reduce using rule 110 (function_statement -> method_call0 SEMICOLON .)
    READ            reduce using rule 110 (function_statement -> method_call0 SEMICOLON .)
    RETURN          reduce using rule 110 (function_statement -> method_call0 SEMICOLON .)
    WHILE           reduce using rule 110 (function_statement -> method_call0 SEMICOLON .)
    RBRACKET        reduce using rule 110 (function_statement -> method_call0 SEMICOLON .)
=======
    (24) function2 -> simple_assignment function2 .

    RSQRBRACKET     reduce using rule 24 (function2 -> simple_assignment function2 .)
>>>>>>> Stashed changes


state 293

<<<<<<< Updated upstream
    (14) function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .

    CLASS           reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    DEF             reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    ID              reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    MAIN            reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    PRIVATE         reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    PUBLIC          reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
    RBRACKET        reduce using rule 14 (function0 -> DEF ID LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 .)
=======
    (46) function_block0 -> LBRACKET function_block1 . RBRACKET

    RBRACKET        shift and go to state 306


state 294

    (47) function_block1 -> function_statement . function_block1
    (47) function_block1 -> . function_statement function_block1
    (48) function_block1 -> . empty
    (105) function_statement -> . simple_assignment
    (106) function_statement -> . condition0
    (107) function_statement -> . writing0
    (108) function_statement -> . reading
    (109) function_statement -> . return
    (110) function_statement -> . function_call SEMICOLON
    (111) function_statement -> . method_call0 SEMICOLON
    (112) function_statement -> . while
    (145) empty -> .
    (54) simple_assignment -> . ID EQUALS expression0 SEMICOLON
    (113) condition0 -> . IF LPAREN expression0 RPAREN block0 condition1 SEMICOLON
    (116) writing0 -> . WRITE push_writing_op LPAREN writing1 RPAREN SEMICOLON
    (123) reading -> . READ ID SEMICOLON
    (124) return -> . RETURN expression0 SEMICOLON
    (125) return -> . RETURN SEMICOLON
    (84) function_call -> . ID LPAREN function_call_params0 RPAREN
    (102) method_call0 -> . ID DOT function_call
    (126) while -> . WHILE LPAREN expression0 RPAREN block0

    RBRACKET        reduce using rule 145 (empty -> .)
    ID              shift and go to state 304
    IF              shift and go to state 25
    WRITE           shift and go to state 26
    READ            shift and go to state 27
    RETURN          shift and go to state 28
    WHILE           shift and go to state 29

    function_statement             shift and go to state 294
    function_block1                shift and go to state 307
    empty                          shift and go to state 295
    simple_assignment              shift and go to state 296
    condition0                     shift and go to state 297
    writing0                       shift and go to state 298
    reading                        shift and go to state 299
    return                         shift and go to state 300
    function_call                  shift and go to state 301
    method_call0                   shift and go to state 302
    while                          shift and go to state 303

state 295

    (48) function_block1 -> empty .

    RBRACKET        reduce using rule 48 (function_block1 -> empty .)


state 296

    (105) function_statement -> simple_assignment .

    ID              reduce using rule 105 (function_statement -> simple_assignment .)
    IF              reduce using rule 105 (function_statement -> simple_assignment .)
    WRITE           reduce using rule 105 (function_statement -> simple_assignment .)
    READ            reduce using rule 105 (function_statement -> simple_assignment .)
    RETURN          reduce using rule 105 (function_statement -> simple_assignment .)
    WHILE           reduce using rule 105 (function_statement -> simple_assignment .)
    RBRACKET        reduce using rule 105 (function_statement -> simple_assignment .)


state 297

    (106) function_statement -> condition0 .

    ID              reduce using rule 106 (function_statement -> condition0 .)
    IF              reduce using rule 106 (function_statement -> condition0 .)
    WRITE           reduce using rule 106 (function_statement -> condition0 .)
    READ            reduce using rule 106 (function_statement -> condition0 .)
    RETURN          reduce using rule 106 (function_statement -> condition0 .)
    WHILE           reduce using rule 106 (function_statement -> condition0 .)
    RBRACKET        reduce using rule 106 (function_statement -> condition0 .)


state 298

    (107) function_statement -> writing0 .

    ID              reduce using rule 107 (function_statement -> writing0 .)
    IF              reduce using rule 107 (function_statement -> writing0 .)
    WRITE           reduce using rule 107 (function_statement -> writing0 .)
    READ            reduce using rule 107 (function_statement -> writing0 .)
    RETURN          reduce using rule 107 (function_statement -> writing0 .)
    WHILE           reduce using rule 107 (function_statement -> writing0 .)
    RBRACKET        reduce using rule 107 (function_statement -> writing0 .)


state 299

    (108) function_statement -> reading .

    ID              reduce using rule 108 (function_statement -> reading .)
    IF              reduce using rule 108 (function_statement -> reading .)
    WRITE           reduce using rule 108 (function_statement -> reading .)
    READ            reduce using rule 108 (function_statement -> reading .)
    RETURN          reduce using rule 108 (function_statement -> reading .)
    WHILE           reduce using rule 108 (function_statement -> reading .)
    RBRACKET        reduce using rule 108 (function_statement -> reading .)


state 300

    (109) function_statement -> return .

    ID              reduce using rule 109 (function_statement -> return .)
    IF              reduce using rule 109 (function_statement -> return .)
    WRITE           reduce using rule 109 (function_statement -> return .)
    READ            reduce using rule 109 (function_statement -> return .)
    RETURN          reduce using rule 109 (function_statement -> return .)
    WHILE           reduce using rule 109 (function_statement -> return .)
    RBRACKET        reduce using rule 109 (function_statement -> return .)


state 301

    (110) function_statement -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 308


state 302

    (111) function_statement -> method_call0 . SEMICOLON

    SEMICOLON       shift and go to state 309


state 303

    (112) function_statement -> while .

    ID              reduce using rule 112 (function_statement -> while .)
    IF              reduce using rule 112 (function_statement -> while .)
    WRITE           reduce using rule 112 (function_statement -> while .)
    READ            reduce using rule 112 (function_statement -> while .)
    RETURN          reduce using rule 112 (function_statement -> while .)
    WHILE           reduce using rule 112 (function_statement -> while .)
    RBRACKET        reduce using rule 112 (function_statement -> while .)


state 304

    (54) simple_assignment -> ID . EQUALS expression0 SEMICOLON
    (84) function_call -> ID . LPAREN function_call_params0 RPAREN
    (102) method_call0 -> ID . DOT function_call

    EQUALS          shift and go to state 210
    LPAREN          shift and go to state 32
    DOT             shift and go to state 33


state 305

    (20) function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET . function_block0 revert_scope
    (46) function_block0 -> . LBRACKET function_block1 RBRACKET

    LBRACKET        shift and go to state 289

    function_block0                shift and go to state 310

state 306

    (46) function_block0 -> LBRACKET function_block1 RBRACKET .

    PRIVATE         reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    PUBLIC          reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    RBRACKET        reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    CLASS           reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    DEF             reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    ID              reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    IF              reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    WRITE           reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    READ            reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    RETURN          reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    WHILE           reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)
    MAIN            reduce using rule 46 (function_block0 -> LBRACKET function_block1 RBRACKET .)


state 307

    (47) function_block1 -> function_statement function_block1 .

    RBRACKET        reduce using rule 47 (function_block1 -> function_statement function_block1 .)


state 308

    (110) function_statement -> function_call SEMICOLON .

    ID              reduce using rule 110 (function_statement -> function_call SEMICOLON .)
    IF              reduce using rule 110 (function_statement -> function_call SEMICOLON .)
    WRITE           reduce using rule 110 (function_statement -> function_call SEMICOLON .)
    READ            reduce using rule 110 (function_statement -> function_call SEMICOLON .)
    RETURN          reduce using rule 110 (function_statement -> function_call SEMICOLON .)
    WHILE           reduce using rule 110 (function_statement -> function_call SEMICOLON .)
    RBRACKET        reduce using rule 110 (function_statement -> function_call SEMICOLON .)


state 309

    (111) function_statement -> method_call0 SEMICOLON .

    ID              reduce using rule 111 (function_statement -> method_call0 SEMICOLON .)
    IF              reduce using rule 111 (function_statement -> method_call0 SEMICOLON .)
    WRITE           reduce using rule 111 (function_statement -> method_call0 SEMICOLON .)
    READ            reduce using rule 111 (function_statement -> method_call0 SEMICOLON .)
    RETURN          reduce using rule 111 (function_statement -> method_call0 SEMICOLON .)
    WHILE           reduce using rule 111 (function_statement -> method_call0 SEMICOLON .)
    RBRACKET        reduce using rule 111 (function_statement -> method_call0 SEMICOLON .)


state 310

    (20) function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 . revert_scope
    (11) revert_scope -> .

    CLASS           reduce using rule 11 (revert_scope -> .)
    DEF             reduce using rule 11 (revert_scope -> .)
    ID              reduce using rule 11 (revert_scope -> .)
    IF              reduce using rule 11 (revert_scope -> .)
    WRITE           reduce using rule 11 (revert_scope -> .)
    READ            reduce using rule 11 (revert_scope -> .)
    RETURN          reduce using rule 11 (revert_scope -> .)
    WHILE           reduce using rule 11 (revert_scope -> .)
    MAIN            reduce using rule 11 (revert_scope -> .)
    PRIVATE         reduce using rule 11 (revert_scope -> .)
    PUBLIC          reduce using rule 11 (revert_scope -> .)
    RBRACKET        reduce using rule 11 (revert_scope -> .)

    revert_scope                   shift and go to state 311

state 311

    (20) function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .

    CLASS           reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    DEF             reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    ID              reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    IF              reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    WRITE           reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    READ            reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    RETURN          reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    WHILE           reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    MAIN            reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    PRIVATE         reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    PUBLIC          reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
    RBRACKET        reduce using rule 20 (function0 -> DEF id_def LPAREN params0 RPAREN ARROW function1 LSQRBRACKET LSQRBRACKET function2 RSQRBRACKET RSQRBRACKET function_block0 revert_scope .)
>>>>>>> Stashed changes

WARNING: 
WARNING: Conflicts:
WARNING: 
<<<<<<< Updated upstream
WARNING: shift/reduce conflict for LTHAN in state 37 resolved as shift
WARNING: shift/reduce conflict for GTHAN in state 37 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 37 resolved as shift
WARNING: shift/reduce conflict for EQUIVALENT in state 37 resolved as shift
WARNING: reduce/reduce conflict in state 73 resolved using rule (power2 -> empty)
WARNING: rejected rule (expression1 -> empty) in state 73
WARNING: reduce/reduce conflict in state 129 resolved using rule (expression3 -> attr_access0)
WARNING: rejected rule (empty -> <empty>) in state 129
WARNING: reduce/reduce conflict in state 158 resolved using rule (class2 -> empty)
WARNING: rejected rule (attributes -> empty) in state 158
WARNING: reduce/reduce conflict in state 216 resolved using rule (class3 -> empty)
WARNING: rejected rule (methods -> empty) in state 216
=======
WARNING: shift/reduce conflict for CLASS in state 12 resolved as shift
WARNING: shift/reduce conflict for DEF in state 12 resolved as shift
WARNING: shift/reduce conflict for ID in state 12 resolved as shift
WARNING: shift/reduce conflict for IF in state 12 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 12 resolved as shift
WARNING: shift/reduce conflict for READ in state 12 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 12 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 12 resolved as shift
WARNING: shift/reduce conflict for LTHAN in state 54 resolved as shift
WARNING: shift/reduce conflict for GTHAN in state 54 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 54 resolved as shift
WARNING: shift/reduce conflict for EQUIVALENT in state 54 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (statement -> assignment0)
WARNING: rejected rule (empty -> <empty>) in state 12
WARNING: reduce/reduce conflict in state 54 resolved using rule (check_pow_rad_operator -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 54
WARNING: reduce/reduce conflict in state 167 resolved using rule (class2 -> empty)
WARNING: rejected rule (attributes -> empty) in state 167
WARNING: reduce/reduce conflict in state 185 resolved using rule (check_pow_rad_operator -> <empty>)
WARNING: rejected rule (expression3 -> attr_access0) in state 185
WARNING: reduce/reduce conflict in state 240 resolved using rule (class3 -> empty)
WARNING: rejected rule (methods -> empty) in state 240
WARNING: Rule (expression3 -> attr_access0) is never reduced
>>>>>>> Stashed changes
